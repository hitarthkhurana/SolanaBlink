"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@noble";
exports.ids = ["vendor-chunks/@noble"];
exports.modules = {

/***/ "(rsc)/../node_modules/@noble/curves/esm/_shortw_utils.js":
/*!**********************************************************!*\
  !*** ../node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(rsc)/../node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(rsc)/../node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs)=>(0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash)=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({\n            ...curveDef,\n            ...getHash(hash)\n        });\n    return Object.freeze({\n        ...create(defHash),\n        create\n    });\n} //# sourceMappingURL=_shortw_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL19zaG9ydHdfdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDMUI7QUFDcUI7QUFDUDtBQUN4RCx3Q0FBd0M7QUFDakMsU0FBU0ksUUFBUUMsSUFBSTtJQUN4QixPQUFPO1FBQ0hBO1FBQ0FMLE1BQU0sQ0FBQ00sS0FBSyxHQUFHQyxPQUFTUCx3REFBSUEsQ0FBQ0ssTUFBTUMsS0FBS0wsZ0VBQVdBLElBQUlNO1FBQ3ZETCxXQUFXQSw4REFBQUE7SUFDZjtBQUNKO0FBQ08sU0FBU00sWUFBWUMsUUFBUSxFQUFFQyxPQUFPO0lBQ3pDLE1BQU1DLFNBQVMsQ0FBQ04sT0FBU0YscUVBQVdBLENBQUM7WUFBRSxHQUFHTSxRQUFRO1lBQUUsR0FBR0wsUUFBUUMsS0FBSztRQUFDO0lBQ3JFLE9BQU9PLE9BQU9DLE1BQU0sQ0FBQztRQUFFLEdBQUdGLE9BQU9ELFFBQVE7UUFBRUM7SUFBTztBQUN0RCxFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcz84ZTZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMsIHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB3ZWllcnN0cmFzcyB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuLy8gY29ubmVjdHMgbm9ibGUtY3VydmVzIHRvIG5vYmxlLWhhc2hlc1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhhc2goaGFzaCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhhc2gsXG4gICAgICAgIGhtYWM6IChrZXksIC4uLm1zZ3MpID0+IGhtYWMoaGFzaCwga2V5LCBjb25jYXRCeXRlcyguLi5tc2dzKSksXG4gICAgICAgIHJhbmRvbUJ5dGVzLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWYsIGRlZkhhc2gpIHtcbiAgICBjb25zdCBjcmVhdGUgPSAoaGFzaCkgPT4gd2VpZXJzdHJhc3MoeyAuLi5jdXJ2ZURlZiwgLi4uZ2V0SGFzaChoYXNoKSB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLmNyZWF0ZShkZWZIYXNoKSwgY3JlYXRlIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3Nob3J0d191dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiaG1hYyIsImNvbmNhdEJ5dGVzIiwicmFuZG9tQnl0ZXMiLCJ3ZWllcnN0cmFzcyIsImdldEhhc2giLCJoYXNoIiwia2V5IiwibXNncyIsImNyZWF0ZUN1cnZlIiwiY3VydmVEZWYiLCJkZWZIYXNoIiwiY3JlYXRlIiwiT2JqZWN0IiwiZnJlZXplIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/@noble/curves/esm/_shortw_utils.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/@noble/curves/esm/abstract/curve.js":
/*!***********************************************************!*\
  !*** ../node_modules/@noble/curves/esm/abstract/curve.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item)=>{\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W)=>{\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return {\n            windows,\n            windowSize\n        };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder (elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\n         * - ùëä is the window size\n         * - ùëõ is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */ precomputeWindow (elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for(let window = 0; window < windows; window++){\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for(let i = 1; i < windowSize; i++){\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */ wNAF (W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for(let window = 0; window < windows; window++){\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                } else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return {\n                p,\n                f\n            };\n        },\n        wNAFCached (P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        }\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n} //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDcEUsMEJBQTBCO0FBQzRCO0FBQ1Y7QUFDNUMsTUFBTUcsTUFBTUMsT0FBTztBQUNuQixNQUFNQyxNQUFNRCxPQUFPO0FBQ25CLDZEQUE2RDtBQUM3RCxtR0FBbUc7QUFDbkcseURBQXlEO0FBQ3pELDREQUE0RDtBQUM1RCwrRUFBK0U7QUFDL0Usb0dBQW9HO0FBQ3BHLG9HQUFvRztBQUNwRyxxQ0FBcUM7QUFDckMsa0dBQWtHO0FBQ2xHLGdHQUFnRztBQUNoRyw4Q0FBOEM7QUFDdkMsU0FBU0UsS0FBS0MsQ0FBQyxFQUFFQyxJQUFJO0lBQ3hCLE1BQU1DLGtCQUFrQixDQUFDQyxXQUFXQztRQUNoQyxNQUFNQyxNQUFNRCxLQUFLRSxNQUFNO1FBQ3ZCLE9BQU9ILFlBQVlFLE1BQU1EO0lBQzdCO0lBQ0EsTUFBTUcsT0FBTyxDQUFDQztRQUNWLE1BQU1DLFVBQVVDLEtBQUtDLElBQUksQ0FBQ1YsT0FBT08sS0FBSyxHQUFHLGNBQWM7UUFDdkQsTUFBTUksYUFBYSxLQUFNSixDQUFBQSxJQUFJLElBQUksMEJBQTBCO1FBQzNELE9BQU87WUFBRUM7WUFBU0c7UUFBVztJQUNqQztJQUNBLE9BQU87UUFDSFY7UUFDQSx1Q0FBdUM7UUFDdkNXLGNBQWFDLEdBQUcsRUFBRUMsQ0FBQztZQUNmLElBQUlDLElBQUloQixFQUFFaUIsSUFBSTtZQUNkLElBQUlDLElBQUlKO1lBQ1IsTUFBT0MsSUFBSW5CLElBQUs7Z0JBQ1osSUFBSW1CLElBQUlqQixLQUNKa0IsSUFBSUEsRUFBRUcsR0FBRyxDQUFDRDtnQkFDZEEsSUFBSUEsRUFBRUUsTUFBTTtnQkFDWkwsTUFBTWpCO1lBQ1Y7WUFDQSxPQUFPa0I7UUFDWDtRQUNBOzs7Ozs7Ozs7U0FTQyxHQUNESyxrQkFBaUJQLEdBQUcsRUFBRU4sQ0FBQztZQUNuQixNQUFN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eEQseURBQWNBLENBQUN1RCxPQUFPO1FBQ2xCbkMsR0FBRztRQUNIcUMsR0FBRztRQUNIQyxJQUFJO1FBQ0pDLElBQUk7SUFDUixHQUFHO1FBQ0NDLFlBQVk7UUFDWkMsYUFBYTtJQUNqQjtJQUNBLGVBQWU7SUFDZixPQUFPQyxPQUFPQyxNQUFNLENBQUM7UUFDakIsR0FBR2hFLG9EQUFPQSxDQUFDd0QsTUFBTW5DLENBQUMsRUFBRW1DLE1BQU1LLFVBQVUsQ0FBQztRQUNyQyxHQUFHTCxLQUFLO1FBQ1IsR0FBRztZQUFFbEMsR0FBR2tDLE1BQU1DLEVBQUUsQ0FBQ1EsS0FBSztRQUFDLENBQUM7SUFDNUI7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanM/MmJkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBBYmVsaWFuIGdyb3VwIHV0aWxpdGllc1xuaW1wb3J0IHsgdmFsaWRhdGVGaWVsZCwgbkxlbmd0aCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuLy8gRWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gb2YgUG9pbnQgYnkgc2NhbGFyLiBGcmFnaWxlLlxuLy8gU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXG4vLyBDcmVhdGVzIHByZWNvbXB1dGF0aW9uIHRhYmxlcyBmb3IgZmFzdCBtdWx0aXBsaWNhdGlvbjpcbi8vIC0gcHJpdmF0ZSBzY2FsYXIgaXMgc3BsaXQgYnkgZml4ZWQgc2l6ZSB3aW5kb3dzIG9mIFcgYml0c1xuLy8gLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxuLy8gLSBzaW5jZSB3aW5kb3dzIGFyZSBkaWZmZXJlbnQsIHNhbWUgcG9pbnQgaW5zaWRlIHRhYmxlcyB3b24ndCBiZSBhY2Nlc3NlZCBtb3JlIHRoYW4gb25jZSBwZXIgY2FsY1xuLy8gLSBlYWNoIG11bHRpcGxpY2F0aW9uIGlzICdNYXRoLmNlaWwoQ1VSVkVfT1JERVIgLyDwnZGKKSArIDEnIHBvaW50IGFkZGl0aW9ucyAoZml4ZWQgZm9yIGFueSBzY2FsYXIpXG4vLyAtICsxIHdpbmRvdyBpcyBuZWNjZXNzYXJ5IGZvciB3TkFGXG4vLyAtIHdOQUYgcmVkdWNlcyB0YWJsZSBzaXplOiAyeCBsZXNzIG1lbW9yeSArIDJ4IGZhc3RlciBnZW5lcmF0aW9uLCBidXQgMTAlIHNsb3dlciBtdWx0aXBsaWNhdGlvblxuLy8gVE9ETzogUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LiBUaGlzIHdvdWxkIGFsbG93XG4vLyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG5leHBvcnQgZnVuY3Rpb24gd05BRihjLCBiaXRzKSB7XG4gICAgY29uc3QgY29uc3RUaW1lTmVnYXRlID0gKGNvbmRpdGlvbiwgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBuZWcgPSBpdGVtLm5lZ2F0ZSgpO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSAoVykgPT4ge1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKGJpdHMgLyBXKSArIDE7IC8vICsxLCBiZWNhdXNlXG4gICAgICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN0VGltZU5lZ2F0ZSxcbiAgICAgICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgICAgIHVuc2FmZUxhZGRlcihlbG0sIG4pIHtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGQgPSBlbG07XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXG4gICAgICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgICAgICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XG4gICAgICAgICAqIDJeKPCdkYriiJIxKSAqIChNYXRoLmNlaWwo8J2RmyAvIPCdkYopICsgMSksIHdoZXJlOlxuICAgICAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAgICAgICAqIC0g8J2RmyBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICAgICAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxuICAgICAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlV2luZG93KGVsbSwgVykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgLy8gPTEsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGNoZWNrIHRoYXQgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj8gd05BRiBiZWhhdmlvdXMgaXMgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gQnV0IG5lZWQgdG8gY2FyZWZ1bGx5IHJlbW92ZSBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZVxuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZiA9IGMuQkFTRTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMiAqKiBXIC0gMSk7IC8vIENyZWF0ZSBtYXNrIHdpdGggVyBvbmVzOiAwYjExMTEgZm9yIFc9NCBldGMuXG4gICAgICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG4gICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgVyBiaXRzLlxuICAgICAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cbiAgICAgICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBiaXRzIGFyZSBiaWdnZXIgdGhhbiBtYXggc2l6ZSwgd2UnbGwgc3BsaXQgdGhvc2UuXG4gICAgICAgICAgICAgICAgLy8gKzIyNCA9PiAyNTYgLSAzMlxuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBuICs9IF8xbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHdhcyBmaXJzdCB3cml0dGVuIHdpdGggYXNzdW1wdGlvbiB0aGF0ICdmJyBhbmQgJ3AnIHdpbGwgbmV2ZXIgYmUgaW5maW5pdHkgcG9pbnQ6XG4gICAgICAgICAgICAgICAgLy8gc2luY2UgZWFjaCBhZGRpdGlvbiBpcyBtdWx0aXBsaWVkIGJ5IDIgKiogVywgaXQgY2Fubm90IGNhbmNlbCBlYWNoIG90aGVyLiBIb3dldmVyLFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5lZ2F0ZSBub3c6IGl0IGlzIHBvc3NpYmxlIHRoYXQgbmVnYXRlZCBlbGVtZW50IGZyb20gbG93IHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gd291bGQgYmUgdGhlIHNhbWUgYXMgaGlnaCBlbGVtZW50LCB3aGljaCB3aWxsIGNyZWF0ZSBjYXJyeSBpbnRvIG5leHQgd2luZG93LlxuICAgICAgICAgICAgICAgIC8vIEl0J3Mgbm90IG9idmlvdXMgaG93IHRoaXMgY2FuIGZhaWwsIGJ1dCBzdGlsbCB3b3J0aCBpbnZlc3RpZ2F0aW5nIGxhdGVyLlxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIG9udG8gWmVybyBwb2ludC5cbiAgICAgICAgICAgICAgICAvLyBBZGQgcmFuZG9tIHBvaW50IGluc2lkZSBjdXJyZW50IHdpbmRvdyB0byBmLlxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDEgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IG9mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDEgPSB3aW5kb3cgJSAyICE9PSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQyID0gd2JpdHMgPCAwO1xuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBpbXBvcnRhbnQgcGFydCBmb3IgY29uc3QtdGltZSBnZXRQdWJsaWNLZXlcbiAgICAgICAgICAgICAgICAgICAgZiA9IGYuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMSwgcHJlY29tcHV0ZXNbb2Zmc2V0MV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDIsIHByZWNvbXB1dGVzW29mZnNldDJdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSklULWNvbXBpbGVyIHNob3VsZCBub3QgZWxpbWluYXRlIGYgaGVyZSwgc2luY2UgaXQgd2lsbCBsYXRlciBiZSB1c2VkIGluIG5vcm1hbGl6ZVooKVxuICAgICAgICAgICAgLy8gRXZlbiBpZiB0aGUgdmFyaWFibGUgaXMgc3RpbGwgdW51c2VkLCB0aGVyZSBhcmUgc29tZSBjaGVja3Mgd2hpY2ggd2lsbFxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uLCBzbyBjb21waWxlciBuZWVkcyB0byBwcm92ZSB0aGV5IHdvbid0IGhhcHBlbiwgd2hpY2ggaXMgaGFyZC5cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxuICAgICAgICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgbGVzcyBjb25zdC10aW1lOiBhcm91bmQgMSBiaWdpbnQgbXVsdGlwbHkuXG4gICAgICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWQoUCwgcHJlY29tcHV0ZXNNYXAsIG4sIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVyA9IFAuX1dJTkRPV19TSVpFIHx8IDE7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcHJlY29tcHV0ZXMgb24gYSBmaXJzdCBydW4sIHJldXNlIHRoZW0gYWZ0ZXJcbiAgICAgICAgICAgIGxldCBjb21wID0gcHJlY29tcHV0ZXNNYXAuZ2V0KFApO1xuICAgICAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKTtcbiAgICAgICAgICAgICAgICBpZiAoVyAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjb21wdXRlc01hcC5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIGNvbXAsIG4pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xuICAgIHZhbGlkYXRlRmllbGQoY3VydmUuRnApO1xuICAgIHZhbGlkYXRlT2JqZWN0KGN1cnZlLCB7XG4gICAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgICBoOiAnYmlnaW50JyxcbiAgICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4ubkxlbmd0aChjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAgICAgLi4uY3VydmUsXG4gICAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6WyJ2YWxpZGF0ZUZpZWxkIiwibkxlbmd0aCIsInZhbGlkYXRlT2JqZWN0IiwiXzBuIiwiQmlnSW50IiwiXzFuIiwid05BRiIsImMiLCJiaXRzIiwiY29uc3RUaW1lTmVnYXRlIiwiY29uZGl0aW9uIiwiaXRlbSIsIm5lZyIsIm5lZ2F0ZSIsIm9wdHMiLCJXIiwid2luZG93cyIsIk1hdGgiLCJjZWlsIiwid2luZG93U2l6ZSIsInVuc2FmZUxhZGRlciIsImVsbSIsIm4iLCJwIiwiWkVSTyIsImQiLCJhZGQiLCJkb3VibGUiLCJwcmVjb21wdXRlV2luZG93IiwicG9pbnRzIiwiYmFzZSIsIndpbmRvdyIsInB1c2giLCJpIiwicHJlY29tcHV0ZXMiLCJmIiwiQkFTRSIsIm1hc2siLCJtYXhOdW1iZXIiLCJzaGlmdEJ5Iiwib2Zmc2V0Iiwid2JpdHMiLCJOdW1iZXIiLCJvZmZzZXQxIiwib2Zmc2V0MiIsImFicyIsImNvbmQxIiwiY29uZDIiLCJ3TkFGQ2FjaGVkIiwiUCIsInByZWNvbXB1dGVzTWFwIiwidHJhbnNmb3JtIiwiX1dJTkRPV19TSVpFIiwiY29tcCIsImdldCIsInNldCIsInZhbGlkYXRlQmFzaWMiLCJjdXJ2ZSIsIkZwIiwiaCIsIkd4IiwiR3kiLCJuQml0TGVuZ3RoIiwibkJ5dGVMZW5ndGgiLCJPYmplY3QiLCJmcmVlemUiLCJPUkRFUiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/@noble/curves/esm/abstract/curve.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/@noble/curves/esm/abstract/edwards.js":
/*!*************************************************************!*\
  !*** ../node_modules/@noble/curves/esm/abstract/edwards.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   twistedEdwards: () => (/* binding */ twistedEdwards)\n/* harmony export */ });\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Twisted Edwards curve. The formula is: ax¬≤ + y¬≤ = 1 + dx¬≤y¬≤\n\n\n\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = {\n    zip215: true\n};\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(curve, {\n        hash: \"function\",\n        a: \"bigint\",\n        d: \"bigint\",\n        randomBytes: \"function\"\n    }, {\n        adjustScalarBytes: \"function\",\n        domain: \"function\",\n        uvRatio: \"function\",\n        mapToCurve: \"function\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...opts\n    });\n}\n// It is not generic twisted curve for now, but ed25519/ed448 generic implementation\nfunction twistedEdwards(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes, nByteLength, h: cofactor } = CURVE;\n    const MASK = _2n << BigInt(nByteLength * 8) - _1n;\n    const modP = Fp.create; // Function overrides\n    // sqrt(u/v)\n    const uvRatio = CURVE.uvRatio || ((u, v)=>{\n        try {\n            return {\n                isValid: true,\n                value: Fp.sqrt(u * Fp.inv(v))\n            };\n        } catch (e) {\n            return {\n                isValid: false,\n                value: _0n\n            };\n        }\n    });\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes)=>bytes); // NOOP\n    const domain = CURVE.domain || ((data, ctx, phflag)=>{\n        if (ctx.length || phflag) throw new Error(\"Contexts/pre-hash are not supported\");\n        return data;\n    }); // NOOP\n    const inBig = (n)=>typeof n === \"bigint\" && _0n < n; // n in [1..]\n    const inRange = (n, max)=>inBig(n) && inBig(max) && n < max; // n in [1..max-1]\n    const in0MaskRange = (n)=>n === _0n || inRange(n, MASK); // n in [0..MASK-1]\n    function assertInRange(n, max) {\n        // n in [1..max-1]\n        if (inRange(n, max)) return n;\n        throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);\n    }\n    function assertGE0(n) {\n        // n in [0..CURVE_ORDER-1]\n        return n === _0n ? n : assertInRange(n, CURVE_ORDER); // GE = prime subgroup, not full group\n    }\n    const pointPrecomputes = new Map();\n    function isPoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ExtendedPoint expected\");\n    }\n    // Extended Point works in extended coordinates: (x, y, z, t) ‚àã (x=x/z, y=y/z, t=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(ex, ey, ez, et){\n            this.ex = ex;\n            this.ey = ey;\n            this.ez = ez;\n            this.et = et;\n            if (!in0MaskRange(ex)) throw new Error(\"x required\");\n            if (!in0MaskRange(ey)) throw new Error(\"y required\");\n            if (!in0MaskRange(ez)) throw new Error(\"z required\");\n            if (!in0MaskRange(et)) throw new Error(\"t required\");\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point) throw new Error(\"extended point not allowed\");\n            const { x, y } = p || {};\n            if (!in0MaskRange(x) || !in0MaskRange(y)) throw new Error(\"invalid affine point\");\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p)=>p.ez));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // Not required for fromHex(), which always creates valid points.\n        // Could be useful for fromAffine().\n        assertValidity() {\n            const { a, d } = CURVE;\n            if (this.is0()) throw new Error(\"bad point: ZERO\"); // TODO: optimize, with vars below?\n            // Equation in affine coordinates: ax¬≤ + y¬≤ = 1 + dx¬≤y¬≤\n            // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX¬≤ + Y¬≤)Z¬≤ = Z‚Å¥ + dX¬≤Y¬≤\n            const { ex: X, ey: Y, ez: Z, et: T } = this;\n            const X2 = modP(X * X); // X¬≤\n            const Y2 = modP(Y * Y); // Y¬≤\n            const Z2 = modP(Z * Z); // Z¬≤\n            const Z4 = modP(Z2 * Z2); // Z‚Å¥\n            const aX2 = modP(X2 * a); // aX¬≤\n            const left = modP(Z2 * modP(aX2 + Y2)); // (aX¬≤ + Y¬≤)Z¬≤\n            const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z‚Å¥ + dX¬≤Y¬≤\n            if (left !== right) throw new Error(\"bad point: equation left != right (1)\");\n            // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n            const XY = modP(X * Y);\n            const ZT = modP(Z * T);\n            if (XY !== ZT) throw new Error(\"bad point: equation left != right (2)\");\n        }\n        // Compare one point to another.\n        equals(other) {\n            isPoint(other);\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            isPoint(other);\n            const { a, d } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n            // Faster algo for adding 2 Extended Points when curve's a=-1.\n            // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n            // Cost: 8M + 8add + 2*2.\n            // Note: It does not check whether the `other` point is valid.\n            if (a === BigInt(-1)) {\n                const A = modP((Y1 - X1) * (Y2 + X2));\n                const B = modP((Y1 + X1) * (Y2 - X2));\n                const F = modP(B - A);\n                if (F === _0n) return this.double(); // Same point. Tests say it doesn't affect timing\n                const C = modP(Z1 * _2n * T2);\n                const D = modP(T1 * _2n * Z2);\n                const E = D + C;\n                const G = B + A;\n                const H = D - C;\n                const X3 = modP(E * F);\n                const Y3 = modP(G * H);\n                const T3 = modP(E * H);\n                const Z3 = modP(F * G);\n                return new Point(X3, Y3, Z3, T3);\n            }\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));\n            return Point.normalizeZ([\n                p,\n                f\n            ])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        multiplyUnsafe(scalar) {\n            let n = assertGE0(scalar); // 0 <= scalar < CURVE.n\n            if (n === _0n) return I;\n            if (this.equals(I) || n === _1n) return this;\n            if (this.equals(G)) return this.wNAF(n).p;\n            return wnaf.unsafeLadder(this, n);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(iz) {\n            const { ex: x, ey: y, ez: z } = this;\n            const is0 = this.is0();\n            if (iz == null) iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n            const ax = modP(x * iz);\n            const ay = modP(y * iz);\n            const zz = modP(z * iz);\n            if (is0) return {\n                x: _0n,\n                y: _1n\n            };\n            if (zz !== _1n) throw new Error(\"invZ was invalid\");\n            return {\n                x: ax,\n                y: ay\n            };\n        }\n        clearCofactor() {\n            const { h: cofactor } = CURVE;\n            if (cofactor === _1n) return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        // Converts hash string or Uint8Array to Point.\n        // Uses algo from RFC8032 5.1.3.\n        static fromHex(hex, zip215 = false) {\n            const { d, a } = CURVE;\n            const len = Fp.BYTES;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"pointHex\", hex, len); // copy hex to a new array\n            const normed = hex.slice(); // copy again, we'll manipulate it\n            const lastByte = hex[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(normed);\n            if (y === _0n) {\n            // y=0 is allowed\n            } else {\n                // RFC8032 prohibits >= p, but ZIP215 doesn't\n                if (zip215) assertInRange(y, MASK); // zip215=true [1..P-1] (2^255-19-1 for ed25519)\n                else assertInRange(y, Fp.ORDER); // zip215=false [1..MASK-1] (2^256-1 for ed25519)\n            }\n            // Ed25519: x¬≤ = (y¬≤-1)/(dy¬≤+1) mod p. Ed448: x¬≤ = (y¬≤-1)/(dy¬≤-1) mod p. Generic case:\n            // ax¬≤+y¬≤=1+dx¬≤y¬≤ => y¬≤-1=dx¬≤y¬≤-ax¬≤ => y¬≤-1=x¬≤(dy¬≤-a) => x¬≤=(y¬≤-1)/(dy¬≤-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y¬≤ - 1\n            const v = modP(d * y2 - a); // v = d y¬≤ + 1.\n            let { isValid, value: x } = uvRatio(u, v); // ‚àö(u/v)\n            if (!isValid) throw new Error(\"Point.fromHex: invalid y coordinate\");\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd) // if x=0 and x_0 = 1, fail\n            throw new Error(\"Point.fromHex: x=0 and x_0=1\");\n            if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({\n                x,\n                y\n            });\n        }\n        static fromPrivateKey(privKey) {\n            return getExtendedPublicKey(privKey).point;\n        }\n        toRawBytes() {\n            const { x, y } = this.toAffine();\n            const bytes = _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n            return bytes; // and use the last byte to encode sign of x\n        }\n        toHex() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    const { BASE: G, ZERO: I } = Point;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, nByteLength * 8);\n    function modN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(a, CURVE_ORDER);\n    }\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return modN(_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(hash));\n    }\n    /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */ function getExtendedPublicKey(key) {\n        const len = nByteLength;\n        key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"private key\", key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"hashed private key\", cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        const point = G.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toRawBytes(); // Uint8Array representation\n        return {\n            head,\n            prefix,\n            scalar,\n            point,\n            pointBytes\n        };\n    }\n    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n    function getPublicKey(privKey) {\n        return getExtendedPublicKey(privKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {\n        const msg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...msgs);\n        return modN_LE(cHash(domain(msg, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"context\", context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */ function sign(msg, privKey, options = {}) {\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"message\", msg);\n        if (prehash) msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = G.multiply(r).toRawBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = modN(r + k * scalar); // S = (r + k * s) mod L\n        assertGE0(s); // 0 <= s < l\n        const res = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(R, _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE(s, Fp.BYTES));\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"result\", res, nByteLength * 2); // 64-byte signature\n    }\n    const verifyOpts = VERIFY_DEFAULT;\n    function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n        sig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"signature\", sig, 2 * len); // An extended group equation is checked.\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"message\", msg);\n        if (prehash) msg = prehash(msg); // for ed25519ph, etc\n        const s = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(sig.slice(len, 2 * len));\n        // zip215: true is good for consensus-critical apps and allows points < 2^256\n        // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p\n        let A, R, SB;\n        try {\n            A = Point.fromHex(publicKey, zip215);\n            R = Point.fromHex(sig.slice(0, len), zip215);\n            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n        } catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder()) return false;\n        const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n    }\n    G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    const utils = {\n        getExtendedPublicKey,\n        // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n        randomPrivateKey: ()=>randomBytes(Fp.BYTES),\n        /**\n         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n         * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n         * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n         * @param windowSize 2, 4, 8, 16\n         */ precompute (windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3));\n            return point;\n        }\n    };\n    return {\n        CURVE,\n        getPublicKey,\n        sign,\n        verify,\n        ExtendedPoint: Point,\n        utils\n    };\n} //# sourceMappingURL=edwards.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2Vkd2FyZHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLG9FQUFvRSxHQUNwRSw4REFBOEQ7QUFDYjtBQUNkO0FBQ0Y7QUFDUTtBQUN6QyxxRUFBcUU7QUFDckUsa0JBQWtCO0FBQ2xCLE1BQU1LLE1BQU1DLE9BQU8sSUFBSUMsTUFBTUQsT0FBTyxJQUFJRSxNQUFNRixPQUFPLElBQUlHLE1BQU1ILE9BQU87QUFDdEUsOEVBQThFO0FBQzlFLE1BQU1JLGlCQUFpQjtJQUFFQyxRQUFRO0FBQUs7QUFDdEMsU0FBU0MsYUFBYUMsS0FBSztJQUN2QixNQUFNQyxPQUFPZCx3REFBYUEsQ0FBQ2E7SUFDM0JWLHFEQUFpQixDQUFDVSxPQUFPO1FBQ3JCRyxNQUFNO1FBQ05DLEdBQUc7UUFDSEMsR0FBRztRQUNIQyxhQUFhO0lBQ2pCLEdBQUc7UUFDQ0MsbUJBQW1CO1FBQ25CQyxRQUFRO1FBQ1JDLFNBQVM7UUFDVEMsWUFBWTtJQUNoQjtJQUNBLGVBQWU7SUFDZixPQUFPQyxPQUFPQyxNQUFNLENBQUM7UUFBRSxHQUFHWCxJQUFJO0lBQUM7QUFDbkM7QUFDQSxvRkFBb0Y7QUFDN0UsU0FBU1ksZUFBZUMsUUFBUTtJQUNuQyxNQUFNQyxRQUFRaEIsYUFBYWU7SUFDM0IsTUFBTSxFQUFFRSxFQUFFLEVBQUVDLEdBQUdDLFdBQVcsRUFBRUMsU0FBU0EsT0FBTyxFQUFFaEIsTUFBTWlCLEtBQUssRUFBRWQsV0FBVyxFQUFFZSxXQUFXLEVBQUVDLEdBQUdDLFFBQVEsRUFBRyxHQUFHUjtJQUN0RyxNQUFNUyxPQUFPN0IsT0FBUUYsT0FBTzRCLGNBQWMsS0FBSzNCO0lBQy9DLE1BQU0rQixPQUFPVCxHQUFHVSxNQUFNLEVBQUUscUJBQXFCO0lBQzdDLFlBQVk7SUFDWixNQUFNakIsVUFBVU0sTUFBTU4sT0FBTyxJQUN4QixFQUFDa0IsR0FBR0M7UUFDRCxJQUFJO1lBQ0EsT0FBTztnQkFB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O1FBQ2ZtSTtJQUNKO0FBQ0osRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2Vkd2FyZHMuanM/ZjczZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBUd2lzdGVkIEVkd2FyZHMgY3VydmUuIFRoZSBmb3JtdWxhIGlzOiBheMKyICsgecKyID0gMSArIGR4wrJ5wrJcbmltcG9ydCB7IHZhbGlkYXRlQmFzaWMsIHdOQUYgfSBmcm9tICcuL2N1cnZlLmpzJztcbmltcG9ydCB7IG1vZCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgKiBhcyB1dCBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGVuc3VyZUJ5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzhuID0gQmlnSW50KDgpO1xuLy8gdmVyaWZpY2F0aW9uIHJ1bGUgaXMgZWl0aGVyIHppcDIxNSBvciByZmM4MDMyIC8gbmlzdDE4Ni01LiBDb25zdWx0IGZyb21IZXg6XG5jb25zdCBWRVJJRllfREVGQVVMVCA9IHsgemlwMjE1OiB0cnVlIH07XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgaGFzaDogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYTogJ2JpZ2ludCcsXG4gICAgICAgIGQ6ICdiaWdpbnQnLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9LCB7XG4gICAgICAgIGFkanVzdFNjYWxhckJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICBkb21haW46ICdmdW5jdGlvbicsXG4gICAgICAgIHV2UmF0aW86ICdmdW5jdGlvbicsXG4gICAgICAgIG1hcFRvQ3VydmU6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5vcHRzIH0pO1xufVxuLy8gSXQgaXMgbm90IGdlbmVyaWMgdHdpc3RlZCBjdXJ2ZSBmb3Igbm93LCBidXQgZWQyNTUxOS9lZDQ0OCBnZW5lcmljIGltcGxlbWVudGF0aW9uXG5leHBvcnQgZnVuY3Rpb24gdHdpc3RlZEVkd2FyZHMoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIsIHByZWhhc2g6IHByZWhhc2gsIGhhc2g6IGNIYXNoLCByYW5kb21CeXRlcywgbkJ5dGVMZW5ndGgsIGg6IGNvZmFjdG9yLCB9ID0gQ1VSVkU7XG4gICAgY29uc3QgTUFTSyA9IF8ybiA8PCAoQmlnSW50KG5CeXRlTGVuZ3RoICogOCkgLSBfMW4pO1xuICAgIGNvbnN0IG1vZFAgPSBGcC5jcmVhdGU7IC8vIEZ1bmN0aW9uIG92ZXJyaWRlc1xuICAgIC8vIHNxcnQodS92KVxuICAgIGNvbnN0IHV2UmF0aW8gPSBDVVJWRS51dlJhdGlvIHx8XG4gICAgICAgICgodSwgdikgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlLCB2YWx1ZTogRnAuc3FydCh1ICogRnAuaW52KHYpKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgdmFsdWU6IF8wbiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICBjb25zdCBhZGp1c3RTY2FsYXJCeXRlcyA9IENVUlZFLmFkanVzdFNjYWxhckJ5dGVzIHx8ICgoYnl0ZXMpID0+IGJ5dGVzKTsgLy8gTk9PUFxuICAgIGNvbnN0IGRvbWFpbiA9IENVUlZFLmRvbWFpbiB8fFxuICAgICAgICAoKGRhdGEsIGN0eCwgcGhmbGFnKSA9PiB7XG4gICAgICAgICAgICBpZiAoY3R4Lmxlbmd0aCB8fCBwaGZsYWcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZXh0cy9wcmUtaGFzaCBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pOyAvLyBOT09QXG4gICAgY29uc3QgaW5CaWcgPSAobikgPT4gdHlwZW9mIG4gPT09ICdiaWdpbnQnICYmIF8wbiA8IG47IC8vIG4gaW4gWzEuLl1cbiAgICBjb25zdCBpblJhbmdlID0gKG4sIG1heCkgPT4gaW5CaWcobikgJiYgaW5CaWcobWF4KSAmJiBuIDwgbWF4OyAvLyBuIGluIFsxLi5tYXgtMV1cbiAgICBjb25zdCBpbjBNYXNrUmFuZ2UgPSAobikgPT4gbiA9PT0gXzBuIHx8IGluUmFuZ2UobiwgTUFTSyk7IC8vIG4gaW4gWzAuLk1BU0stMV1cbiAgICBmdW5jdGlvbiBhc3NlcnRJblJhbmdlKG4sIG1heCkge1xuICAgICAgICAvLyBuIGluIFsxLi5tYXgtMV1cbiAgICAgICAgaWYgKGluUmFuZ2UobiwgbWF4KSlcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHZhbGlkIHNjYWxhciA8ICR7bWF4fSwgZ290ICR7dHlwZW9mIG59ICR7bn1gKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0R0UwKG4pIHtcbiAgICAgICAgLy8gbiBpbiBbMC4uQ1VSVkVfT1JERVItMV1cbiAgICAgICAgcmV0dXJuIG4gPT09IF8wbiA/IG4gOiBhc3NlcnRJblJhbmdlKG4sIENVUlZFX09SREVSKTsgLy8gR0UgPSBwcmltZSBzdWJncm91cCwgbm90IGZ1bGwgZ3JvdXBcbiAgICB9XG4gICAgY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBpc1BvaW50KG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHRlbmRlZFBvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIC8vIEV4dGVuZGVkIFBvaW50IHdvcmtzIGluIGV4dGVuZGVkIGNvb3JkaW5hdGVzOiAoeCwgeSwgeiwgdCkg4oiLICh4PXgveiwgeT15L3osIHQ9eHkpLlxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1R3aXN0ZWRfRWR3YXJkc19jdXJ2ZSNFeHRlbmRlZF9jb29yZGluYXRlc1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoZXgsIGV5LCBleiwgZXQpIHtcbiAgICAgICAgICAgIHRoaXMuZXggPSBleDtcbiAgICAgICAgICAgIHRoaXMuZXkgPSBleTtcbiAgICAgICAgICAgIHRoaXMuZXogPSBlejtcbiAgICAgICAgICAgIHRoaXMuZXQgPSBldDtcbiAgICAgICAgICAgIGlmICghaW4wTWFza1JhbmdlKGV4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmICghaW4wTWFza1JhbmdlKGV5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmICghaW4wTWFza1JhbmdlKGV6KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ogcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmICghaW4wTWFza1JhbmdlKGV0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3QgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXh0ZW5kZWQgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgICAgICAgIGlmICghaW4wTWFza1JhbmdlKHgpIHx8ICFpbjBNYXNrUmFuZ2UoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBfMW4sIG1vZFAoeCAqIHkpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2gocG9pbnRzLm1hcCgocCkgPT4gcC5leikpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb24ndCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB3aW5kb3dTaXplO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90IHJlcXVpcmVkIGZvciBmcm9tSGV4KCksIHdoaWNoIGFsd2F5cyBjcmVhdGVzIHZhbGlkIHBvaW50cy5cbiAgICAgICAgLy8gQ291bGQgYmUgdXNlZnVsIGZvciBmcm9tQWZmaW5lKCkuXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBkIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzMCgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7IC8vIFRPRE86IG9wdGltaXplLCB3aXRoIHZhcnMgYmVsb3c/XG4gICAgICAgICAgICAvLyBFcXVhdGlvbiBpbiBhZmZpbmUgY29vcmRpbmF0ZXM6IGF4wrIgKyB5wrIgPSAxICsgZHjCsnnCslxuICAgICAgICAgICAgLy8gRXF1YXRpb24gaW4gcHJvamVjdGl2ZSBjb29yZGluYXRlcyAoWC9aLCBZL1osIFopOiAgKGFYwrIgKyBZwrIpWsKyID0gWuKBtCArIGRYwrJZwrJcbiAgICAgICAgICAgIGNvbnN0IHsgZXg6IFgsIGV5OiBZLCBlejogWiwgZXQ6IFQgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBYMiA9IG1vZFAoWCAqIFgpOyAvLyBYwrJcbiAgICAgICAgICAgIGNvbnN0IFkyID0gbW9kUChZICogWSk7IC8vIFnCslxuICAgICAgICAgICAgY29uc3QgWjIgPSBtb2RQKFogKiBaKTsgLy8gWsKyXG4gICAgICAgICAgICBjb25zdCBaNCA9IG1vZFAoWjIgKiBaMik7IC8vIFrigbRcbiAgICAgICAgICAgIGNvbnN0IGFYMiA9IG1vZFAoWDIgKiBhKTsgLy8gYVjCslxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IG1vZFAoWjIgKiBtb2RQKGFYMiArIFkyKSk7IC8vIChhWMKyICsgWcKyKVrCslxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBtb2RQKFo0ICsgbW9kUChkICogbW9kUChYMiAqIFkyKSkpOyAvLyBa4oG0ICsgZFjCslnCslxuICAgICAgICAgICAgaWYgKGxlZnQgIT09IHJpZ2h0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0ICgxKScpO1xuICAgICAgICAgICAgLy8gSW4gRXh0ZW5kZWQgY29vcmRpbmF0ZXMgd2UgYWxzbyBoYXZlIFQsIHdoaWNoIGlzIHgqeT1UL1o6IGNoZWNrIFgqWSA9PSBaKlRcbiAgICAgICAgICAgIGNvbnN0IFhZID0gbW9kUChYICogWSk7XG4gICAgICAgICAgICBjb25zdCBaVCA9IG1vZFAoWiAqIFQpO1xuICAgICAgICAgICAgaWYgKFhZICE9PSBaVClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCAoMiknKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGlzUG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBleDogWDEsIGV5OiBZMSwgZXo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBleDogWDIsIGV5OiBZMiwgZXo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGNvbnN0IFgxWjIgPSBtb2RQKFgxICogWjIpO1xuICAgICAgICAgICAgY29uc3QgWDJaMSA9IG1vZFAoWDIgKiBaMSk7XG4gICAgICAgICAgICBjb25zdCBZMVoyID0gbW9kUChZMSAqIFoyKTtcbiAgICAgICAgICAgIGNvbnN0IFkyWjEgPSBtb2RQKFkyICogWjEpO1xuICAgICAgICAgICAgcmV0dXJuIFgxWjIgPT09IFgyWjEgJiYgWTFaMiA9PT0gWTJaMTtcbiAgICAgICAgfVxuICAgICAgICBpczAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoUG9pbnQuWkVSTyk7XG4gICAgICAgIH1cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgLy8gRmxpcHMgcG9pbnQgc2lnbiB0byBhIG5lZ2F0aXZlIG9uZSAoLXgsIHkgaW4gYWZmaW5lIGNvb3JkcylcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQobW9kUCgtdGhpcy5leCksIHRoaXMuZXksIHRoaXMuZXosIG1vZFAoLXRoaXMuZXQpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYXN0IGFsZ28gZm9yIGRvdWJsaW5nIEV4dGVuZGVkIFBvaW50LlxuICAgICAgICAvLyBodHRwczovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLmh0bWwjZG91YmxpbmctZGJsLTIwMDgtaHdjZFxuICAgICAgICAvLyBDb3N0OiA0TSArIDRTICsgMSphICsgNmFkZCArIDEqMi5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IHsgZXg6IFgxLCBleTogWTEsIGV6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IEEgPSBtb2RQKFgxICogWDEpOyAvLyBBID0gWDEyXG4gICAgICAgICAgICBjb25zdCBCID0gbW9kUChZMSAqIFkxKTsgLy8gQiA9IFkxMlxuICAgICAgICAgICAgY29uc3QgQyA9IG1vZFAoXzJuICogbW9kUChaMSAqIFoxKSk7IC8vIEMgPSAyKloxMlxuICAgICAgICAgICAgY29uc3QgRCA9IG1vZFAoYSAqIEEpOyAvLyBEID0gYSpBXG4gICAgICAgICAgICBjb25zdCB4MXkxID0gWDEgKyBZMTtcbiAgICAgICAgICAgIGNvbnN0IEUgPSBtb2RQKG1vZFAoeDF5MSAqIHgxeTEpIC0gQSAtIEIpOyAvLyBFID0gKFgxK1kxKTItQS1CXG4gICAgICAgICAgICBjb25zdCBHID0gRCArIEI7IC8vIEcgPSBEK0JcbiAgICAgICAgICAgIGNvbnN0IEYgPSBHIC0gQzsgLy8gRiA9IEctQ1xuICAgICAgICAgICAgY29uc3QgSCA9IEQgLSBCOyAvLyBIID0gRC1CXG4gICAgICAgICAgICBjb25zdCBYMyA9IG1vZFAoRSAqIEYpOyAvLyBYMyA9IEUqRlxuICAgICAgICAgICAgY29uc3QgWTMgPSBtb2RQKEcgKiBIKTsgLy8gWTMgPSBHKkhcbiAgICAgICAgICAgIGNvbnN0IFQzID0gbW9kUChFICogSCk7IC8vIFQzID0gRSpIXG4gICAgICAgICAgICBjb25zdCBaMyA9IG1vZFAoRiAqIEcpOyAvLyBaMyA9IEYqR1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFzdCBhbGdvIGZvciBhZGRpbmcgMiBFeHRlbmRlZCBQb2ludHMuXG4gICAgICAgIC8vIGh0dHBzOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQuaHRtbCNhZGRpdGlvbi1hZGQtMjAwOC1od2NkXG4gICAgICAgIC8vIENvc3Q6IDlNICsgMSphICsgMSpkICsgN2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBpc1BvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgYSwgZCB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCB7IGV4OiBYMSwgZXk6IFkxLCBlejogWjEsIGV0OiBUMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZXg6IFgyLCBleTogWTIsIGV6OiBaMiwgZXQ6IFQyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIC8vIEZhc3RlciBhbGdvIGZvciBhZGRpbmcgMiBFeHRlbmRlZCBQb2ludHMgd2hlbiBjdXJ2ZSdzIGE9LTEuXG4gICAgICAgICAgICAvLyBodHRwOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQtMS5odG1sI2FkZGl0aW9uLWFkZC0yMDA4LWh3Y2QtNFxuICAgICAgICAgICAgLy8gQ29zdDogOE0gKyA4YWRkICsgMioyLlxuICAgICAgICAgICAgLy8gTm90ZTogSXQgZG9lcyBub3QgY2hlY2sgd2hldGhlciB0aGUgYG90aGVyYCBwb2ludCBpcyB2YWxpZC5cbiAgICAgICAgICAgIGlmIChhID09PSBCaWdJbnQoLTEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgQSA9IG1vZFAoKFkxIC0gWDEpICogKFkyICsgWDIpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBCID0gbW9kUCgoWTEgKyBYMSkgKiAoWTIgLSBYMikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEYgPSBtb2RQKEIgLSBBKTtcbiAgICAgICAgICAgICAgICBpZiAoRiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb3VibGUoKTsgLy8gU2FtZSBwb2ludC4gVGVzdHMgc2F5IGl0IGRvZXNuJ3QgYWZmZWN0IHRpbWluZ1xuICAgICAgICAgICAgICAgIGNvbnN0IEMgPSBtb2RQKFoxICogXzJuICogVDIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEQgPSBtb2RQKFQxICogXzJuICogWjIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEUgPSBEICsgQztcbiAgICAgICAgICAgICAgICBjb25zdCBHID0gQiArIEE7XG4gICAgICAgICAgICAgICAgY29uc3QgSCA9IEQgLSBDO1xuICAgICAgICAgICAgICAgIGNvbnN0IFgzID0gbW9kUChFICogRik7XG4gICAgICAgICAgICAgICAgY29uc3QgWTMgPSBtb2RQKEcgKiBIKTtcbiAgICAgICAgICAgICAgICBjb25zdCBUMyA9IG1vZFAoRSAqIEgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFozID0gbW9kUChGICogRyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBBID0gbW9kUChYMSAqIFgyKTsgLy8gQSA9IFgxKlgyXG4gICAgICAgICAgICBjb25zdCBCID0gbW9kUChZMSAqIFkyKTsgLy8gQiA9IFkxKlkyXG4gICAgICAgICAgICBjb25zdCBDID0gbW9kUChUMSAqIGQgKiBUMik7IC8vIEMgPSBUMSpkKlQyXG4gICAgICAgICAgICBjb25zdCBEID0gbW9kUChaMSAqIFoyKTsgLy8gRCA9IFoxKloyXG4gICAgICAgICAgICBjb25zdCBFID0gbW9kUCgoWDEgKyBZMSkgKiAoWDIgKyBZMikgLSBBIC0gQik7IC8vIEUgPSAoWDErWTEpKihYMitZMiktQS1CXG4gICAgICAgICAgICBjb25zdCBGID0gRCAtIEM7IC8vIEYgPSBELUNcbiAgICAgICAgICAgIGNvbnN0IEcgPSBEICsgQzsgLy8gRyA9IEQrQ1xuICAgICAgICAgICAgY29uc3QgSCA9IG1vZFAoQiAtIGEgKiBBKTsgLy8gSCA9IEItYSpBXG4gICAgICAgICAgICBjb25zdCBYMyA9IG1vZFAoRSAqIEYpOyAvLyBYMyA9IEUqRlxuICAgICAgICAgICAgY29uc3QgWTMgPSBtb2RQKEcgKiBIKTsgLy8gWTMgPSBHKkhcbiAgICAgICAgICAgIGNvbnN0IFQzID0gbW9kUChFICogSCk7IC8vIFQzID0gRSpIXG4gICAgICAgICAgICBjb25zdCBaMyA9IG1vZFAoRiAqIEcpOyAvLyBaMyA9IEYqR1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgd05BRihuKSB7XG4gICAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkKHRoaXMsIHBvaW50UHJlY29tcHV0ZXMsIG4sIFBvaW50Lm5vcm1hbGl6ZVopO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYoYXNzZXJ0SW5SYW5nZShzY2FsYXIsIENVUlZFX09SREVSKSk7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcCwgZl0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgLy8gSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgLy8gYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24uXG4gICAgICAgIC8vIERvZXMgTk9UIGFsbG93IHNjYWxhcnMgaGlnaGVyIHRoYW4gQ1VSVkUubi5cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUoc2NhbGFyKSB7XG4gICAgICAgICAgICBsZXQgbiA9IGFzc2VydEdFMChzY2FsYXIpOyAvLyAwIDw9IHNjYWxhciA8IENVUlZFLm5cbiAgICAgICAgICAgIGlmIChuID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIEk7XG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbHMoSSkgfHwgbiA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWxzKEcpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUYobikucDtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBuKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVja3MgaWYgcG9pbnQgaXMgb2Ygc21hbGwgb3JkZXIuXG4gICAgICAgIC8vIElmIHlvdSBhZGQgc29tZXRoaW5nIHRvIHNtYWxsIG9yZGVyIHBvaW50LCB5b3Ugd2lsbCBoYXZlIFwiZGlydHlcIlxuICAgICAgICAvLyBwb2ludCB3aXRoIHRvcnNpb24gY29tcG9uZW50LlxuICAgICAgICAvLyBNdWx0aXBsaWVzIHBvaW50IGJ5IGNvZmFjdG9yIGFuZCBjaGVja3MgaWYgdGhlIHJlc3VsdCBpcyAwLlxuICAgICAgICBpc1NtYWxsT3JkZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShjb2ZhY3RvcikuaXMwKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGllcyBwb2ludCBieSBjdXJ2ZSBvcmRlciBhbmQgY2hlY2tzIGlmIHRoZSByZXN1bHQgaXMgMC5cbiAgICAgICAgLy8gUmV0dXJucyBgZmFsc2VgIGlzIHRoZSBwb2ludCBpcyBkaXJ0eS5cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBDVVJWRV9PUkRFUikuaXMwKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgRXh0ZW5kZWQgcG9pbnQgdG8gZGVmYXVsdCAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgICAgICB0b0FmZmluZShpeikge1xuICAgICAgICAgICAgY29uc3QgeyBleDogeCwgZXk6IHksIGV6OiB6IH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gdGhpcy5pczAoKTtcbiAgICAgICAgICAgIGlmIChpeiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGl6ID0gaXMwID8gXzhuIDogRnAuaW52KHopOyAvLyA4IHdhcyBjaG9zZW4gYXJiaXRyYXJpbHlcbiAgICAgICAgICAgIGNvbnN0IGF4ID0gbW9kUCh4ICogaXopO1xuICAgICAgICAgICAgY29uc3QgYXkgPSBtb2RQKHkgKiBpeik7XG4gICAgICAgICAgICBjb25zdCB6eiA9IG1vZFAoeiAqIGl6KTtcbiAgICAgICAgICAgIGlmIChpczApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogXzBuLCB5OiBfMW4gfTtcbiAgICAgICAgICAgIGlmICh6eiAhPT0gXzFuKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJDb2ZhY3RvcigpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShjb2ZhY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgaGFzaCBzdHJpbmcgb3IgVWludDhBcnJheSB0byBQb2ludC5cbiAgICAgICAgLy8gVXNlcyBhbGdvIGZyb20gUkZDODAzMiA1LjEuMy5cbiAgICAgICAgc3RhdGljIGZyb21IZXgoaGV4LCB6aXAyMTUgPSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgeyBkLCBhIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IEZwLkJZVEVTO1xuICAgICAgICAgICAgaGV4ID0gZW5zdXJlQnl0ZXMoJ3BvaW50SGV4JywgaGV4LCBsZW4pOyAvLyBjb3B5IGhleCB0byBhIG5ldyBhcnJheVxuICAgICAgICAgICAgY29uc3Qgbm9ybWVkID0gaGV4LnNsaWNlKCk7IC8vIGNvcHkgYWdhaW4sIHdlJ2xsIG1hbmlwdWxhdGUgaXRcbiAgICAgICAgICAgIGNvbnN0IGxhc3RCeXRlID0gaGV4W2xlbiAtIDFdOyAvLyBzZWxlY3QgbGFzdCBieXRlXG4gICAgICAgICAgICBub3JtZWRbbGVuIC0gMV0gPSBsYXN0Qnl0ZSAmIH4weDgwOyAvLyBjbGVhciBsYXN0IGJpdFxuICAgICAgICAgICAgY29uc3QgeSA9IHV0LmJ5dGVzVG9OdW1iZXJMRShub3JtZWQpO1xuICAgICAgICAgICAgaWYgKHkgPT09IF8wbikge1xuICAgICAgICAgICAgICAgIC8vIHk9MCBpcyBhbGxvd2VkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSRkM4MDMyIHByb2hpYml0cyA+PSBwLCBidXQgWklQMjE1IGRvZXNuJ3RcbiAgICAgICAgICAgICAgICBpZiAoemlwMjE1KVxuICAgICAgICAgICAgICAgICAgICBhc3NlcnRJblJhbmdlKHksIE1BU0spOyAvLyB6aXAyMTU9dHJ1ZSBbMS4uUC0xXSAoMl4yNTUtMTktMSBmb3IgZWQyNTUxOSlcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydEluUmFuZ2UoeSwgRnAuT1JERVIpOyAvLyB6aXAyMTU9ZmFsc2UgWzEuLk1BU0stMV0gKDJeMjU2LTEgZm9yIGVkMjU1MTkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFZDI1NTE5OiB4wrIgPSAoecKyLTEpLyhkecKyKzEpIG1vZCBwLiBFZDQ0ODogeMKyID0gKHnCsi0xKS8oZHnCsi0xKSBtb2QgcC4gR2VuZXJpYyBjYXNlOlxuICAgICAgICAgICAgLy8gYXjCsit5wrI9MStkeMKyecKyID0+IHnCsi0xPWR4wrJ5wrItYXjCsiA9PiB5wrItMT14wrIoZHnCsi1hKSA9PiB4wrI9KHnCsi0xKS8oZHnCsi1hKVxuICAgICAgICAgICAgY29uc3QgeTIgPSBtb2RQKHkgKiB5KTsgLy8gZGVub21pbmF0b3IgaXMgYWx3YXlzIG5vbi0wIG1vZCBwLlxuICAgICAgICAgICAgY29uc3QgdSA9IG1vZFAoeTIgLSBfMW4pOyAvLyB1ID0gecKyIC0gMVxuICAgICAgICAgICAgY29uc3QgdiA9IG1vZFAoZCAqIHkyIC0gYSk7IC8vIHYgPSBkIHnCsiArIDEuXG4gICAgICAgICAgICBsZXQgeyBpc1ZhbGlkLCB2YWx1ZTogeCB9ID0gdXZSYXRpbyh1LCB2KTsgLy8g4oiaKHUvdilcbiAgICAgICAgICAgIGlmICghaXNWYWxpZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50LmZyb21IZXg6IGludmFsaWQgeSBjb29yZGluYXRlJyk7XG4gICAgICAgICAgICBjb25zdCBpc1hPZGQgPSAoeCAmIF8xbikgPT09IF8xbjsgLy8gVGhlcmUgYXJlIDIgc3F1YXJlIHJvb3RzLiBVc2UgeF8wIGJpdCB0byBzZWxlY3QgcHJvcGVyXG4gICAgICAgICAgICBjb25zdCBpc0xhc3RCeXRlT2RkID0gKGxhc3RCeXRlICYgMHg4MCkgIT09IDA7IC8vIHhfMCwgbGFzdCBiaXRcbiAgICAgICAgICAgIGlmICghemlwMjE1ICYmIHggPT09IF8wbiAmJiBpc0xhc3RCeXRlT2RkKVxuICAgICAgICAgICAgICAgIC8vIGlmIHg9MCBhbmQgeF8wID0gMSwgZmFpbFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQuZnJvbUhleDogeD0wIGFuZCB4XzA9MScpO1xuICAgICAgICAgICAgaWYgKGlzTGFzdEJ5dGVPZGQgIT09IGlzWE9kZClcbiAgICAgICAgICAgICAgICB4ID0gbW9kUCgteCk7IC8vIGlmIHhfMCAhPSB4IG1vZCAyLCBzZXQgeCA9IHAteFxuICAgICAgICAgICAgcmV0dXJuIFBvaW50LmZyb21BZmZpbmUoeyB4LCB5IH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2S2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkocHJpdktleSkucG9pbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdG9SYXdCeXRlcygpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB1dC5udW1iZXJUb0J5dGVzTEUoeSwgRnAuQllURVMpOyAvLyBlYWNoIHkgaGFzIDIgeCB2YWx1ZXMgKHgsIC15KVxuICAgICAgICAgICAgYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gfD0geCAmIF8xbiA/IDB4ODAgOiAwOyAvLyB3aGVuIGNvbXByZXNzaW5nLCBpdCdzIGVub3VnaCB0byBzdG9yZSB5XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXM7IC8vIGFuZCB1c2UgdGhlIGxhc3QgYnl0ZSB0byBlbmNvZGUgc2lnbiBvZiB4XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoKSk7IC8vIFNhbWUgYXMgdG9SYXdCeXRlcywgYnV0IHJldHVybnMgc3RyaW5nLlxuICAgICAgICB9XG4gICAgfVxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBfMW4sIG1vZFAoQ1VSVkUuR3ggKiBDVVJWRS5HeSkpO1xuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoXzBuLCBfMW4sIF8xbiwgXzBuKTsgLy8gMCwgMSwgMSwgMFxuICAgIGNvbnN0IHsgQkFTRTogRywgWkVSTzogSSB9ID0gUG9pbnQ7XG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQsIG5CeXRlTGVuZ3RoICogOCk7XG4gICAgZnVuY3Rpb24gbW9kTihhKSB7XG4gICAgICAgIHJldHVybiBtb2QoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICAvLyBMaXR0bGUtZW5kaWFuIFNIQTUxMiB3aXRoIG1vZHVsbyBuXG4gICAgZnVuY3Rpb24gbW9kTl9MRShoYXNoKSB7XG4gICAgICAgIHJldHVybiBtb2ROKHV0LmJ5dGVzVG9OdW1iZXJMRShoYXNoKSk7XG4gICAgfVxuICAgIC8qKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBjcmVhdGVzIHB1YmxpYyBrZXkgYW5kIG90aGVyIHN0dWZmLiBSRkM4MDMyIDUuMS41ICovXG4gICAgZnVuY3Rpb24gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkoa2V5KSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IG5CeXRlTGVuZ3RoO1xuICAgICAgICBrZXkgPSBlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXksIGxlbik7XG4gICAgICAgIC8vIEhhc2ggcHJpdmF0ZSBrZXkgd2l0aCBjdXJ2ZSdzIGhhc2ggZnVuY3Rpb24gdG8gcHJvZHVjZSB1bmlmb3JtaW5nbHkgcmFuZG9tIGlucHV0XG4gICAgICAgIC8vIENoZWNrIGJ5dGUgbGVuZ3RoczogZW5zdXJlKDY0LCBoKGVuc3VyZSgzMiwga2V5KSkpXG4gICAgICAgIGNvbnN0IGhhc2hlZCA9IGVuc3VyZUJ5dGVzKCdoYXNoZWQgcHJpdmF0ZSBrZXknLCBjSGFzaChrZXkpLCAyICogbGVuKTtcbiAgICAgICAgY29uc3QgaGVhZCA9IGFkanVzdFNjYWxhckJ5dGVzKGhhc2hlZC5zbGljZSgwLCBsZW4pKTsgLy8gY2xlYXIgZmlyc3QgaGFsZiBiaXRzLCBwcm9kdWNlIEZFXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGhhc2hlZC5zbGljZShsZW4sIDIgKiBsZW4pOyAvLyBzZWNvbmQgaGFsZiBpcyBjYWxsZWQga2V5IHByZWZpeCAoNS4xLjYpXG4gICAgICAgIGNvbnN0IHNjYWxhciA9IG1vZE5fTEUoaGVhZCk7IC8vIFRoZSBhY3R1YWwgcHJpdmF0ZSBzY2FsYXJcbiAgICAgICAgY29uc3QgcG9pbnQgPSBHLm11bHRpcGx5KHNjYWxhcik7IC8vIFBvaW50IG9uIEVkd2FyZHMgY3VydmUgYWthIHB1YmxpYyBrZXlcbiAgICAgICAgY29uc3QgcG9pbnRCeXRlcyA9IHBvaW50LnRvUmF3Qnl0ZXMoKTsgLy8gVWludDhBcnJheSByZXByZXNlbnRhdGlvblxuICAgICAgICByZXR1cm4geyBoZWFkLCBwcmVmaXgsIHNjYWxhciwgcG9pbnQsIHBvaW50Qnl0ZXMgfTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlcyBFZERTQSBwdWIga2V5LiBSRkM4MDMyIDUuMS41LiBQcml2a2V5IGlzIGhhc2hlZC4gVXNlIGZpcnN0IGhhbGYgd2l0aCAzIGJpdHMgY2xlYXJlZFxuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2S2V5KSB7XG4gICAgICAgIHJldHVybiBnZXRFeHRlbmRlZFB1YmxpY0tleShwcml2S2V5KS5wb2ludEJ5dGVzO1xuICAgIH1cbiAgICAvLyBpbnQoJ0xFJywgU0hBNTEyKGRvbTIoRiwgQykgfHwgbXNncykpIG1vZCBOXG4gICAgZnVuY3Rpb24gaGFzaERvbWFpblRvU2NhbGFyKGNvbnRleHQgPSBuZXcgVWludDhBcnJheSgpLCAuLi5tc2dzKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IHV0LmNvbmNhdEJ5dGVzKC4uLm1zZ3MpO1xuICAgICAgICByZXR1cm4gbW9kTl9MRShjSGFzaChkb21haW4obXNnLCBlbnN1cmVCeXRlcygnY29udGV4dCcsIGNvbnRleHQpLCAhIXByZWhhc2gpKSk7XG4gICAgfVxuICAgIC8qKiBTaWducyBtZXNzYWdlIHdpdGggcHJpdmF0ZUtleS4gUkZDODAzMiA1LjEuNiAqL1xuICAgIGZ1bmN0aW9uIHNpZ24obXNnLCBwcml2S2V5LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbXNnID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZyA9IHByZWhhc2gobXNnKTsgLy8gZm9yIGVkMjU1MTlwaCBldGMuXG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBzY2FsYXIsIHBvaW50Qnl0ZXMgfSA9IGdldEV4dGVuZGVkUHVibGljS2V5KHByaXZLZXkpO1xuICAgICAgICBjb25zdCByID0gaGFzaERvbWFpblRvU2NhbGFyKG9wdGlvbnMuY29udGV4dCwgcHJlZml4LCBtc2cpOyAvLyByID0gZG9tMihGLCBDKSB8fCBwcmVmaXggfHwgUEgoTSlcbiAgICAgICAgY29uc3QgUiA9IEcubXVsdGlwbHkocikudG9SYXdCeXRlcygpOyAvLyBSID0gckdcbiAgICAgICAgY29uc3QgayA9IGhhc2hEb21haW5Ub1NjYWxhcihvcHRpb25zLmNvbnRleHQsIFIsIHBvaW50Qnl0ZXMsIG1zZyk7IC8vIFIgfHwgQSB8fCBQSChNKVxuICAgICAgICBjb25zdCBzID0gbW9kTihyICsgayAqIHNjYWxhcik7IC8vIFMgPSAociArIGsgKiBzKSBtb2QgTFxuICAgICAgICBhc3NlcnRHRTAocyk7IC8vIDAgPD0gcyA8IGxcbiAgICAgICAgY29uc3QgcmVzID0gdXQuY29uY2F0Qnl0ZXMoUiwgdXQubnVtYmVyVG9CeXRlc0xFKHMsIEZwLkJZVEVTKSk7XG4gICAgICAgIHJldHVybiBlbnN1cmVCeXRlcygncmVzdWx0JywgcmVzLCBuQnl0ZUxlbmd0aCAqIDIpOyAvLyA2NC1ieXRlIHNpZ25hdHVyZVxuICAgIH1cbiAgICBjb25zdCB2ZXJpZnlPcHRzID0gVkVSSUZZX0RFRkFVTFQ7XG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZywgbXNnLCBwdWJsaWNLZXksIG9wdGlvbnMgPSB2ZXJpZnlPcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGV4dCwgemlwMjE1IH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBsZW4gPSBGcC5CWVRFUzsgLy8gVmVyaWZpZXMgRWREU0Egc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBhbmQgcHVibGljIGtleS4gUkZDODAzMiA1LjEuNy5cbiAgICAgICAgc2lnID0gZW5zdXJlQnl0ZXMoJ3NpZ25hdHVyZScsIHNpZywgMiAqIGxlbik7IC8vIEFuIGV4dGVuZGVkIGdyb3VwIGVxdWF0aW9uIGlzIGNoZWNrZWQuXG4gICAgICAgIG1zZyA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbXNnKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2cgPSBwcmVoYXNoKG1zZyk7IC8vIGZvciBlZDI1NTE5cGgsIGV0Y1xuICAgICAgICBjb25zdCBzID0gdXQuYnl0ZXNUb051bWJlckxFKHNpZy5zbGljZShsZW4sIDIgKiBsZW4pKTtcbiAgICAgICAgLy8gemlwMjE1OiB0cnVlIGlzIGdvb2QgZm9yIGNvbnNlbnN1cy1jcml0aWNhbCBhcHBzIGFuZCBhbGxvd3MgcG9pbnRzIDwgMl4yNTZcbiAgICAgICAgLy8gemlwMjE1OiBmYWxzZSBmb2xsb3dzIFJGQzgwMzIgLyBOSVNUMTg2LTUgYW5kIHJlc3RyaWN0cyBwb2ludHMgdG8gQ1VSVkUucFxuICAgICAgICBsZXQgQSwgUiwgU0I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBBID0gUG9pbnQuZnJvbUhleChwdWJsaWNLZXksIHppcDIxNSk7XG4gICAgICAgICAgICBSID0gUG9pbnQuZnJvbUhleChzaWcuc2xpY2UoMCwgbGVuKSwgemlwMjE1KTtcbiAgICAgICAgICAgIFNCID0gRy5tdWx0aXBseVVuc2FmZShzKTsgLy8gMCA8PSBzIDwgbCBpcyBkb25lIGluc2lkZVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghemlwMjE1ICYmIEEuaXNTbWFsbE9yZGVyKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGsgPSBoYXNoRG9tYWluVG9TY2FsYXIoY29udGV4dCwgUi50b1Jhd0J5dGVzKCksIEEudG9SYXdCeXRlcygpLCBtc2cpO1xuICAgICAgICBjb25zdCBSa0EgPSBSLmFkZChBLm11bHRpcGx5VW5zYWZlKGspKTtcbiAgICAgICAgLy8gWzhdW1NdQiA9IFs4XVIgKyBbOF1ba11BJ1xuICAgICAgICByZXR1cm4gUmtBLnN1YnRyYWN0KFNCKS5jbGVhckNvZmFjdG9yKCkuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgIH1cbiAgICBHLl9zZXRXaW5kb3dTaXplKDgpOyAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIGdldEV4dGVuZGVkUHVibGljS2V5LFxuICAgICAgICAvLyBlZDI1NTE5IHByaXZhdGUga2V5cyBhcmUgdW5pZm9ybSAzMmIuIE5vIG5lZWQgdG8gY2hlY2sgZm9yIG1vZHVsbyBiaWFzLCBsaWtlIGluIHNlY3AyNTZrMS5cbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4gcmFuZG9tQnl0ZXMoRnAuQllURVMpLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2UncmUgZG9pbmcgc2NhbGFyIG11bHRpcGxpY2F0aW9uICh1c2VkIGluIGdldFB1YmxpY0tleSBldGMpIHdpdGggcHJlY29tcHV0ZWQgQkFTRV9QT0lOVFxuICAgICAgICAgKiB2YWx1ZXMuIFRoaXMgc2xvd3MgZG93biBmaXJzdCBnZXRQdWJsaWNLZXkoKSBieSBtaWxsaXNlY29uZHMgKHNlZSBTcGVlZCBzZWN0aW9uKSxcbiAgICAgICAgICogYnV0IGFsbG93cyB0byBzcGVlZC11cCBzdWJzZXF1ZW50IGdldFB1YmxpY0tleSgpIGNhbGxzIHVwIHRvIDIweC5cbiAgICAgICAgICogQHBhcmFtIHdpbmRvd1NpemUgMiwgNCwgOCwgMTZcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xuICAgICAgICAgICAgcG9pbnQuX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSk7XG4gICAgICAgICAgICBwb2ludC5tdWx0aXBseShCaWdJbnQoMykpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgc2lnbixcbiAgICAgICAgdmVyaWZ5LFxuICAgICAgICBFeHRlbmRlZFBvaW50OiBQb2ludCxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVkd2FyZHMuanMubWFwIl0sIm5hbWVzIjpbInZhbGlkYXRlQmFzaWMiLCJ3TkFGIiwibW9kIiwidXQiLCJlbnN1cmVCeXRlcyIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl84biIsIlZFUklGWV9ERUZBVUxUIiwiemlwMjE1IiwidmFsaWRhdGVPcHRzIiwiY3VydmUiLCJvcHRzIiwidmFsaWRhdGVPYmplY3QiLCJoYXNoIiwiYSIsImQiLCJyYW5kb21CeXRlcyIsImFkanVzdFNjYWxhckJ5dGVzIiwiZG9tYWluIiwidXZSYXRpbyIsIm1hcFRvQ3VydmUiLCJPYmplY3QiLCJmcmVlemUiLCJ0d2lzdGVkRWR3YXJkcyIsImN1cnZlRGVmIiwiQ1VSVkUiLCJGcCIsIm4iLCJDVVJWRV9PUkRFUiIsInByZWhhc2giLCJjSGFzaCIsIm5CeXRlTGVuZ3RoIiwiaCIsImNvZmFjdG9yIiwiTUFTSyIsIm1vZFAiLCJjcmVhdGUiLCJ1IiwidiIsImlzVmFsaWQiLCJ2YWx1ZSIsInNxcnQiLCJpbnYiLCJlIiwiYnl0ZXMiLCJkYXRhIiwiY3R4IiwicGhmbGFnIiwibGVuZ3RoIiwiRXJyb3IiLCJpbkJpZyIsImluUmFuZ2UiLCJtYXgiLCJpbjBNYXNrUmFuZ2UiLCJhc3NlcnRJblJhbmdlIiwiYXNzZXJ0R0UwIiwicG9pbnRQcmVjb21wdXRlcyIsIk1hcCIsImlzUG9pbnQiLCJvdGhlciIsIlBvaW50IiwiY29uc3RydWN0b3IiLCJleCIsImV5IiwiZXoiLCJldCIsIngiLCJ0b0FmZmluZSIsInkiLCJmcm9tQWZmaW5lIiwicCIsIm5vcm1hbGl6ZVoiLCJwb2ludHMiLCJ0b0ludiIsImludmVydEJhdGNoIiwibWFwIiwiaSIsIl9zZXRXaW5kb3dTaXplIiwid2luZG93U2l6ZSIsIl9XSU5ET1dfU0laRSIsImRlbGV0ZSIsImFzc2VydFZhbGlkaXR5IiwiaXMwIiwiWCIsIlkiLCJaIiwiVCIsIlgyIiwiWTIiLCJaMiIsIlo0IiwiYVgyIiwibGVmdCIsInJpZ2h0IiwiWFkiLCJaVCIsImVxdWFscyIsIlgxIiwiWTEiLCJaMSIsIlgxWjIiLCJYMloxIiwiWTFaMiIsIlkyWjEiLCJaRVJPIiwibmVnYXRlIiwiZG91YmxlIiwiQSIsIkIiLCJDIiwiRCIsIngxeTEiLCJFIiwiRyIsIkYiLCJIIiwiWDMiLCJZMyIsIlQzIiwiWjMiLCJhZGQiLCJUMSIsIlQyIiwic3VidHJhY3QiLCJ3bmFmIiwid05BRkNhY2hlZCIsIm11bHRpcGx5Iiwic2NhbGFyIiwiZiIsIm11bHRpcGx5VW5zYWZlIiwiSSIsInVuc2FmZUxhZGRlciIsImlzU21hbGxPcmRlciIsImlzVG9yc2lvbkZyZWUiLCJpeiIsInoiLCJheCIsImF5IiwienoiLCJjbGVhckNvZmFjdG9yIiwiZnJvbUhleCIsImhleCIsImxlbiIsIkJZVEVTIiwibm9ybWVkIiwic2xpY2UiLCJsYXN0Qnl0ZSIsImJ5dGVzVG9OdW1iZXJMRSIsIk9SREVSIiwieTIiLCJpc1hPZGQiLCJpc0xhc3RCeXRlT2RkIiwiZnJvbVByaXZhdGVLZXkiLCJwcml2S2V5IiwiZ2V0RXh0ZW5kZWRQdWJsaWNLZXkiLCJwb2ludCIsInRvUmF3Qnl0ZXMiLCJudW1iZXJUb0J5dGVzTEUiLCJ0b0hleCIsImJ5dGVzVG9IZXgiLCJCQVNFIiwiR3giLCJHeSIsIm1vZE4iLCJtb2ROX0xFIiwia2V5IiwiaGFzaGVkIiwiaGVhZCIsInByZWZpeCIsInBvaW50Qnl0ZXMiLCJnZXRQdWJsaWNLZXkiLCJoYXNoRG9tYWluVG9TY2FsYXIiLCJjb250ZXh0IiwiVWludDhBcnJheSIsIm1zZ3MiLCJtc2ciLCJjb25jYXRCeXRlcyIsInNpZ24iLCJvcHRpb25zIiwiciIsIlIiLCJrIiwicyIsInJlcyIsInZlcmlmeU9wdHMiLCJ2ZXJpZnkiLCJzaWciLCJwdWJsaWNLZXkiLCJTQiIsImVycm9yIiwiUmtBIiwidXRpbHMiLCJyYW5kb21Qcml2YXRlS2V5IiwicHJlY29tcHV0ZSIsIkV4dGVuZGVkUG9pbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/@noble/curves/esm/abstract/edwards.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << 8 * length) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({\n        length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++){\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error(\"number expected\");\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255) DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255) throw new Error(\"Invalid xmd length\");\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            strxor(b_0, b[i - 1]),\n            i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen\n        }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: \"stringOrUint8Array\",\n        p: \"bigint\",\n        m: \"isSafeInteger\",\n        k: \"isSafeInteger\",\n        hash: \"hash\"\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === \"string\" ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === \"xmd\") {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    } else if (expand === \"xof\") {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    } else if (expand === \"_internal_pass\") {\n        // for internal tests only\n        prb = msg;\n    } else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return {\n            x,\n            y\n        };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== \"function\") throw new Error(\"mapToCurve() must be defined\");\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve (msg, options) {\n            const u = hash_to_field(msg, 2, {\n                ...def,\n                DST: def.DST,\n                ...options\n            });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve (msg, options) {\n            const u = hash_to_field(msg, 1, {\n                ...def,\n                DST: def.encodeDST,\n                ...options\n            });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve (scalars) {\n            if (!Array.isArray(scalars)) throw new Error(\"mapToCurve: expected array of bigints\");\n            for (const i of scalars)if (typeof i !== \"bigint\") throw new Error(`mapToCurve: expected array of bigints, got ${i} in array`);\n            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();\n            P.assertValidity();\n            return P;\n        }\n    };\n} //# sourceMappingURL=hash-to-curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFtQztBQUM0RDtBQUMvRiw2RkFBNkY7QUFDN0YsTUFBTU0sUUFBUUosc0RBQWVBO0FBQzdCLDRDQUE0QztBQUM1QyxTQUFTSyxNQUFNQyxLQUFLLEVBQUVDLE1BQU07SUFDeEIsSUFBSUQsUUFBUSxLQUFLQSxTQUFTLEtBQU0sSUFBSUMsUUFBUztRQUN6QyxNQUFNLElBQUlDLE1BQU0sQ0FBQyxzQkFBc0IsRUFBRUYsTUFBTSxRQUFRLEVBQUVDLE9BQU8sQ0FBQztJQUNyRTtJQUNBLE1BQU1FLE1BQU1DLE1BQU1DLElBQUksQ0FBQztRQUFFSjtJQUFPLEdBQUdLLElBQUksQ0FBQztJQUN4QyxJQUFLLElBQUlDLElBQUlOLFNBQVMsR0FBR00sS0FBSyxHQUFHQSxJQUFLO1FBQ2xDSixHQUFHLENBQUNJLEVBQUUsR0FBR1AsUUFBUTtRQUNqQkEsV0FBVztJQUNmO0lBQ0EsT0FBTyxJQUFJUSxXQUFXTDtBQUMxQjtBQUNBLFNBQVNNLE9BQU9DLENBQUMsRUFBRUMsQ0FBQztJQUNoQixNQUFNQyxNQUFNLElBQUlKLFdBQVdFLEVBQUVULE1BQU07SUFDbkMsSUFBSyxJQUFJTSxJQUFJLEdBQUdBLElBQUlHLEVBQUVULE1BQU0sRUFBRU0sSUFBSztRQUMvQkssR0FBRyxDQUFDTCxFQUFFLEdBQUdHLENBQUMsQ0FBQ0gsRUFBRSxHQUFHSSxDQUFDLENBQUNKLEVBQUU7SUFDeEI7SUFDQSxPQUFPSztBQUNYO0FBQ0EsU0FBU0MsS0FBS0MsSUFBSTtJQUNkLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDRixPQUN0QixNQUFNLElBQUlaLE1BQU07QUFDeEI7QUFDQSxvR0FBb0c7QUFDcEcsdURBQXVEO0FBQ2hELFNBQVNlLG1CQUFtQkMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQztJQUN0RDVCLGlEQUFNQSxDQUFDeUI7SUFDUHpCLGlEQUFNQSxDQUFDMEI7SUFDUE4sS0FBS087SUFDTCx1REFBdUQ7SUFDdkQsSUFBSUQsSUFBSWxCLE1BQU0sR0FBRyxLQUNia0IsTUFBTUUsRUFBRTFCLHNEQUFXQSxDQUFDQyxzREFBV0EsQ0FBQyxzQkFBc0J1QjtJQUMxRCxNQUFNLEVBQUVHLFdBQVdDLFVBQVUsRUFBRUMsVUFBVUMsVUFBVSxFQUFFLEdBQUdKO0lBQ3hELE1BQU1LLE1BQU1DLEtBQUtDLElBQUksQ0FBQ1IsYUFBYUc7SUFDbkMsSUFBSUcsTUFBTSxLQUNOLE1BQU0sSUFBSXhCLE1BQU07SUFDcEIsTUFBTTJCLFlBQVlsQyxzREFBV0EsQ0FBQ3dCLEtBQUtwQixNQUFNb0IsSUFBSWxCLE1BQU0sRUFBRTtJQUNyRCxNQUFNNkIsUUFBUS9CLE1BQU0sR0FBRzBCO0lBQ3ZCLE1BQU1NLFlBQVloQyxNQUFNcUIsWUFBWSxJQUFJLG1CQUFtQjtJQUMzRCxNQUFNVCxJQUFJLElBQUlQLE1BQU1zQjtJQUNwQixNQUFNTSxNQUFNWCxFQUFFMUIsc0RBQVdBLENBQUNtQyxPQUFPWixLQUFLYSxXQUFXaEMsTUFBTSxHQUFHLElBQUk4QjtJQUM5RGxCLENBQUMsQ0FBQyxFQUFFLEdBQUdVLEVBQUUxQixzREFBV0EsQ0FBQ3FDLEtBQUtqQyxNQUFNLEdBQUcsSUFBSThCO0lBQ3ZDLElBQUssSUFBSXRCLElBQUksR0FBR0EsS0FBS21CLEtBQUtuQixJQUFLO1FBQzNCLE1BQU0wQixPQUFPO1lBQUN4QixPQUFPdUIsS0FBS3JCLENBQUMsQ0FBQ0osSUFBSSxFQUFFO1lBQUdSLE1BQU1RLElBQUksR0FBRztZQUFJc0I7U0FBVTtRQUNoRWxCLENBQUMsQ0FBQ0osRUFBRSxHQUFHYyxFQUFFMUIsc0RBQVdBLElBQUlzQztJQUM1QjtJQUNBLE1BQU1DLHNCQUFzQnZDLHNEQUFXQSxJQUFJZ0I7SUFDM0MsT0FBT3VCLG9CQUFvQkMsS0FBSyxDQUFDLEdBQUdmO0FBQ3hDO0FBQ0EsdUZBQXVGO0FBQ3ZGLDREQUE0RDtBQUM1RCxpRUFBaUU7QUFDakUsa0VBQWtFO0FBQ2xFLHVEQUF1RDtBQUNoRCxTQUFTZ0IsbUJBQW1CbEIsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLFVBQVUsRUFBRWlCLENBQUMsRUFBRWhCLENBQUM7SUFDekQ1QixpREFBTUEsQ0FBQ3lCO0lBQ1B6QixpREFBTUEsQ0FBQzBCO0lBQ1BOLEtBQUtPO0lBQ0wsdURBQXVEO0lBQ3ZELG9GQUFvRjtJQUNwRixJQUFJRCxJQUFJbEIsTUFBTSxHQUFHLEtBQUs7UUFDbEIsTUFBTXFDLFFBQVFYLEtBQUtDLElBQUksQ0FBQyxJQUFLUyxJQUFLO1FBQ2xDbEIsTUFBTUUsRUFBRWtCLE1BQU0sQ0FBQztZQUFFRDtRQUFNLEdBQUdFLE1BQU0sQ0FBQzVDLHNEQUFXQSxDQUFDLHNCQUFzQjRDLE1BQU0sQ0FBQ3JCLEtBQUtzQixNQUFNO0lBQ3pGO0lBQ0EsSUFBSXJCLGFBQWEsU0FBU0QsSUFBSWxCLE1BQU0sR0FBRyxLQUNuQyxNQUFNLElBQUlDLE1BQU07SUFDcEIsT0FBUW1CLEVBQUVrQixNQUFNLENBQUM7UUFBRUQsT0FBT2xCO0lBQVcsR0FDaENvQixNQUFNLENBQUN0QixLQUNQc0IsTUFBTSxDQUFDekMsTUFBTXFCLFlBQVksR0FDMUIsMkNBQTJDO0tBQzFDb0IsTUFBTSxDQUFDckIsS0FDUHFCLE1BQU0sQ0FBQ3pDLE1BQU1vQixJQUFJbEIsTUFBTSxFQUFFLElBQ3pCd0MsTUFBTTtBQUNmO0FBQ0E7Ozs7Ozs7Q0FPQyxHQUNNLFNBQVNDLGNBQWN4QixHQUFHLEVBQUV5QixLQUFLLEVBQUVDLE9BQU87SUFDN0MvQyx5REFBY0EsQ0FBQytDLFNBQVM7UUFDcEJ6QixLQUFLO1FBQ0wwQixHQUFHO1FBQ0hDLEdBQUc7UUFDSFQsR0FBRztRQUNIVSxNQUFNO0lBQ1Y7SUFDQSxNQUFNLEVBQUVGLENBQUMsRUFBRVIsQ0FBQyxFQUFFUyxDQUFDLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFN0IsS0FBSzhCLElBQUksRUFBRSxHQUFHTDtJQUM3Q25ELGlEQUFNQSxDQUFDeUI7SUFDUEwsS0FBSzhCO0lBQ0wsTUFBTXhCLE1BQU0sT0FBTzhCLFNBQVMsV0FBV3JELHNEQUFXQSxDQUFDcUQsUUFBUUE7SUFDM0QsTUFBTUMsUUFBUUwsRUFBRU0sUUFBUSxDQUFDLEdBQUdsRCxNQUFNO0lBQ2xDLE1BQU1tRCxJQUFJekIsS0FBS0MsSUFBSSxDQUFDLENBQUNzQixRQUFRYixDQUFBQSxJQUFLLElBQUksdUNBQXVDO0lBQzdFLE1BQU1nQixlQUFlVixRQUFRRyxJQUFJTTtJQUNqQyxJQUFJRSxLQUFLLHNCQUFzQjtJQUMvQixJQUFJTixXQUFXLE9BQU87UUFDbEJNLE1BQU1yQyxtQkFBbUJDLEtBQUtDLEtBQUtrQyxjQUFjTjtJQUNyRCxPQUNLLElBQUlDLFdBQVcsT0FBTztRQUN2Qk0sTUFBTWxCLG1CQUFtQmxCLEtBQUtDLEtBQUtrQyxjQUFjaEIsR0FBR1U7SUFDeEQsT0FDSyxJQUFJQyxXQUFXLGtCQUFrQjtRQUNsQywwQkFBMEI7UUFDMUJNLE1BQU1wQztJQUNWLE9BQ0s7UUFDRCxNQUFNLElBQUloQixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXFELElBQUksSUFBSW5ELE1BQU11QztJQUNwQixJQUFLLElBQUlwQyxJQUFJLEdBQUdBLElBQUlvQyxPQUFPcEMsSUFBSztRQUM1QixNQUFNaUQsSUFBSSxJQUFJcEQsTUFBTTBDO1FBQ3BCLElBQUssSUFBSVcsSUFBSSxHQUFHQSxJQUFJWCxHQUFHVyxJQUFLO1lBQ3hCLE1BQU1DLGFBQWFOLElBQUtLLENBQUFBLElBQUlsRCxJQUFJdUMsQ0FBQUE7WUFDaEMsTUFBTWEsS0FBS0wsSUFBSU0sUUFBUSxDQUFDRixZQUFZQSxhQUFhTjtZQUNqREksQ0FBQyxDQUFDQyxFQUFFLEdBQUdqRSxnREFBR0EsQ0FBQ00sTUFBTTZELEtBQUtkO1FBQzFCO1FBQ0FVLENBQUMsQ0FBQ2hELEVBQUUsR0FBR2lEO0lBQ1g7SUFDQSxPQUFPRDtBQUNYO0FBQ08sU0FBU00sV0FBV0MsS0FBSyxFQUFFQyxHQUFHO0lBQ2pDLDZCQUE2QjtJQUM3QixNQUFNQyxRQUFRRCxJQUFJQSxHQUFHLENBQUMsQ0FBQ3hELElBQU1ILE1BQU1DLElBQUksQ0FBQ0UsR0FBRzBELE9BQU87SUFDbEQsT0FBTyxDQUFDQyxHQUFHQztRQUNQLE1BQU0sQ0FBQ0MsTUFBTUMsTUFBTUMsTUFBTUMsS0FBSyxHQUFHUCxNQUFNRCxHQUFHLENBQUMsQ0FBQ1MsTUFBUUEsSUFBSUMsTUFBTSxDQUFDLENBQUNDLEtBQUtuRSxJQUFNdUQsTUFBTWEsR0FBRyxDQUFDYixNQUFNYyxHQUFHLENBQUNGLEtBQUtSLElBQUkzRDtRQUN4RzJELElBQUlKLE1BQU1lLEdBQUcsQ0FBQ1QsTUFBTUMsT0FBTyxjQUFjO1FBQ3pDRixJQUFJTCxNQUFNYyxHQUFHLENBQUNULEdBQUdMLE1BQU1lLEdBQUcsQ0FBQ1AsTUFBTUMsUUFBUSxvQkFBb0I7UUFDN0QsT0FBTztZQUFFTDtZQUFHQztRQUFFO0lBQ2xCO0FBQ0o7QUFDTyxTQUFTVyxhQUFhQyxLQUFLLEVBQUVDLFVBQVUsRUFBRUMsR0FBRztJQUMvQyxJQUFJLE9BQU9ELGVBQWUsWUFDdEIsTUFBTSxJQUFJOUUsTUFBTTtJQUNwQixPQUFPO1FBQ0gseUNBQXlDO1FBQ3pDLHNFQUFzRTtRQUN0RWdGLGFBQVloRSxHQUFHLEVBQUUwQixPQUFPO1lBQ3BCLE1BQU1XLElBQUliLGNBQWN4QixLQUFLLEdBQUc7Z0JBQUUsR0FBRytELEdBQUc7Z0JBQUU5RCxLQUFLOEQsSUFBSTlELEdBQUc7Z0JBQUUsR0FBR3lCLE9BQU87WUFBQztZQUNuRSxNQUFNdUMsS0FBS0osTUFBTUssVUFBVSxDQUFDSixXQUFXekIsQ0FBQyxDQUFDLEVBQUU7WUFDM0MsTUFBTThCLEtBQUtOLE1BQU1LLFVBQVUsQ0FBQ0osV0FBV3pCLENBQUMsQ0FBQyxFQUFFO1lBQzNDLE1BQU0rQixJQUFJSCxHQUFHUixHQUFHLENBQUNVLElBQUlFLGFBQWE7WUFDbENELEVBQUVFLGNBQWM7WUFDaEIsT0FBT0Y7UUFDWDtRQUNBLHlDQUF5QztRQUN6Qyx3RUFBd0U7UUFDeEVHLGVBQWN2RSxHQUFHLEVBQUUwQixPQUFPO1lBQ3RCLE1BQU1XLElBQUliLGNBQWN4QixLQUFLLEdBQUc7Z0JBQUUsR0FBRytELEdBQUc7Z0JBQUU5RCxLQUFLOEQsSUFBSVMsU0FBUztnQkFBRSxHQUFHOUMsT0FBTztZQUFDO1lBQ3pFLE1BQU0wQyxJQUFJUCxNQUFNSyxVQUFVLENBQUNKLFdBQVd6QixDQUFDLENBQUMsRUFBRSxHQUFHZ0MsYUFBYTtZQUMxREQsRUFBRUUsY0FBYztZQUNoQixPQUFPRjtRQUNYO1FBQ0EsMENBQTBDO1FBQzFDTixZQUFXVyxPQUFPO1lBQ2QsSUFBSSxDQUFDdkYsTUFBTXdGLE9BQU8sQ0FBQ0QsVUFDZixNQUFNLElBQUl6RixNQUFNO1lBQ3BCLEtBQUssTUFBTUssS0FBS29GLFFBQ1osSUFBSSxPQUFPcEYsTUFBTSxVQUNiLE1BQU0sSUFBSUwsTUFBTSxDQUFDLDJDQUEyQyxFQUFFSyxFQUFFLFNBQVMsQ0FBQztZQUNsRixNQUFNK0UsSUFBSVAsTUFBTUssVUFBVSxDQUFDSixXQUFXVyxVQUFVSixhQUFhO1lBQzdERCxFQUFFRSxjQUFjO1lBQ2hCLE9BQU9GO1FBQ1g7SUFDSjtBQUNKLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzP2ExOGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbW9kIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IGFieXRlcywgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgdXRmOFRvQnl0ZXMsIHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBPY3RldCBTdHJlYW0gdG8gSW50ZWdlci4gXCJzcGVjXCIgaW1wbGVtZW50YXRpb24gb2Ygb3MyaXAgaXMgMi41eCBzbG93ZXIgdnMgYnl0ZXNUb051bWJlckJFLlxuY29uc3Qgb3MyaXAgPSBieXRlc1RvTnVtYmVyQkU7XG4vLyBJbnRlZ2VyIHRvIE9jdGV0IFN0cmVhbSAobnVtYmVyVG9CeXRlc0JFKVxuZnVuY3Rpb24gaTJvc3AodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gMSA8PCAoOCAqIGxlbmd0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgSTJPU1AgY2FsbDogdmFsdWU9JHt2YWx1ZX0gbGVuZ3RoPSR7bGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0pLmZpbGwoMCk7XG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHJlc1tpXSA9IHZhbHVlICYgMHhmZjtcbiAgICAgICAgdmFsdWUgPj4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzKTtcbn1cbmZ1bmN0aW9uIHN0cnhvcihhLCBiKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBhW2ldIF4gYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIGFudW0oaXRlbSkge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaXRlbSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtYmVyIGV4cGVjdGVkJyk7XG59XG4vLyBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYSBjcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb24gSCB0aGF0IG91dHB1dHMgYiBiaXRzXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4xXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBIKSB7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYWJ5dGVzKERTVCk7XG4gICAgYW51bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIERTVCA9IEgoY29uY2F0Qnl0ZXModXRmOFRvQnl0ZXMoJ0gyQy1PVkVSU0laRS1EU1QtJyksIERTVCkpO1xuICAgIGNvbnN0IHsgb3V0cHV0TGVuOiBiX2luX2J5dGVzLCBibG9ja0xlbjogcl9pbl9ieXRlcyB9ID0gSDtcbiAgICBjb25zdCBlbGwgPSBNYXRoLmNlaWwobGVuSW5CeXRlcyAvIGJfaW5fYnl0ZXMpO1xuICAgIGlmIChlbGwgPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB4bWQgbGVuZ3RoJyk7XG4gICAgY29uc3QgRFNUX3ByaW1lID0gY29uY2F0Qnl0ZXMoRFNULCBpMm9zcChEU1QubGVuZ3RoLCAxKSk7XG4gICAgY29uc3QgWl9wYWQgPSBpMm9zcCgwLCByX2luX2J5dGVzKTtcbiAgICBjb25zdCBsX2lfYl9zdHIgPSBpMm9zcChsZW5JbkJ5dGVzLCAyKTsgLy8gbGVuX2luX2J5dGVzX3N0clxuICAgIGNvbnN0IGIgPSBuZXcgQXJyYXkoZWxsKTtcbiAgICBjb25zdCBiXzAgPSBIKGNvbmNhdEJ5dGVzKFpfcGFkLCBtc2csIGxfaV9iX3N0ciwgaTJvc3AoMCwgMSksIERTVF9wcmltZSkpO1xuICAgIGJbMF0gPSBIKGNvbmNhdEJ5dGVzKGJfMCwgaTJvc3AoMSwgMSksIERTVF9wcmltZSkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGVsbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbc3RyeG9yKGJfMCwgYltpIC0gMV0pLCBpMm9zcChpICsgMSwgMSksIERTVF9wcmltZV07XG4gICAgICAgIGJbaV0gPSBIKGNvbmNhdEJ5dGVzKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgY29uc3QgcHNldWRvX3JhbmRvbV9ieXRlcyA9IGNvbmNhdEJ5dGVzKC4uLmIpO1xuICAgIHJldHVybiBwc2V1ZG9fcmFuZG9tX2J5dGVzLnNsaWNlKDAsIGxlbkluQnl0ZXMpO1xufVxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGFuIGV4dGVuZGFibGUtb3V0cHV0IGZ1bmN0aW9uIChYT0YpIEguXG4vLyAxLiBUaGUgY29sbGlzaW9uIHJlc2lzdGFuY2Ugb2YgSCBNVVNUIGJlIGF0IGxlYXN0IGsgYml0cy5cbi8vIDIuIEggTVVTVCBiZSBhbiBYT0YgdGhhdCBoYXMgYmVlbiBwcm92ZWQgaW5kaWZmZXJlbnRpYWJsZSBmcm9tXG4vLyAgICBhIHJhbmRvbSBvcmFjbGUgdW5kZXIgYSByZWFzb25hYmxlIGNyeXB0b2dyYXBoaWMgYXNzdW1wdGlvbi5cbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjJcbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbkluQnl0ZXMsIGssIEgpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhYnl0ZXMoRFNUKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICAvLyBEU1QgPSBIKCdIMkMtT1ZFUlNJWkUtRFNULScgfHwgYV92ZXJ5X2xvbmdfRFNULCBNYXRoLmNlaWwoKGxlbkluQnl0ZXMgKiBrKSAvIDgpKTtcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSkge1xuICAgICAgICBjb25zdCBka0xlbiA9IE1hdGguY2VpbCgoMiAqIGspIC8gOCk7XG4gICAgICAgIERTVCA9IEguY3JlYXRlKHsgZGtMZW4gfSkudXBkYXRlKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpKS51cGRhdGUoRFNUKS5kaWdlc3QoKTtcbiAgICB9XG4gICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZF9tZXNzYWdlX3hvZjogaW52YWxpZCBsZW5JbkJ5dGVzJyk7XG4gICAgcmV0dXJuIChILmNyZWF0ZSh7IGRrTGVuOiBsZW5JbkJ5dGVzIH0pXG4gICAgICAgIC51cGRhdGUobXNnKVxuICAgICAgICAudXBkYXRlKGkyb3NwKGxlbkluQnl0ZXMsIDIpKVxuICAgICAgICAvLyAyLiBEU1RfcHJpbWUgPSBEU1QgfHwgSTJPU1AobGVuKERTVCksIDEpXG4gICAgICAgIC51cGRhdGUoRFNUKVxuICAgICAgICAudXBkYXRlKGkyb3NwKERTVC5sZW5ndGgsIDEpKVxuICAgICAgICAuZGlnZXN0KCkpO1xufVxuLyoqXG4gKiBIYXNoZXMgYXJiaXRyYXJ5LWxlbmd0aCBieXRlIHN0cmluZ3MgdG8gYSBsaXN0IG9mIG9uZSBvciBtb3JlIGVsZW1lbnRzIG9mIGEgZmluaXRlIGZpZWxkIEZcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4yXG4gKiBAcGFyYW0gbXNnIGEgYnl0ZSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWVzc2FnZSB0byBoYXNoXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiBGIHRvIG91dHB1dFxuICogQHBhcmFtIG9wdGlvbnMgYHtEU1Q6IHN0cmluZywgcDogYmlnaW50LCBtOiBudW1iZXIsIGs6IG51bWJlciwgZXhwYW5kOiAneG1kJyB8ICd4b2YnLCBoYXNoOiBIfWAsIHNlZSBhYm92ZVxuICogQHJldHVybnMgW3VfMCwgLi4uLCB1Xyhjb3VudCAtIDEpXSwgYSBsaXN0IG9mIGZpZWxkIGVsZW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaF90b19maWVsZChtc2csIGNvdW50LCBvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywge1xuICAgICAgICBEU1Q6ICdzdHJpbmdPclVpbnQ4QXJyYXknLFxuICAgICAgICBwOiAnYmlnaW50JyxcbiAgICAgICAgbTogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBrOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IHAsIGssIG0sIGhhc2gsIGV4cGFuZCwgRFNUOiBfRFNUIH0gPSBvcHRpb25zO1xuICAgIGFieXRlcyhtc2cpO1xuICAgIGFudW0oY291bnQpO1xuICAgIGNvbnN0IERTVCA9IHR5cGVvZiBfRFNUID09PSAnc3RyaW5nJyA/IHV0ZjhUb0J5dGVzKF9EU1QpIDogX0RTVDtcbiAgICBjb25zdCBsb2cycCA9IHAudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IEwgPSBNYXRoLmNlaWwoKGxvZzJwICsgaykgLyA4KTsgLy8gc2VjdGlvbiA1LjEgb2YgaWV0ZiBkcmFmdCBsaW5rIGFib3ZlXG4gICAgY29uc3QgbGVuX2luX2J5dGVzID0gY291bnQgKiBtICogTDtcbiAgICBsZXQgcHJiOyAvLyBwc2V1ZG9fcmFuZG9tX2J5dGVzXG4gICAgaWYgKGV4cGFuZCA9PT0gJ3htZCcpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICd4b2YnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuX2luX2J5dGVzLCBrLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAnX2ludGVybmFsX3Bhc3MnKSB7XG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCB0ZXN0cyBvbmx5XG4gICAgICAgIHByYiA9IG1zZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kIG11c3QgYmUgXCJ4bWRcIiBvciBcInhvZlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IHUgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBlID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgY29uc3QgZWxtX29mZnNldCA9IEwgKiAoaiArIGkgKiBtKTtcbiAgICAgICAgICAgIGNvbnN0IHR2ID0gcHJiLnN1YmFycmF5KGVsbV9vZmZzZXQsIGVsbV9vZmZzZXQgKyBMKTtcbiAgICAgICAgICAgIGVbal0gPSBtb2Qob3MyaXAodHYpLCBwKTtcbiAgICAgICAgfVxuICAgICAgICB1W2ldID0gZTtcbiAgICB9XG4gICAgcmV0dXJuIHU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNvZ2VueU1hcChmaWVsZCwgbWFwKSB7XG4gICAgLy8gTWFrZSBzYW1lIG9yZGVyIGFzIGluIHNwZWNcbiAgICBjb25zdCBDT0VGRiA9IG1hcC5tYXAoKGkpID0+IEFycmF5LmZyb20oaSkucmV2ZXJzZSgpKTtcbiAgICByZXR1cm4gKHgsIHkpID0+IHtcbiAgICAgICAgY29uc3QgW3hOdW0sIHhEZW4sIHlOdW0sIHlEZW5dID0gQ09FRkYubWFwKCh2YWwpID0+IHZhbC5yZWR1Y2UoKGFjYywgaSkgPT4gZmllbGQuYWRkKGZpZWxkLm11bChhY2MsIHgpLCBpKSkpO1xuICAgICAgICB4ID0gZmllbGQuZGl2KHhOdW0sIHhEZW4pOyAvLyB4TnVtIC8geERlblxuICAgICAgICB5ID0gZmllbGQubXVsKHksIGZpZWxkLmRpdih5TnVtLCB5RGVuKSk7IC8vIHkgKiAoeU51bSAvIHlEZXYpXG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihQb2ludCwgbWFwVG9DdXJ2ZSwgZGVmKSB7XG4gICAgaWYgKHR5cGVvZiBtYXBUb0N1cnZlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmUoKSBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBoYXNoX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCB7IC4uLmRlZiwgRFNUOiBkZWYuRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgdTAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpO1xuICAgICAgICAgICAgY29uc3QgdTEgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVsxXSkpO1xuICAgICAgICAgICAgY29uc3QgUCA9IHUwLmFkZCh1MSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGVuY29kZV90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAxLCB7IC4uLmRlZiwgRFNUOiBkZWYuZW5jb2RlRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNhbWUgYXMgZW5jb2RlVG9DdXJ2ZSwgYnV0IHdpdGhvdXQgaGFzaFxuICAgICAgICBtYXBUb0N1cnZlKHNjYWxhcnMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmU6IGV4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMnKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBzY2FsYXJzKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWFwVG9DdXJ2ZTogZXhwZWN0ZWQgYXJyYXkgb2YgYmlnaW50cywgZ290ICR7aX0gaW4gYXJyYXlgKTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUoc2NhbGFycykpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXRvLWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6WyJtb2QiLCJhYnl0ZXMiLCJieXRlc1RvTnVtYmVyQkUiLCJjb25jYXRCeXRlcyIsInV0ZjhUb0J5dGVzIiwidmFsaWRhdGVPYmplY3QiLCJvczJpcCIsImkyb3NwIiwidmFsdWUiLCJsZW5ndGgiLCJFcnJvciIsInJlcyIsIkFycmF5IiwiZnJvbSIsImZpbGwiLCJpIiwiVWludDhBcnJheSIsInN0cnhvciIsImEiLCJiIiwiYXJyIiwiYW51bSIsIml0ZW0iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiZXhwYW5kX21lc3NhZ2VfeG1kIiwibXNnIiwiRFNUIiwibGVuSW5CeXRlcyIsIkgiLCJvdXRwdXRMZW4iLCJiX2luX2J5dGVzIiwiYmxvY2tMZW4iLCJyX2luX2J5dGVzIiwiZWxsIiwiTWF0aCIsImNlaWwiLCJEU1RfcHJpbWUiLCJaX3BhZCIsImxfaV9iX3N0ciIsImJfMCIsImFyZ3MiLCJwc2V1ZG9fcmFuZG9tX2J5dGVzIiwic2xpY2UiLCJleHBhbmRfbWVzc2FnZV94b2YiLCJrIiwiZGtMZW4iLCJjcmVhdGUiLCJ1cGRhdGUiLCJkaWdlc3QiLCJoYXNoX3RvX2ZpZWxkIiwiY291bnQiLCJvcHRpb25zIiwicCIsIm0iLCJoYXNoIiwiZXhwYW5kIiwiX0RTVCIsImxvZzJwIiwidG9TdHJpbmciLCJMIiwibGVuX2luX2J5dGVzIiwicHJiIiwidSIsImUiLCJqIiwiZWxtX29mZnNldCIsInR2Iiwic3ViYXJyYXkiLCJpc29nZW55TWFwIiwiZmllbGQiLCJtYXAiLCJDT0VGRiIsInJldmVyc2UiLCJ4IiwieSIsInhOdW0iLCJ4RGVuIiwieU51bSIsInlEZW4iLCJ2YWwiLCJyZWR1Y2UiLCJhY2MiLCJhZGQiLCJtdWwiLCJkaXYiLCJjcmVhdGVIYXNoZXIiLCJQb2ludCIsIm1hcFRvQ3VydmUiLCJkZWYiLCJoYXNoVG9DdXJ2ZSIsInUwIiwiZnJvbUFmZmluZSIsInUxIiwiUCIsImNsZWFyQ29mYWN0b3IiLCJhc3NlcnRWYWxpZGl0eSIsImVuY29kZVRvQ3VydmUiLCJlbmNvZGVEU1QiLCJzY2FsYXJzIiwiaXNBcnJheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/@noble/curves/esm/abstract/modular.js":
/*!*************************************************************!*\
  !*** ../node_modules/@noble/curves/esm/abstract/modular.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ // TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n) throw new Error(\"Expected power/modulo > 0\");\n    if (modulo === _1n) return _0n;\n    let res = _1n;\n    while(power > _0n){\n        if (power & _1n) res = res * num % modulo;\n        num = num * num % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ‚â° 1    if a is a square (mod p)\n    // (a | p) ‚â° -1   if a is not a square (mod p)\n    // (a | p) ‚â° 0    if a ‚â° 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for(Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n    // Step 2: Select a non-square z such that (z | p) ‚â° -1 and set c ‚â° zq\n    for(Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ‚â° -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error(\"Cannot find square root\");\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while(!Fp.eql(b, Fp.ONE)){\n            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for(let t2 = Fp.sqr(b); m < r; m++){\n                if (Fp.eql(t2, Fp.ONE)) break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ‚â° 3 (mod 4)\n    // ‚àön = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Atkin algorithm for q ‚â° 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // P ‚â° 9 (mod 16)\n    if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"isSafeInteger\",\n        BITS: \"isSafeInteger\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n) throw new Error(\"Expected power > 0\");\n    if (power === _0n) return f.ONE;\n    if (power === _1n) return num;\n    let p = f.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */ function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x)=>{\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048) throw new Error(\"Field lengths over 2048 bytes are not supported\");\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: redef.sqrt || ((n)=>sqrtP(f, n)),\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c)=>c ? b : a,\n        toBytes: (num)=>isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes)=>{\n            if (bytes.length !== BYTES) throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        }\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */ function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== \"bigint\") throw new Error(\"field order must be bigint\");\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n} //# sourceMappingURL=modular.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0VBQW9FLEdBQ3BFLHNEQUFzRDtBQUNpRjtBQUN2SSxrQkFBa0I7QUFDbEIsTUFBTU8sTUFBTUMsT0FBTyxJQUFJQyxNQUFNRCxPQUFPLElBQUlFLE1BQU1GLE9BQU8sSUFBSUcsTUFBTUgsT0FBTztBQUN0RSxrQkFBa0I7QUFDbEIsTUFBTUksTUFBTUosT0FBTyxJQUFJSyxNQUFNTCxPQUFPLElBQUlNLE1BQU1OLE9BQU87QUFDckQsa0JBQWtCO0FBQ2xCLE1BQU1PLE1BQU1QLE9BQU8sSUFBSVEsT0FBT1IsT0FBTztBQUNyQyx3QkFBd0I7QUFDakIsU0FBU1MsSUFBSUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3BCLE1BQU1DLFNBQVNGLElBQUlDO0lBQ25CLE9BQU9DLFVBQVViLE1BQU1hLFNBQVNELElBQUlDO0FBQ3hDO0FBQ0E7Ozs7O0NBS0MsR0FDRCxvQ0FBb0M7QUFDN0IsU0FBU0MsSUFBSUMsR0FBRyxFQUFFQyxLQUFLLEVBQUVDLE1BQU07SUFDbEMsSUFBSUEsVUFBVWpCLE9BQU9nQixRQUFRaEIsS0FDekIsTUFBTSxJQUFJa0IsTUFBTTtJQUNwQixJQUFJRCxXQUFXZixLQUNYLE9BQU9GO0lBQ1gsSUFBSW1CLE1BQU1qQjtJQUNWLE1BQU9jLFFBQVFoQixJQUFLO1FBQ2hCLElBQUlnQixRQUFRZCxLQUNSaUIsTUFBTSxNQUFPSixNQUFPRTtRQUN4QkYsTUFBTSxNQUFPQSxNQUFPRTtRQUNwQkQsVUFBVWQ7SUFDZDtJQUNBLE9BQU9pQjtBQUNYO0FBQ0EsMERBQTBEO0FBQ25ELFNBQVNDLEtBQUtDLENBQUMsRUFBRUwsS0FBSyxFQUFFQyxNQUFNO0lBQ2pDLElBQUlFLE1BQU1FO0lBQ1YsTUFBT0wsVUFBVWhCLElBQUs7UUFDbEJtQixPQUFPQTtRQUNQQSxPQUFPRjtJQUNY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b2R1bGFyLmpzPzUwZGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVXRpbGl0aWVzIGZvciBtb2R1bGFyIGFyaXRobWV0aWNzIGFuZCBmaW5pdGUgZmllbGRzXG5pbXBvcnQgeyBiaXRNYXNrLCBieXRlc1RvTnVtYmVyQkUsIGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSwgbnVtYmVyVG9CeXRlc0xFLCB2YWxpZGF0ZU9iamVjdCwgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfNG4gPSBCaWdJbnQoNCksIF81biA9IEJpZ0ludCg1KSwgXzhuID0gQmlnSW50KDgpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfOW4gPSBCaWdJbnQoOSksIF8xNm4gPSBCaWdJbnQoMTYpO1xuLy8gQ2FsY3VsYXRlcyBhIG1vZHVsbyBiXG5leHBvcnQgZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IHJhaXNlIG51bSB0byBwb3dlciBhbmQgZG8gbW9kdWxhciBkaXZpc2lvbi5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqIEBleGFtcGxlXG4gKiBwb3coMm4sIDZuLCAxMW4pIC8vIDY0biAlIDExbiA9PSA5blxuICovXG4vLyBUT0RPOiB1c2UgZmllbGQgdmVyc2lvbiAmJiByZW1vdmVcbmV4cG9ydCBmdW5jdGlvbiBwb3cobnVtLCBwb3dlciwgbW9kdWxvKSB7XG4gICAgaWYgKG1vZHVsbyA8PSBfMG4gfHwgcG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIvbW9kdWxvID4gMCcpO1xuICAgIGlmIChtb2R1bG8gPT09IF8xbilcbiAgICAgICAgcmV0dXJuIF8wbjtcbiAgICBsZXQgcmVzID0gXzFuO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICByZXMgPSAocmVzICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgbnVtID0gKG51bSAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBEb2VzIHggXiAoMiBeIHBvd2VyKSBtb2QgcC4gcG93MigzMCwgNCkgPT0gMzAgXiAoMiBeIDQpXG5leHBvcnQgZnVuY3Rpb24gcG93Mih4LCBwb3dlciwgbW9kdWxvKSB7XG4gICAgbGV0IHJlcyA9IHg7XG4gICAgd2hpbGUgKHBvd2VyLS0gPiBfMG4pIHtcbiAgICAgICAgcmVzICo9IHJlcztcbiAgICAgICAgcmVzICU9IG1vZHVsbztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsb1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChudW1iZXIsIG1vZHVsbykge1xuICAgIGlmIChudW1iZXIgPT09IF8wbiB8fCBtb2R1bG8gPD0gXzBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VycywgZ290IG49JHtudW1iZXJ9IG1vZD0ke21vZHVsb31gKTtcbiAgICB9XG4gICAgLy8gRXVjbGlkZWFuIEdDRCBodHRwczovL2JyaWxsaWFudC5vcmcvd2lraS9leHRlbmRlZC1ldWNsaWRlYW4tYWxnb3JpdGhtL1xuICAgIC8vIEZlcm1hdCdzIGxpdHRsZSB0aGVvcmVtIFwiQ1QtbGlrZVwiIHZlcnNpb24gaW52KG4pID0gbl4obS0yKSBtb2QgbSBpcyAzMHggc2xvd2VyLlxuICAgIGxldCBhID0gbW9kKG51bWJlciwgbW9kdWxvKTtcbiAgICBsZXQgYiA9IG1vZHVsbztcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgeCA9IF8wbiwgeSA9IF8xbiwgdSA9IF8xbiwgdiA9IF8wbjtcbiAgICB3aGlsZSAoYSAhPT0gXzBuKSB7XG4gICAgICAgIC8vIEpJVCBhcHBsaWVzIG9wdGltaXphdGlvbiBpZiB0aG9zZSB0d28gbGluZXMgZm9sbG93IGVhY2ggb3RoZXJcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBiID0gYSwgYSA9IHIsIHggPSB1LCB5ID0gdiwgdSA9IG0sIHYgPSBuO1xuICAgIH1cbiAgICBjb25zdCBnY2QgPSBiO1xuICAgIGlmIChnY2QgIT09IF8xbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuIG1vZCh4LCBtb2R1bG8pO1xufVxuLyoqXG4gKiBUb25lbGxpLVNoYW5rcyBzcXVhcmUgcm9vdCBzZWFyY2ggYWxnb3JpdGhtLlxuICogMS4gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEyKVxuICogMi4gU3F1YXJlIFJvb3RzIGZyb20gMTsgMjQsIDUxLCAxMCB0byBEYW4gU2hhbmtzXG4gKiBXaWxsIHN0YXJ0IGFuIGluZmluaXRlIGxvb3AgaWYgZmllbGQgb3JkZXIgUCBpcyBub3QgcHJpbWUuXG4gKiBAcGFyYW0gUCBmaWVsZCBvcmRlclxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB0YWtlcyBmaWVsZCBGcCAoY3JlYXRlZCBmcm9tIFApIGFuZCBudW1iZXIgblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gTGVnZW5kcmUgY29uc3RhbnQ6IHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApLFxuICAgIC8vIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXG4gICAgLy8gKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAtMSAgIGlmIGEgaXMgbm90IGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuICAgIGNvbnN0IGxlZ2VuZHJlQyA9IChQIC0gXzFuKSAvIF8ybjtcbiAgICBsZXQgUSwgUywgWjtcbiAgICAvLyBTdGVwIDE6IEJ5IGZhY3RvcmluZyBvdXQgcG93ZXJzIG9mIDIgZnJvbSBwIC0gMSxcbiAgICAvLyBmaW5kIHEgYW5kIHMgc3VjaCB0aGF0IHAgLSAxID0gcSooMl5zKSB3aXRoIHEgb2RkXG4gICAgZm9yIChRID0gUCAtIF8xbiwgUyA9IDA7IFEgJSBfMm4gPT09IF8wbjsgUSAvPSBfMm4sIFMrKylcbiAgICAgICAgO1xuICAgIC8vIFN0ZXAgMjogU2VsZWN0IGEgbm9uLXNxdWFyZSB6IHN1Y2ggdGhhdCAoeiB8IHApIOKJoSAtMSBhbmQgc2V0IGMg4omhIHpxXG4gICAgZm9yIChaID0gXzJuOyBaIDwgUCAmJiBwb3coWiwgbGVnZW5kcmVDLCBQKSAhPT0gUCAtIF8xbjsgWisrKVxuICAgICAgICA7XG4gICAgLy8gRmFzdC1wYXRoXG4gICAgaWYgKFMgPT09IDEpIHtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaUZhc3QoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFNsb3ctcGF0aFxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgLy8gU3RlcCAwOiBDaGVjayB0aGF0IG4gaXMgaW5kZWVkIGEgc3F1YXJlOiAobiB8IHApIHNob3VsZCBub3QgYmUg4omhIC0xXG4gICAgICAgIGlmIChGcC5wb3cobiwgbGVnZW5kcmVDKSA9PT0gRnAubmVnKEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgIGxldCByID0gUztcbiAgICAgICAgLy8gVE9ETzogd2lsbCBmYWlsIGF0IEZwMi9ldGNcbiAgICAgICAgbGV0IGcgPSBGcC5wb3coRnAubXVsKEZwLk9ORSwgWiksIFEpOyAvLyB3aWxsIHVwZGF0ZSBib3RoIHggYW5kIGJcbiAgICAgICAgbGV0IHggPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG4gICAgICAgIGxldCBiID0gRnAucG93KG4sIFEpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG4gICAgICAgIHdoaWxlICghRnAuZXFsKGIsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgIGlmIChGcC5lcWwoYiwgRnAuWkVSTykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwLlpFUk87IC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvbmVsbGklRTIlODAlOTNTaGFua3NfYWxnb3JpdGhtICg0LiBJZiB0ID0gMCwgcmV0dXJuIHIgPSAwKVxuICAgICAgICAgICAgLy8gRmluZCBtIHN1Y2ggYl4oMl5tKT09MVxuICAgICAgICAgICAgbGV0IG0gPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgdDIgPSBGcC5zcXIoYik7IG0gPCByOyBtKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnAuZXFsKHQyLCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0MiA9IEZwLnNxcih0Mik7IC8vIHQyICo9IHQyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFOiByLW0tMSBjYW4gYmUgYmlnZ2VyIHRoYW4gMzIsIG5lZWQgdG8gY29udmVydCB0byBiaWdpbnQgYmVmb3JlIHNoaWZ0LCBvdGhlcndpc2UgdGhlcmUgd2lsbCBiZSBvdmVyZmxvd1xuICAgICAgICAgICAgY29uc3QgZ2UgPSBGcC5wb3coZywgXzFuIDw8IEJpZ0ludChyIC0gbSAtIDEpKTsgLy8gZ2UgPSAyXihyLW0tMSlcbiAgICAgICAgICAgIGcgPSBGcC5zcXIoZ2UpOyAvLyBnID0gZ2UgKiBnZVxuICAgICAgICAgICAgeCA9IEZwLm11bCh4LCBnZSk7IC8vIHggKj0gZ2VcbiAgICAgICAgICAgIGIgPSBGcC5tdWwoYiwgZyk7IC8vIGIgKj0gZ1xuICAgICAgICAgICAgciA9IG07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnQoUCkge1xuICAgIC8vIE5PVEU6IGRpZmZlcmVudCBhbGdvcml0aG1zIGNhbiBnaXZlIGRpZmZlcmVudCByb290cywgaXQgaXMgdXAgdG8gdXNlciB0byBkZWNpZGUgd2hpY2ggb25lIHRoZXkgd2FudC5cbiAgICAvLyBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAgICAvLyBQIOKJoSAzIChtb2QgNClcbiAgICAvLyDiiJpuID0gbl4oKFArMSkvNClcbiAgICBpZiAoUCAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIE5vdCBhbGwgcm9vdHMgcG9zc2libGUhXG4gICAgICAgIC8vIGNvbnN0IE9SREVSID1cbiAgICAgICAgLy8gICAweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYm47XG4gICAgICAgIC8vIGNvbnN0IE5VTSA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICAvLyBUaHJvdyBpZiByb290KioyICE9IG5cbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEF0a2luIGFsZ29yaXRobSBmb3IgcSDiiaEgNSAobW9kIDgpLCBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTApXG4gICAgaWYgKFAgJSBfOG4gPT09IF81bikge1xuICAgICAgICBjb25zdCBjMSA9IChQIC0gXzVuKSAvIF84bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xuICAgICAgICAgICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIGMxKTtcbiAgICAgICAgICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xuICAgICAgICAgICAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUCDiiaEgOSAobW9kIDE2KVxuICAgIGlmIChQICUgXzE2biA9PT0gXzluKSB7XG4gICAgICAgIC8vIE5PVEU6IHRvbmVsbGkgaXMgdG9vIHNsb3cgZm9yIGJscy1GcDIgY2FsY3VsYXRpb25zIGV2ZW4gb24gc3RhcnRcbiAgICAgICAgLy8gTWVhbnMgd2UgY2Fubm90IHVzZSBzcXJ0IGZvciBjb25zdGFudHMgYXQgYWxsIVxuICAgICAgICAvL1xuICAgICAgICAvLyBjb25zdCBjMSA9IEZwLnNxcnQoRnAubmVnYXRlKEZwLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMiA9IEZwLnNxcnQoYzEpOyAgICAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMyA9IEZwLnNxcnQoRnAubmVnYXRlKGMxKSk7ICAgICAvLyAgMy4gYzMgPSBzcXJ0KC1jMSkgaW4gRiwgaS5lLiwgKGMzXjIpID09IC1jMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGM0ID0gKFAgKyBfN24pIC8gXzE2bjsgICAgICAgICAgIC8vICA0LiBjNCA9IChxICsgNykgLyAxNiAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICAgICAgLy8gc3FydCA9ICh4KSA9PiB7XG4gICAgICAgIC8vICAgbGV0IHR2MSA9IEZwLnBvdyh4LCBjNCk7ICAgICAgICAgICAgIC8vICAxLiB0djEgPSB4XmM0XG4gICAgICAgIC8vICAgbGV0IHR2MiA9IEZwLm11bChjMSwgdHYxKTsgICAgICAgICAgIC8vICAyLiB0djIgPSBjMSAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IHR2MyA9IEZwLm11bChjMiwgdHYxKTsgICAgICAgICAvLyAgMy4gdHYzID0gYzIgKiB0djFcbiAgICAgICAgLy8gICBsZXQgdHY0ID0gRnAubXVsKGMzLCB0djEpOyAgICAgICAgICAgLy8gIDQuIHR2NCA9IGMzICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgZTEgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgNS4gIGUxID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTIgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MyksIHgpOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgdHYxID0gRnAuY21vdih0djEsIHR2MiwgZTEpOyAvLyAgNy4gdHYxID0gQ01PVih0djEsIHR2MiwgZTEpICAjIFNlbGVjdCB0djIgaWYgKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgdHYyID0gRnAuY21vdih0djQsIHR2MywgZTIpOyAvLyAgOC4gdHYyID0gQ01PVih0djQsIHR2MywgZTIpICAjIFNlbGVjdCB0djMgaWYgKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTMgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgcmV0dXJuIEZwLmNtb3YodHYxLCB0djIsIGUzKTsgLy8gIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAgIyBTZWxlY3QgdGhlIHNxcnQgZnJvbSB0djEgYW5kIHR2MlxuICAgICAgICAvLyB9XG4gICAgfVxuICAgIC8vIE90aGVyIGNhc2VzOiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAgICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcbn1cbi8vIExpdHRsZS1lbmRpYW4gY2hlY2sgZm9yIGZpcnN0IExFIGJpdCAobGFzdCBCRSBiaXQpO1xuZXhwb3J0IGNvbnN0IGlzTmVnYXRpdmVMRSA9IChudW0sIG1vZHVsbykgPT4gKG1vZChudW0sIG1vZHVsbykgJiBfMW4pID09PSBfMW47XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEZJRUxEX0ZJRUxEUyA9IFtcbiAgICAnY3JlYXRlJywgJ2lzVmFsaWQnLCAnaXMwJywgJ25lZycsICdpbnYnLCAnc3FydCcsICdzcXInLFxuICAgICdlcWwnLCAnYWRkJywgJ3N1YicsICdtdWwnLCAncG93JywgJ2RpdicsXG4gICAgJ2FkZE4nLCAnc3ViTicsICdtdWxOJywgJ3Nxck4nXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcbiAgICBjb25zdCBpbml0aWFsID0ge1xuICAgICAgICBPUkRFUjogJ2JpZ2ludCcsXG4gICAgICAgIE1BU0s6ICdiaWdpbnQnLFxuICAgICAgICBCWVRFUzogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBCSVRTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gRklFTERfRklFTERTLnJlZHVjZSgobWFwLCB2YWwpID0+IHtcbiAgICAgICAgbWFwW3ZhbF0gPSAnZnVuY3Rpb24nO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIGluaXRpYWwpO1xuICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdChmaWVsZCwgb3B0cyk7XG59XG4vLyBHZW5lcmljIGZpZWxkIGZ1bmN0aW9uc1xuLyoqXG4gKiBTYW1lIGFzIGBwb3dgIGJ1dCBmb3IgRnA6IG5vbi1jb25zdGFudC10aW1lLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBQb3coZiwgbnVtLCBwb3dlcikge1xuICAgIC8vIFNob3VsZCBoYXZlIHNhbWUgc3BlZWQgYXMgcG93IGZvciBiaWdpbnRzXG4gICAgLy8gVE9ETzogYmVuY2htYXJrIVxuICAgIGlmIChwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlciA+IDAnKTtcbiAgICBpZiAocG93ZXIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuIGYuT05FO1xuICAgIGlmIChwb3dlciA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIGxldCBwID0gZi5PTkU7XG4gICAgbGV0IGQgPSBudW07XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHAgPSBmLm11bChwLCBkKTtcbiAgICAgICAgZCA9IGYuc3FyKGQpO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgaW52ZXJ0IGFuIGFycmF5IG9mIEZpZWxkIGVsZW1lbnRzLlxuICogYGludigwKWAgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaGVyZTogbWFrZSBzdXJlIHRvIHRocm93IGFuIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBJbnZlcnRCYXRjaChmLCBudW1zKSB7XG4gICAgY29uc3QgdG1wID0gbmV3IEFycmF5KG51bXMubGVuZ3RoKTtcbiAgICAvLyBXYWxrIGZyb20gZmlyc3QgdG8gbGFzdCwgbXVsdGlwbHkgdGhlbSBieSBlYWNoIG90aGVyIE1PRCBwXG4gICAgY29uc3QgbGFzdE11bHRpcGxpZWQgPSBudW1zLnJlZHVjZSgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBhY2M7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgZi5PTkUpO1xuICAgIC8vIEludmVydCBsYXN0IGVsZW1lbnRcbiAgICBjb25zdCBpbnZlcnRlZCA9IGYuaW52KGxhc3RNdWx0aXBsaWVkKTtcbiAgICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBmLm11bChhY2MsIHRtcFtpXSk7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgaW52ZXJ0ZWQpO1xuICAgIHJldHVybiB0bXA7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBEaXYoZiwgbGhzLCByaHMpIHtcbiAgICByZXR1cm4gZi5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IGludmVydChyaHMsIGYuT1JERVIpIDogZi5pbnYocmhzKSk7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgVHJ1ZSB3aGVuZXZlciB0aGUgdmFsdWUgeCBpcyBhIHNxdWFyZSBpbiB0aGUgZmllbGQgRi5cbmV4cG9ydCBmdW5jdGlvbiBGcElzU3F1YXJlKGYpIHtcbiAgICBjb25zdCBsZWdlbmRyZUNvbnN0ID0gKGYuT1JERVIgLSBfMW4pIC8gXzJuOyAvLyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICByZXR1cm4gKHgpID0+IHtcbiAgICAgICAgY29uc3QgcCA9IGYucG93KHgsIGxlZ2VuZHJlQ29uc3QpO1xuICAgICAgICByZXR1cm4gZi5lcWwocCwgZi5aRVJPKSB8fCBmLmVxbChwLCBmLk9ORSk7XG4gICAgfTtcbn1cbi8vIENVUlZFLm4gbGVuZ3Roc1xuZXhwb3J0IGZ1bmN0aW9uIG5MZW5ndGgobiwgbkJpdExlbmd0aCkge1xuICAgIC8vIEJpdCBzaXplLCBieXRlIHNpemUgb2YgQ1VSVkUublxuICAgIGNvbnN0IF9uQml0TGVuZ3RoID0gbkJpdExlbmd0aCAhPT0gdW5kZWZpbmVkID8gbkJpdExlbmd0aCA6IG4udG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IG5CeXRlTGVuZ3RoID0gTWF0aC5jZWlsKF9uQml0TGVuZ3RoIC8gOCk7XG4gICAgcmV0dXJuIHsgbkJpdExlbmd0aDogX25CaXRMZW5ndGgsIG5CeXRlTGVuZ3RoIH07XG59XG4vKipcbiAqIEluaXRpYWxpemVzIGEgZmluaXRlIGZpZWxkIG92ZXIgcHJpbWUuICoqTm9uLXByaW1lcyBhcmUgbm90IHN1cHBvcnRlZC4qKlxuICogRG8gbm90IGluaXQgaW4gbG9vcDogc2xvdy4gVmVyeSBmcmFnaWxlOiBhbHdheXMgcnVuIGEgYmVuY2htYXJrIG9uIGEgY2hhbmdlLlxuICogTWFqb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uczpcbiAqICogYSkgZGVub3JtYWxpemVkIG9wZXJhdGlvbnMgbGlrZSBtdWxOIGluc3RlYWQgb2YgbXVsXG4gKiAqIGIpIHNhbWUgb2JqZWN0IHNoYXBlOiBuZXZlciBhZGQgb3IgcmVtb3ZlIGtleXNcbiAqICogYykgT2JqZWN0LmZyZWV6ZVxuICogQHBhcmFtIE9SREVSIHByaW1lIHBvc2l0aXZlIGJpZ2ludFxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xuICogQHBhcmFtIGlzTEUgKGRlZjogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cbiAqIEBwYXJhbSByZWRlZiBvcHRpb25hbCBmYXN0ZXIgcmVkZWZpbml0aW9ucyBvZiBzcXJ0IGFuZCBvdGhlciBtZXRob2RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuLCBpc0xFID0gZmFsc2UsIHJlZGVmID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIEZpZWxkIE9SREVSID4gMCwgZ290ICR7T1JERVJ9YCk7XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIGJpdExlbik7XG4gICAgaWYgKEJZVEVTID4gMjA0OClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZCBsZW5ndGhzIG92ZXIgMjA0OCBieXRlcyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIGNvbnN0IHNxcnRQID0gRnBTcXJ0KE9SREVSKTtcbiAgICBjb25zdCBmID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE9SREVSLFxuICAgICAgICBCSVRTLFxuICAgICAgICBCWVRFUyxcbiAgICAgICAgTUFTSzogYml0TWFzayhCSVRTKSxcbiAgICAgICAgWkVSTzogXzBuLFxuICAgICAgICBPTkU6IF8xbixcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBtb2QobnVtLCBPUkRFUiksXG4gICAgICAgIGlzVmFsaWQ6IChudW0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmllbGQgZWxlbWVudDogZXhwZWN0ZWQgYmlnaW50LCBnb3QgJHt0eXBlb2YgbnVtfWApO1xuICAgICAgICAgICAgcmV0dXJuIF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVI7IC8vIDAgaXMgdmFsaWQgZWxlbWVudCwgYnV0IGl0J3Mgbm90IGludmVydGlibGVcbiAgICAgICAgfSxcbiAgICAgICAgaXMwOiAobnVtKSA9PiBudW0gPT09IF8wbixcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXG4gICAgICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICAgICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgICAgICBzcXJOOiAobnVtKSA9PiBudW0gKiBudW0sXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICAgICAgbXVsTjogKGxocywgcmhzKSA9PiBsaHMgKiByaHMsXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgICAgICBzcXJ0OiByZWRlZi5zcXJ0IHx8ICgobikgPT4gc3FydFAoZiwgbikpLFxuICAgICAgICBpbnZlcnRCYXRjaDogKGxzdCkgPT4gRnBJbnZlcnRCYXRjaChmLCBsc3QpLFxuICAgICAgICAvLyBUT0RPOiBkbyB3ZSByZWFsbHkgbmVlZCBjb25zdGFudCBjbW92P1xuICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGNvbnN0LXRpbWUgYmlnaW50cyBhbnl3YXksIHNvIHByb2JhYmx5IHdpbGwgYmUgbm90IHZlcnkgdXNlZnVsXG4gICAgICAgIGNtb3Y6IChhLCBiLCBjKSA9PiAoYyA/IGIgOiBhKSxcbiAgICAgICAgdG9CeXRlczogKG51bSkgPT4gKGlzTEUgPyBudW1iZXJUb0J5dGVzTEUobnVtLCBCWVRFUykgOiBudW1iZXJUb0J5dGVzQkUobnVtLCBCWVRFUykpLFxuICAgICAgICBmcm9tQnl0ZXM6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gQllURVMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGcC5mcm9tQnl0ZXM6IGV4cGVjdGVkICR7QllURVN9LCBnb3QgJHtieXRlcy5sZW5ndGh9YCk7XG4gICAgICAgICAgICByZXR1cm4gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydE9kZChGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IHJvb3QgOiBGcC5uZWcocm9vdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IEZwLm5lZyhyb290KSA6IHJvb3Q7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIFNhbWUgYXMgbWFwS2V5VG9GaWVsZCwgYnV0IGFjY2VwdHMgbGVzcyBieXRlcyAoNDAgaW5zdGVhZCBvZiA0OCBmb3IgMzItYnl0ZSBmaWVsZCkuXG4gKiBXaGljaCBtYWtlcyBpdCBzbGlnaHRseSBtb3JlIGJpYXNlZCwgbGVzcyBzZWN1cmUuXG4gKiBAZGVwcmVjYXRlZCB1c2UgbWFwS2V5VG9GaWVsZCBpbnN0ZWFkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKGhhc2gsIGdyb3VwT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGhhc2ggPSBlbnN1cmVCeXRlcygncHJpdmF0ZUhhc2gnLCBoYXNoKTtcbiAgICBjb25zdCBoYXNoTGVuID0gaGFzaC5sZW5ndGg7XG4gICAgY29uc3QgbWluTGVuID0gbkxlbmd0aChncm91cE9yZGVyKS5uQnl0ZUxlbmd0aCArIDg7XG4gICAgaWYgKG1pbkxlbiA8IDI0IHx8IGhhc2hMZW4gPCBtaW5MZW4gfHwgaGFzaExlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaGFzaFRvUHJpdmF0ZVNjYWxhcjogZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2hhc2hMZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShoYXNoKSA6IGJ5dGVzVG9OdW1iZXJCRShoYXNoKTtcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbikgKyBfMW47XG59XG4vKipcbiAqIFJldHVybnMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGNvbnN1bWVkIGJ5IHRoZSBmaWVsZCBlbGVtZW50LlxuICogRm9yIGV4YW1wbGUsIDMyIGJ5dGVzIGZvciB1c3VhbCAyNTYtYml0IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIGZpZWxkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBpZiAodHlwZW9mIGZpZWxkT3JkZXIgIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkIG9yZGVyIG11c3QgYmUgYmlnaW50Jyk7XG4gICAgY29uc3QgYml0TGVuZ3RoID0gZmllbGRPcmRlci50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgcmV0dXJuIE1hdGguY2VpbChiaXRMZW5ndGggLyA4KTtcbn1cbi8qKlxuICogUmV0dXJucyBtaW5pbWFsIGFtb3VudCBvZiBieXRlcyB0aGF0IGNhbiBiZSBzYWZlbHkgcmVkdWNlZFxuICogYnkgZmllbGQgb3JkZXIuXG4gKiBTaG91bGQgYmUgMl4tMTI4IGZvciAxMjgtYml0IGN1cnZlIHN1Y2ggYXMgUDI1Ni5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiB0YXJnZXQgaGFzaFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBDYW4gdGFrZSAobiArIG4vMikgb3IgbW9yZSBieXRlcyBvZiB1bmlmb3JtIGlucHV0IGUuZy4gZnJvbSBDU1BSTkcgb3IgS0RGXG4gKiBhbmQgY29udmVydCB0aGVtIGludG8gcHJpdmF0ZSBzY2FsYXIsIHdpdGggdGhlIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gKiBOZWVkcyBhdCBsZWFzdCA0OCBieXRlcyBvZiBpbnB1dCBmb3IgMzItYnl0ZSBwcml2YXRlIGtleS5cbiAqIGh0dHBzOi8vcmVzZWFyY2gua3VkZWxza2lzZWN1cml0eS5jb20vMjAyMC8wNy8yOC90aGUtZGVmaW5pdGl2ZS1ndWlkZS10by1tb2R1bG8tYmlhcy1hbmQtaG93LXRvLWF2b2lkLWl0L1xuICogRklQUyAxODYtNSwgQS4yIGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZGV0YWlsL2ZpcHMvMTg2LzUvZmluYWxcbiAqIFJGQyA5MzgwLCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTVcbiAqIEBwYXJhbSBoYXNoIGhhc2ggb3V0cHV0IGZyb20gU0hBMyBvciBhIHNpbWlsYXIgZnVuY3Rpb25cbiAqIEBwYXJhbSBncm91cE9yZGVyIHNpemUgb2Ygc3ViZ3JvdXAgLSAoZS5nLiBzZWNwMjU2azEuQ1VSVkUubilcbiAqIEBwYXJhbSBpc0xFIGludGVycHJldCBoYXNoIGJ5dGVzIGFzIExFIG51bVxuICogQHJldHVybnMgdmFsaWQgcHJpdmF0ZSBzY2FsYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEhhc2hUb0ZpZWxkKGtleSwgZmllbGRPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcbiAgICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgY29uc3QgbWluTGVuID0gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKTtcbiAgICAvLyBObyBzbWFsbCBudW1iZXJzOiBuZWVkIHRvIHVuZGVyc3RhbmQgYmlhcyBzdG9yeS4gTm8gaHVnZSBudW1iZXJzOiBlYXNpZXIgdG8gZGV0ZWN0IEpTIHRpbWluZ3MuXG4gICAgaWYgKGxlbiA8IDE2IHx8IGxlbiA8IG1pbkxlbiB8fCBsZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtsZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJCRShrZXkpIDogYnl0ZXNUb051bWJlckxFKGtleSk7XG4gICAgLy8gYG1vZCh4LCAxMSlgIGNhbiBzb21ldGltZXMgcHJvZHVjZSAwLiBgbW9kKHgsIDEwKSArIDFgIGlzIHRoZSBzYW1lLCBidXQgbm8gMFxuICAgIGNvbnN0IHJlZHVjZWQgPSBtb2QobnVtLCBmaWVsZE9yZGVyIC0gXzFuKSArIF8xbjtcbiAgICByZXR1cm4gaXNMRSA/IG51bWJlclRvQnl0ZXNMRShyZWR1Y2VkLCBmaWVsZExlbikgOiBudW1iZXJUb0J5dGVzQkUocmVkdWNlZCwgZmllbGRMZW4pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxhci5qcy5tYXAiXSwibmFtZXMiOlsiYml0TWFzayIsImJ5dGVzVG9OdW1iZXJCRSIsImJ5dGVzVG9OdW1iZXJMRSIsImVuc3VyZUJ5dGVzIiwibnVtYmVyVG9CeXRlc0JFIiwibnVtYmVyVG9CeXRlc0xFIiwidmFsaWRhdGVPYmplY3QiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNG4iLCJfNW4iLCJfOG4iLCJfOW4iLCJfMTZuIiwibW9kIiwiYSIsImIiLCJyZXN1bHQiLCJwb3ciLCJudW0iLCJwb3dlciIsIm1vZHVsbyIsIkVycm9yIiwicmVzIiwicG93MiIsIngiLCJpbnZlcnQiLCJudW1iZXIiLCJ5IiwidSIsInYiLCJxIiwiciIsIm0iLCJuIiwiZ2NkIiwidG9uZWxsaVNoYW5rcyIsIlAiLCJsZWdlbmRyZUMiLCJRIiwiUyIsIloiLCJwMWRpdjQiLCJ0b25lbGxpRmFzdCIsIkZwIiwicm9vdCIsImVxbCIsInNxciIsIlExZGl2MiIsInRvbmVsbGlTbG93IiwibmVnIiwiT05FIiwiZyIsIm11bCIsIlpFUk8iLCJ0MiIsImdlIiwiRnBTcXJ0Iiwic3FydDNtb2Q0IiwiYzEiLCJzcXJ0NW1vZDgiLCJuMiIsIm52IiwiaSIsInN1YiIsImlzTmVnYXRpdmVMRSIsIkZJRUxEX0ZJRUxEUyIsInZhbGlkYXRlRmllbGQiLCJmaWVsZCIsImluaXRpYWwiLCJPUkRFUiIsIk1BU0siLCJCWVRFUyIsIkJJVFMiLCJvcHRzIiwicmVkdWNlIiwibWFwIiwidmFsIiwiRnBQb3ciLCJmIiwicCIsImQiLCJGcEludmVydEJhdGNoIiwibnVtcyIsInRtcCIsIkFycmF5IiwibGVuZ3RoIiwibGFzdE11bHRpcGxpZWQiLCJhY2MiLCJpczAiLCJpbnZlcnRlZCIsImludiIsInJlZHVjZVJpZ2h0IiwiRnBEaXYiLCJsaHMiLCJyaHMiLCJGcElzU3F1YXJlIiwibGVnZW5kcmVDb25zdCIsIm5MZW5ndGgiLCJuQml0TGVuZ3RoIiwiX25CaXRMZW5ndGgiLCJ1bmRlZmluZWQiLCJ0b1N0cmluZyIsIm5CeXRlTGVuZ3RoIiwiTWF0aCIsImNlaWwiLCJGaWVsZCIsImJpdExlbiIsImlzTEUiLCJyZWRlZiIsInNxcnRQIiwiT2JqZWN0IiwiZnJlZXplIiwiY3JlYXRlIiwiaXNWYWxpZCIsImlzT2RkIiwiYWRkIiwiZGl2Iiwic3FyTiIsImFkZE4iLCJzdWJOIiwibXVsTiIsInNxcnQiLCJpbnZlcnRCYXRjaCIsImxzdCIsImNtb3YiLCJjIiwidG9CeXRlcyIsImZyb21CeXRlcyIsImJ5dGVzIiwiRnBTcXJ0T2RkIiwiZWxtIiwiRnBTcXJ0RXZlbiIsImhhc2hUb1ByaXZhdGVTY2FsYXIiLCJoYXNoIiwiZ3JvdXBPcmRlciIsImhhc2hMZW4iLCJtaW5MZW4iLCJnZXRGaWVsZEJ5dGVzTGVuZ3RoIiwiZmllbGRPcmRlciIsImJpdExlbmd0aCIsImdldE1pbkhhc2hMZW5ndGgiLCJtYXBIYXNoVG9GaWVsZCIsImtleSIsImxlbiIsImZpZWxkTGVuIiwicmVkdWNlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/@noble/curves/esm/abstract/modular.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/@noble/curves/esm/abstract/montgomery.js":
/*!****************************************************************!*\
  !*** ../node_modules/@noble/curves/esm/abstract/montgomery.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   montgomery: () => (/* binding */ montgomery)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction validateOpts(curve) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(curve, {\n        a: \"bigint\"\n    }, {\n        montgomeryBits: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\",\n        adjustScalarBytes: \"function\",\n        domain: \"function\",\n        powPminus2: \"function\",\n        Gu: \"bigint\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...curve\n    });\n}\n// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)\n// Uses only one coordinate instead of two\nfunction montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P } = CURVE;\n    const modP = (n)=>(0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(n, P);\n    const montgomeryBits = CURVE.montgomeryBits;\n    const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n    const fieldLen = CURVE.nByteLength;\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes)=>bytes);\n    const powPminus2 = CURVE.powPminus2 || ((x)=>(0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.pow)(x, P - BigInt(2), P));\n    // cswap from RFC7748. But it is not from RFC7748!\n    /*\n      cswap(swap, x_2, x_3):\n           dummy = mask(swap) AND (x_2 XOR x_3)\n           x_2 = x_2 XOR dummy\n           x_3 = x_3 XOR dummy\n           Return (x_2, x_3)\n    Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n     and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    */ function cswap(swap, x_2, x_3) {\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy);\n        x_3 = modP(x_3 + dummy);\n        return [\n            x_2,\n            x_3\n        ];\n    }\n    // Accepts 0 as well\n    function assertFieldElement(n) {\n        if (typeof n === \"bigint\" && _0n <= n && n < P) return n;\n        throw new Error(\"Expected valid scalar 0 < scalar < CURVE.P\");\n    }\n    // x25519 from 4\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n    const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n    /**\n     *\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */ function montgomeryLadder(pointU, scalar) {\n        const u = assertFieldElement(pointU);\n        // Section 5: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.\n        const k = assertFieldElement(scalar);\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        let sw;\n        for(let t = BigInt(montgomeryBits - 1); t >= _0n; t--){\n            const k_t = k >> t & _1n;\n            swap ^= k_t;\n            sw = cswap(swap, x_2, x_3);\n            x_2 = sw[0];\n            x_3 = sw[1];\n            sw = cswap(swap, z_2, z_3);\n            z_2 = sw[0];\n            z_3 = sw[1];\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        // (x_2, x_3) = cswap(swap, x_2, x_3)\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        // (z_2, z_3) = cswap(swap, z_2, z_3)\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        // z_2^(p - 2)\n        const z2 = powPminus2(z_2);\n        // Return x_2 * (z_2^(p - 2))\n        return modP(x_2 * z2);\n    }\n    function encodeUCoordinate(u) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(modP(u), montgomeryBytes);\n    }\n    function decodeUCoordinate(uEnc) {\n        // Section 5: When receiving such an array, implementations of X25519\n        // MUST mask the most significant bit in the final byte.\n        const u = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"u coordinate\", uEnc, montgomeryBytes);\n        if (fieldLen === 32) u[31] &= 127; // 0b0111_1111\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(u);\n    }\n    function decodeScalar(n) {\n        const bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"scalar\", n);\n        const len = bytes.length;\n        if (len !== montgomeryBytes && len !== fieldLen) throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${len}`);\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(adjustScalarBytes(bytes));\n    }\n    function scalarMult(scalar, u) {\n        const pointU = decodeUCoordinate(u);\n        const _scalar = decodeScalar(scalar);\n        const pu = montgomeryLadder(pointU, _scalar);\n        // The result was not contributory\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n) throw new Error(\"Invalid private or public key received\");\n        return encodeUCoordinate(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    const GuBytes = encodeUCoordinate(CURVE.Gu);\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    return {\n        scalarMult,\n        scalarMultBase,\n        getSharedSecret: (privateKey, publicKey)=>scalarMult(privateKey, publicKey),\n        getPublicKey: (privateKey)=>scalarMultBase(privateKey),\n        utils: {\n            randomPrivateKey: ()=>CURVE.randomBytes(CURVE.nByteLength)\n        },\n        GuBytes: GuBytes\n    };\n} //# sourceMappingURL=montgomery.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vbnRnb21lcnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsb0VBQW9FLEdBQzVCO0FBQ21EO0FBQzNGLE1BQU1NLE1BQU1DLE9BQU87QUFDbkIsTUFBTUMsTUFBTUQsT0FBTztBQUNuQixTQUFTRSxhQUFhQyxLQUFLO0lBQ3ZCTCx5REFBY0EsQ0FBQ0ssT0FBTztRQUNsQkMsR0FBRztJQUNQLEdBQUc7UUFDQ0MsZ0JBQWdCO1FBQ2hCQyxhQUFhO1FBQ2JDLG1CQUFtQjtRQUNuQkMsUUFBUTtRQUNSQyxZQUFZO1FBQ1pDLElBQUk7SUFDUjtJQUNBLGVBQWU7SUFDZixPQUFPQyxPQUFPQyxNQUFNLENBQUM7UUFBRSxHQUFHVCxLQUFLO0lBQUM7QUFDcEM7QUFDQSw0SUFBNEk7QUFDNUksMENBQTBDO0FBQ25DLFNBQVNVLFdBQVdDLFFBQVE7SUFDL0IsTUFBTUMsUUFBUWIsYUFBYVk7SUFDM0IsTUFBTSxFQUFFRSxDQUFDLEVBQUUsR0FBR0Q7SUFDZCxNQUFNRSxPQUFPLENBQUNDLElBQU16QixnREFBR0EsQ0FBQ3lCLEdBQUdGO0lBQzNCLE1BQU1YLGlCQUFpQlUsTUFBTVYsY0FBYztJQUMzQyxNQUFNYyxrQkFBa0JDLEtBQUtDLElBQUksQ0FBQ2hCLGlCQUFpQjtJQUNuRCxNQUFNaUIsV0FBV1AsTUFBTVQsV0FBVztJQUNsQyxNQUFNQyxvQkFBb0JRLE1BQU1SLGlCQUFpQixJQUFLLEVBQUNnQixRQUFVQSxLQUFJO0lBQ3JFLE1BQU1kLGFBQWFNLE1BQU1OLFVBQVUsSUFBSyxFQUFDZSxJQUFNOUIsZ0RBQUdBLENBQUM4QixHQUFHUixJQUFJaEIsT0FBTyxJQUFJZ0IsRUFBQztJQUN0RSxrREFBa0Q7SUFDbEQ7Ozs7Ozs7O0lBUUEsR0FDQSxTQUFTUyxNQUFNQyxJQUFJLEVBQUVDLEdBQUcsRUFBRUMsR0FBRztRQUN6QixNQUFNQyxRQUFRWixLQUFLUyxPQUFRQyxDQUFB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S0FBSyxjQUFjO1FBQ2hDLE9BQU96QywwREFBZUEsQ0FBQ3lDO0lBQzNCO0lBQ0EsU0FBU3VCLGFBQWF6QyxDQUFDO1FBQ25CLE1BQU1LLFFBQVEzQixzREFBV0EsQ0FBQyxVQUFVc0I7UUFDcEMsTUFBTTBDLE1BQU1yQyxNQUFNc0MsTUFBTTtRQUN4QixJQUFJRCxRQUFRekMsbUJBQW1CeUMsUUFBUXRDLFVBQ25DLE1BQU0sSUFBSVMsTUFBTSxDQUFDLFNBQVMsRUFBRVosZ0JBQWdCLElBQUksRUFBRUcsU0FBUyxZQUFZLEVBQUVzQyxJQUFJLENBQUM7UUFDbEYsT0FBT2pFLDBEQUFlQSxDQUFDWSxrQkFBa0JnQjtJQUM3QztJQUNBLFNBQVN1QyxXQUFXM0IsTUFBTSxFQUFFQyxDQUFDO1FBQ3pCLE1BQU1GLFNBQVN1QixrQkFBa0JyQjtRQUNqQyxNQUFNMkIsVUFBVUosYUFBYXhCO1FBQzdCLE1BQU02QixLQUFLL0IsaUJBQWlCQyxRQUFRNkI7UUFDcEMsa0NBQWtDO1FBQ2xDLHNDQUFzQztRQUN0QyxJQUFJQyxPQUFPakUsS0FDUCxNQUFNLElBQUlnQyxNQUFNO1FBQ3BCLE9BQU95QixrQkFBa0JRO0lBQzdCO0lBQ0Esa0ZBQWtGO0lBQ2xGLE1BQU1DLFVBQVVULGtCQUFrQnpDLE1BQU1MLEVBQUU7SUFDMUMsU0FBU3dELGVBQWUvQixNQUFNO1FBQzFCLE9BQU8yQixXQUFXM0IsUUFBUThCO0lBQzlCO0lBQ0EsT0FBTztRQUNISDtRQUNBSTtRQUNBQyxpQkFBaUIsQ0FBQ0MsWUFBWUMsWUFBY1AsV0FBV00sWUFBWUM7UUFDbkVDLGNBQWMsQ0FBQ0YsYUFBZUYsZUFBZUU7UUFDN0NHLE9BQU87WUFBRUMsa0JBQWtCLElBQU16RCxNQUFNMEQsV0FBVyxDQUFDMUQsTUFBTVQsV0FBVztRQUFFO1FBQ3RFMkQsU0FBU0E7SUFDYjtBQUNKLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb250Z29tZXJ5LmpzPzQ5YTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgbW9kLCBwb3cgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgbnVtYmVyVG9CeXRlc0xFLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgdmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgYTogJ2JpZ2ludCcsXG4gICAgfSwge1xuICAgICAgICBtb250Z29tZXJ5Qml0czogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBhZGp1c3RTY2FsYXJCeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgZG9tYWluOiAnZnVuY3Rpb24nLFxuICAgICAgICBwb3dQbWludXMyOiAnZnVuY3Rpb24nLFxuICAgICAgICBHdTogJ2JpZ2ludCcsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jdXJ2ZSB9KTtcbn1cbi8vIE5PVEU6IG5vdCByZWFsbHkgbW9udGdvbWVyeSBjdXJ2ZSwganVzdCBidW5jaCBvZiB2ZXJ5IHNwZWNpZmljIG1ldGhvZHMgZm9yIFgyNTUxOS9YNDQ4IChSRkMgNzc0OCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzc3NDgpXG4vLyBVc2VzIG9ubHkgb25lIGNvb3JkaW5hdGUgaW5zdGVhZCBvZiB0d29cbmV4cG9ydCBmdW5jdGlvbiBtb250Z29tZXJ5KGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgUCB9ID0gQ1VSVkU7XG4gICAgY29uc3QgbW9kUCA9IChuKSA9PiBtb2QobiwgUCk7XG4gICAgY29uc3QgbW9udGdvbWVyeUJpdHMgPSBDVVJWRS5tb250Z29tZXJ5Qml0cztcbiAgICBjb25zdCBtb250Z29tZXJ5Qnl0ZXMgPSBNYXRoLmNlaWwobW9udGdvbWVyeUJpdHMgLyA4KTtcbiAgICBjb25zdCBmaWVsZExlbiA9IENVUlZFLm5CeXRlTGVuZ3RoO1xuICAgIGNvbnN0IGFkanVzdFNjYWxhckJ5dGVzID0gQ1VSVkUuYWRqdXN0U2NhbGFyQnl0ZXMgfHwgKChieXRlcykgPT4gYnl0ZXMpO1xuICAgIGNvbnN0IHBvd1BtaW51czIgPSBDVVJWRS5wb3dQbWludXMyIHx8ICgoeCkgPT4gcG93KHgsIFAgLSBCaWdJbnQoMiksIFApKTtcbiAgICAvLyBjc3dhcCBmcm9tIFJGQzc3NDguIEJ1dCBpdCBpcyBub3QgZnJvbSBSRkM3NzQ4IVxuICAgIC8qXG4gICAgICBjc3dhcChzd2FwLCB4XzIsIHhfMyk6XG4gICAgICAgICAgIGR1bW15ID0gbWFzayhzd2FwKSBBTkQgKHhfMiBYT1IgeF8zKVxuICAgICAgICAgICB4XzIgPSB4XzIgWE9SIGR1bW15XG4gICAgICAgICAgIHhfMyA9IHhfMyBYT1IgZHVtbXlcbiAgICAgICAgICAgUmV0dXJuICh4XzIsIHhfMylcbiAgICBXaGVyZSBtYXNrKHN3YXApIGlzIHRoZSBhbGwtMSBvciBhbGwtMCB3b3JkIG9mIHRoZSBzYW1lIGxlbmd0aCBhcyB4XzJcbiAgICAgYW5kIHhfMywgY29tcHV0ZWQsIGUuZy4sIGFzIG1hc2soc3dhcCkgPSAwIC0gc3dhcC5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGNzd2FwKHN3YXAsIHhfMiwgeF8zKSB7XG4gICAgICAgIGNvbnN0IGR1bW15ID0gbW9kUChzd2FwICogKHhfMiAtIHhfMykpO1xuICAgICAgICB4XzIgPSBtb2RQKHhfMiAtIGR1bW15KTtcbiAgICAgICAgeF8zID0gbW9kUCh4XzMgKyBkdW1teSk7XG4gICAgICAgIHJldHVybiBbeF8yLCB4XzNdO1xuICAgIH1cbiAgICAvLyBBY2NlcHRzIDAgYXMgd2VsbFxuICAgIGZ1bmN0aW9uIGFzc2VydEZpZWxkRWxlbWVudChuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbiA9PT0gJ2JpZ2ludCcgJiYgXzBuIDw9IG4gJiYgbiA8IFApXG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWxpZCBzY2FsYXIgMCA8IHNjYWxhciA8IENVUlZFLlAnKTtcbiAgICB9XG4gICAgLy8geDI1NTE5IGZyb20gNFxuICAgIC8vIFRoZSBjb25zdGFudCBhMjQgaXMgKDQ4NjY2MiAtIDIpIC8gNCA9IDEyMTY2NSBmb3IgY3VydmUyNTUxOS9YMjU1MTlcbiAgICBjb25zdCBhMjQgPSAoQ1VSVkUuYSAtIEJpZ0ludCgyKSkgLyBCaWdJbnQoNCk7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9pbnRVIHUgY29vcmRpbmF0ZSAoeCkgb24gTW9udGdvbWVyeSBDdXJ2ZSAyNTUxOVxuICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgKiBAcmV0dXJucyBuZXcgUG9pbnQgb24gTW9udGdvbWVyeSBjdXJ2ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vbnRnb21lcnlMYWRkZXIocG9pbnRVLCBzY2FsYXIpIHtcbiAgICAgICAgY29uc3QgdSA9IGFzc2VydEZpZWxkRWxlbWVudChwb2ludFUpO1xuICAgICAgICAvLyBTZWN0aW9uIDU6IEltcGxlbWVudGF0aW9ucyBNVVNUIGFjY2VwdCBub24tY2Fub25pY2FsIHZhbHVlcyBhbmQgcHJvY2VzcyB0aGVtIGFzXG4gICAgICAgIC8vIGlmIHRoZXkgaGFkIGJlZW4gcmVkdWNlZCBtb2R1bG8gdGhlIGZpZWxkIHByaW1lLlxuICAgICAgICBjb25zdCBrID0gYXNzZXJ0RmllbGRFbGVtZW50KHNjYWxhcik7XG4gICAgICAgIGNvbnN0IHhfMSA9IHU7XG4gICAgICAgIGxldCB4XzIgPSBfMW47XG4gICAgICAgIGxldCB6XzIgPSBfMG47XG4gICAgICAgIGxldCB4XzMgPSB1O1xuICAgICAgICBsZXQgel8zID0gXzFuO1xuICAgICAgICBsZXQgc3dhcCA9IF8wbjtcbiAgICAgICAgbGV0IHN3O1xuICAgICAgICBmb3IgKGxldCB0ID0gQmlnSW50KG1vbnRnb21lcnlCaXRzIC0gMSk7IHQgPj0gXzBuOyB0LS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGtfdCA9IChrID4+IHQpICYgXzFuO1xuICAgICAgICAgICAgc3dhcCBePSBrX3Q7XG4gICAgICAgICAgICBzdyA9IGNzd2FwKHN3YXAsIHhfMiwgeF8zKTtcbiAgICAgICAgICAgIHhfMiA9IHN3WzBdO1xuICAgICAgICAgICAgeF8zID0gc3dbMV07XG4gICAgICAgICAgICBzdyA9IGNzd2FwKHN3YXAsIHpfMiwgel8zKTtcbiAgICAgICAgICAgIHpfMiA9IHN3WzBdO1xuICAgICAgICAgICAgel8zID0gc3dbMV07XG4gICAgICAgICAgICBzd2FwID0ga190O1xuICAgICAgICAgICAgY29uc3QgQSA9IHhfMiArIHpfMjtcbiAgICAgICAgICAgIGNvbnN0IEFBID0gbW9kUChBICogQSk7XG4gICAgICAgICAgICBjb25zdCBCID0geF8yIC0gel8yO1xuICAgICAgICAgICAgY29uc3QgQkIgPSBtb2RQKEIgKiBCKTtcbiAgICAgICAgICAgIGNvbnN0IEUgPSBBQSAtIEJCO1xuICAgICAgICAgICAgY29uc3QgQyA9IHhfMyArIHpfMztcbiAgICAgICAgICAgIGNvbnN0IEQgPSB4XzMgLSB6XzM7XG4gICAgICAgICAgICBjb25zdCBEQSA9IG1vZFAoRCAqIEEpO1xuICAgICAgICAgICAgY29uc3QgQ0IgPSBtb2RQKEMgKiBCKTtcbiAgICAgICAgICAgIGNvbnN0IGRhY2IgPSBEQSArIENCO1xuICAgICAgICAgICAgY29uc3QgZGFfY2IgPSBEQSAtIENCO1xuICAgICAgICAgICAgeF8zID0gbW9kUChkYWNiICogZGFjYik7XG4gICAgICAgICAgICB6XzMgPSBtb2RQKHhfMSAqIG1vZFAoZGFfY2IgKiBkYV9jYikpO1xuICAgICAgICAgICAgeF8yID0gbW9kUChBQSAqIEJCKTtcbiAgICAgICAgICAgIHpfMiA9IG1vZFAoRSAqIChBQSArIG1vZFAoYTI0ICogRSkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAoeF8yLCB4XzMpID0gY3N3YXAoc3dhcCwgeF8yLCB4XzMpXG4gICAgICAgIHN3ID0gY3N3YXAoc3dhcCwgeF8yLCB4XzMpO1xuICAgICAgICB4XzIgPSBzd1swXTtcbiAgICAgICAgeF8zID0gc3dbMV07XG4gICAgICAgIC8vICh6XzIsIHpfMykgPSBjc3dhcChzd2FwLCB6XzIsIHpfMylcbiAgICAgICAgc3cgPSBjc3dhcChzd2FwLCB6XzIsIHpfMyk7XG4gICAgICAgIHpfMiA9IHN3WzBdO1xuICAgICAgICB6XzMgPSBzd1sxXTtcbiAgICAgICAgLy8gel8yXihwIC0gMilcbiAgICAgICAgY29uc3QgejIgPSBwb3dQbWludXMyKHpfMik7XG4gICAgICAgIC8vIFJldHVybiB4XzIgKiAoel8yXihwIC0gMikpXG4gICAgICAgIHJldHVybiBtb2RQKHhfMiAqIHoyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlVUNvb3JkaW5hdGUodSkge1xuICAgICAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0xFKG1vZFAodSksIG1vbnRnb21lcnlCeXRlcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZVVDb29yZGluYXRlKHVFbmMpIHtcbiAgICAgICAgLy8gU2VjdGlvbiA1OiBXaGVuIHJlY2VpdmluZyBzdWNoIGFuIGFycmF5LCBpbXBsZW1lbnRhdGlvbnMgb2YgWDI1NTE5XG4gICAgICAgIC8vIE1VU1QgbWFzayB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgaW4gdGhlIGZpbmFsIGJ5dGUuXG4gICAgICAgIGNvbnN0IHUgPSBlbnN1cmVCeXRlcygndSBjb29yZGluYXRlJywgdUVuYywgbW9udGdvbWVyeUJ5dGVzKTtcbiAgICAgICAgaWYgKGZpZWxkTGVuID09PSAzMilcbiAgICAgICAgICAgIHVbMzFdICY9IDEyNzsgLy8gMGIwMTExXzExMTFcbiAgICAgICAgcmV0dXJuIGJ5dGVzVG9OdW1iZXJMRSh1KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlU2NhbGFyKG4pIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBlbnN1cmVCeXRlcygnc2NhbGFyJywgbik7XG4gICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiAhPT0gbW9udGdvbWVyeUJ5dGVzICYmIGxlbiAhPT0gZmllbGRMZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7bW9udGdvbWVyeUJ5dGVzfSBvciAke2ZpZWxkTGVufSBieXRlcywgZ290ICR7bGVufWApO1xuICAgICAgICByZXR1cm4gYnl0ZXNUb051bWJlckxFKGFkanVzdFNjYWxhckJ5dGVzKGJ5dGVzKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxhck11bHQoc2NhbGFyLCB1KSB7XG4gICAgICAgIGNvbnN0IHBvaW50VSA9IGRlY29kZVVDb29yZGluYXRlKHUpO1xuICAgICAgICBjb25zdCBfc2NhbGFyID0gZGVjb2RlU2NhbGFyKHNjYWxhcik7XG4gICAgICAgIGNvbnN0IHB1ID0gbW9udGdvbWVyeUxhZGRlcihwb2ludFUsIF9zY2FsYXIpO1xuICAgICAgICAvLyBUaGUgcmVzdWx0IHdhcyBub3QgY29udHJpYnV0b3J5XG4gICAgICAgIC8vIGh0dHBzOi8vY3IueXAudG8vZWNkaC5odG1sI3ZhbGlkYXRlXG4gICAgICAgIGlmIChwdSA9PT0gXzBuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByaXZhdGUgb3IgcHVibGljIGtleSByZWNlaXZlZCcpO1xuICAgICAgICByZXR1cm4gZW5jb2RlVUNvb3JkaW5hdGUocHUpO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyBwdWJsaWMga2V5IGZyb20gcHJpdmF0ZS4gQnkgZG9pbmcgc2NhbGFyIG11bHRpcGxpY2F0aW9uIG9mIGJhc2UgcG9pbnQuXG4gICAgY29uc3QgR3VCeXRlcyA9IGVuY29kZVVDb29yZGluYXRlKENVUlZFLkd1KTtcbiAgICBmdW5jdGlvbiBzY2FsYXJNdWx0QmFzZShzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxhck11bHQoc2NhbGFyLCBHdUJ5dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NhbGFyTXVsdCxcbiAgICAgICAgc2NhbGFyTXVsdEJhc2UsXG4gICAgICAgIGdldFNoYXJlZFNlY3JldDogKHByaXZhdGVLZXksIHB1YmxpY0tleSkgPT4gc2NhbGFyTXVsdChwcml2YXRlS2V5LCBwdWJsaWNLZXkpLFxuICAgICAgICBnZXRQdWJsaWNLZXk6IChwcml2YXRlS2V5KSA9PiBzY2FsYXJNdWx0QmFzZShwcml2YXRlS2V5KSxcbiAgICAgICAgdXRpbHM6IHsgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4gQ1VSVkUucmFuZG9tQnl0ZXMoQ1VSVkUubkJ5dGVMZW5ndGgpIH0sXG4gICAgICAgIEd1Qnl0ZXM6IEd1Qnl0ZXMsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vbnRnb21lcnkuanMubWFwIl0sIm5hbWVzIjpbIm1vZCIsInBvdyIsImJ5dGVzVG9OdW1iZXJMRSIsImVuc3VyZUJ5dGVzIiwibnVtYmVyVG9CeXRlc0xFIiwidmFsaWRhdGVPYmplY3QiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJ2YWxpZGF0ZU9wdHMiLCJjdXJ2ZSIsImEiLCJtb250Z29tZXJ5Qml0cyIsIm5CeXRlTGVuZ3RoIiwiYWRqdXN0U2NhbGFyQnl0ZXMiLCJkb21haW4iLCJwb3dQbWludXMyIiwiR3UiLCJPYmplY3QiLCJmcmVlemUiLCJtb250Z29tZXJ5IiwiY3VydmVEZWYiLCJDVVJWRSIsIlAiLCJtb2RQIiwibiIsIm1vbnRnb21lcnlCeXRlcyIsIk1hdGgiLCJjZWlsIiwiZmllbGRMZW4iLCJieXRlcyIsIngiLCJjc3dhcCIsInN3YXAiLCJ4XzIiLCJ4XzMiLCJkdW1teSIsImFzc2VydEZpZWxkRWxlbWVudCIsIkVycm9yIiwiYTI0IiwibW9udGdvbWVyeUxhZGRlciIsInBvaW50VSIsInNjYWxhciIsInUiLCJrIiwieF8xIiwiel8yIiwiel8zIiwic3ciLCJ0Iiwia190IiwiQSIsIkFBIiwiQiIsIkJCIiwiRSIsIkMiLCJEIiwiREEiLCJDQiIsImRhY2IiLCJkYV9jYiIsInoyIiwiZW5jb2RlVUNvb3JkaW5hdGUiLCJkZWNvZGVVQ29vcmRpbmF0ZSIsInVFbmMiLCJkZWNvZGVTY2FsYXIiLCJsZW4iLCJsZW5ndGgiLCJzY2FsYXJNdWx0IiwiX3NjYWxhciIsInB1IiwiR3VCeXRlcyIsInNjYWxhck11bHRCYXNlIiwiZ2V0U2hhcmVkU2VjcmV0IiwicHJpdmF0ZUtleSIsInB1YmxpY0tleSIsImdldFB1YmxpY0tleSIsInV0aWxzIiwicmFuZG9tUHJpdmF0ZUtleSIsInJhbmRvbUJ5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/@noble/curves/esm/abstract/montgomery.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/@noble/curves/esm/abstract/utils.js":
/*!***********************************************************!*\
  !*** ../node_modules/@noble/curves/esm/abstract/utils.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nfunction isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\nfunction abytes(item) {\n    if (!isBytes(item)) throw new Error(\"Uint8Array expected\");\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // Big Endian\n    return BigInt(hex === \"\" ? \"0\" : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    _A: 65,\n    _F: 70,\n    _a: 97,\n    _f: 102\n};\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, \"0\"));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n        try {\n            res = hexToBytes(hex);\n        } catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    } else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    } else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length) return false;\n    let diff = 0;\n    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */ function bitLen(n) {\n    let len;\n    for(len = 0; n > _0n; n >>= _1n, len += 1);\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function bitGet(n, pos) {\n    return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */ function bitSet(n, pos, value) {\n    return n | (value ? _1n : _0n) << BigInt(pos);\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const bitMask = (n)=>(_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data)=>new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr)=>Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\") throw new Error(\"hmacFn must be a function\");\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n())=>{\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([\n            0x00\n        ]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h(u8fr([\n            0x01\n        ]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error(\"drbg: tried 1000 values\");\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val)=>typeof val === \"bigint\",\n    function: (val)=>typeof val === \"function\",\n    boolean: (val)=>typeof val === \"boolean\",\n    string: (val)=>typeof val === \"string\",\n    stringOrUint8Array: (val)=>typeof val === \"string\" || isBytes(val),\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== \"function\") throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n} // validate type tests\n // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n // // Should fail type-check\n // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9FQUFvRSxHQUNwRSwwRUFBMEU7QUFDMUUsOERBQThEO0FBQzlELCtFQUErRTtBQUMvRSx1Q0FBdUM7QUFDdkMsTUFBTUEsTUFBTSxhQUFhLEdBQUdDLE9BQU87QUFDbkMsTUFBTUMsTUFBTSxhQUFhLEdBQUdELE9BQU87QUFDbkMsTUFBTUUsTUFBTSxhQUFhLEdBQUdGLE9BQU87QUFDNUIsU0FBU0csUUFBUUMsQ0FBQztJQUNyQixPQUFRQSxhQUFhQyxjQUNoQkQsS0FBSyxRQUFRLE9BQU9BLE1BQU0sWUFBWUEsRUFBRUUsV0FBVyxDQUFDQyxJQUFJLEtBQUs7QUFDdEU7QUFDTyxTQUFTQyxPQUFPQyxJQUFJO0lBQ3ZCLElBQUksQ0FBQ04sUUFBUU0sT0FDVCxNQUFNLElBQUlDLE1BQU07QUFDeEI7QUFDQSx3REFBd0Q7QUFDeEQsTUFBTUMsUUFBUSxhQUFhLEdBQUdDLE1BQU1DLElBQUksQ0FBQztJQUFFQyxRQUFRO0FBQUksR0FBRyxDQUFDQyxHQUFHQyxJQUFNQSxFQUFFQyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUc7QUFDL0Y7O0NBRUMsR0FDTSxTQUFTQyxXQUFXQyxLQUFLO0lBQzVCWixPQUFPWTtJQUNQLG9DQUFvQztJQUNwQyxJQUFJQyxNQUFNO0lBQ1YsSUFBSyxJQUFJTCxJQUFJLEdBQUdBLElBQUlJLE1BQU1OLE1BQU0sRUFBRUUsSUFBSztRQUNuQ0ssT0FBT1YsS0FBSyxDQUFDUyxLQUFLLENBQUNKLEVBQUUsQ0FBQztJQUMxQjtJQUNBLE9BQU9LO0FBQ1g7QUFDTyxTQUFTQyxvQkFBb0JDLEdBQUc7SUFDbkMsTUFBTUYsTUFBTUUsSUFBSU4sUUFBUSxDQUFDO0lBQ3pCLE9BQU9JLElBQUlQLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFTyxJQUFJLENBQUMsR0FBR0E7QUFDeEM7QUFDTyxTQUFTRyxZQUFZSCxHQUFHO0lBQzNCLElBQUksT0FBT0EsUUFBUSxVQUNmLE1BQU0sSUFBSVgsTUFBTSw4QkFBOEIsT0FBT1c7SUFDekQsYUFBYTtJQUNiLE9BQU9yQixPQUFPcUIsUUFBUSxLQUFLLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLElBQUksQ0FBQztBQUMvQztBQUNBLGlFQUFpRTtBQUNqRSxNQUFNSSxTQUFTO0lBQUVDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0FBQUk7QUFDakUsU0FBU0MsY0FBY0MsSUFBSTtJQUN2QixJQUFJQSxRQUFRUixPQUFPQyxFQUFFLElBQUlPLFFBQVFSLE9BQU9FLEVBQUUsRUFDdEMsT0FBT00sT0FBT1IsT0FBT0MsRUFBRTtJQUMzQixJQUFJTyxRQUFRUixPQUFPRyxFQUFFLElBQUlLLFFBQVFSLE9BQU9JLEVBQUUsRUFDdEMsT0FBT0ksT0FBUVIsQ0FBQUEsT0FBT0csRUFBRSxHQUFHLEVBQUM7SUFDaEMsSUFBSUssUUFBUVIsT0FBT0ssRUFBRSxJQUFJRyxRQUFRUixPQUFPTSxFQUFFLEVBQ3RDLE9BQU9FLE9BQVFSLENBQUFBLE9BQU9LLEVBQUUsR0FBRyxFQUFDO0lBQ2hDO0FBQ0o7QUFDQTs7Q0FFQyxHQUNNLFNBQVNJLFdBQVdiLEdBQUc7SUFDMUIsSUFBSSxPQUFPQSxRQUFRLFVBQ2YsTUFBTSxJQUFJWCxNQUFNLDhCQUE4QixPQUFPVztJQUN6RCxNQUFNYyxLQUFLZCxJQUFJUCxNQUFNO0lBQ3JCLE1BQU1zQixLQUFLRCxLQUFLO0lBQ2hCLElBQUlBLEtBQUssR0FDTCxNQUFNLElBQUl6QixNQUFNLDREQUE0RHlCO0lBQ2hGLE1BQU1FLFFBQVEsSUFBSWhDLFdBQVcrQjtJQUM3QixJQUFLLElBQUlFLEtBQUssR0FBR0MsS0FBSyxHQUFHRCxLQUFLRixJQUFJRSxNQUFNQyxNQUFNLEVBQUc7UUFDN0MsTUFBTUMsS0FBS1IsY0FBY1gsSUFBSW9CLFVBQVUsQ0FBQ0Y7UUFDeEMsTUFBTUcsS0FBS1YsY0FBY1gsSUFBSW9CLFVBQVUsQ0FBQ0YsS0FBSztRQUM3QyxJQUFJQyxPQUFPRyxhQUFhRCxPQUFPQyxXQUFXO1lBQ3RDLE1BQU1WLE9BQU9aLEdBQUcsQ0FBQ2tCLEdBQUcsR0FBR2xCLEdBQUcsQ0FBQ2tCLEtBQUssRUFBRTtZQUNsQyxNQUFNLElBQUk3QixNQUFNLGlEQUFpRHVCLE9BQU8sZ0JBQWdCTTtRQUM1RjtRQUNBRixLQUFLLENBQUNDLEdBQUcsR0FBR0UsS0FBSyxLQUFLRTtJQUMxQjtJQUNBLE9BQU9MO0FBQ1g7QUFDQSxvQ0FBb0M7QUFDN0IsU0FBU08sZ0JBQWdCeEIsS0FBSztJQUNqQyxPQUFPSSxZQUFZTCxXQUFXQztBQUNsQztBQUNPLFNBQVN5QixnQkFBZ0J6QixLQUFLO0lBQ2pDWixPQUFPWTtJQUNQLE9BQU9JLFlBQVlMLFdBQVdkLFdBQVdRLElBQUksQ0FBQ08sT0FBTzBCLE9BQU87QUFDaEU7QUFDTyxTQUFTQyxnQkFBZ0JDLENBQUMsRUFBRUMsR0FBRztJQUNsQyxPQUFPZixXQUFXYyxFQUFFL0IsUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQytCLE1BQU0sR0FBRztBQUN2RDtBQUNPLFNBQVNDLGdCQUFnQkYsQ0FBQyxFQUFFQyxHQUFHO0lBQ2xDLE9BQU9GLGdCQUFnQkMsR0FBR0MsS0FBS0gsT0FBTztBQUMxQztBQUNBLHdCQUF3QjtBQUNqQixTQUFTSyxtQkFBbUJILENBQUM7SUFDaEMsT0FBT2QsV0FBV1osb0JBQW9CMEI7QUFDMUM7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNNLFNBQVNJLFlBQVlDLEtBQUssRUFBRWhDLEdBQUcsRUFBRWlDLGNBQWM7SUFDbEQsSUFBSUM7SUFDSixJQUFJLE9BQU9sQyxRQUFRLFVBQVU7UUFDekIsSUFBSTtZQUNBa0MsTUFBTXJCLFdBQVdiO1FBQ3JCLEVBQ0EsT0FBT21DLEdBQUc7WUFDTixNQUFNLElBQUk5QyxNQUFNLENBQUMsRUFBRTJDLE1BQU0sZ0NBQWdDLEVBQUVoQyxJQUFJLFVBQVUsRUFBRW1DLEVBQUUsQ0FBQztRQUNsRjtJQUNKLE9BQ0ssSUFBSXJELFFBQVFrQixNQUFNO1FBQ25CLG1FQUFtRTtRQUNuRSxzRUFBc0U7UUFDdEVrQyxNQUFNbEQsV0FBV1EsSUFBSSxDQUFDUTtJQUMxQixPQUNLO1FBQ0QsTUFBTSxJQUFJWCxNQUFNLENBQUMsRUFBRTJDLE1BQU0saUNBQWlDLENBQUM7SUFDL0Q7SUFDQSxNQUFNSixNQUFNTSxJQUFJekMsTUFBTTtJQUN0QixJQUFJLE9BQU93QyxtQkFBbUIsWUFBWUwsUUFBUUssZ0JBQzlDLE1BQU0sSUFBSTVDLE1BQU0sQ0FBQyxFQUFFMkMsTUFBTSxVQUFVLEVBQUVDLGVBQWUsWUFBWSxFQUFFTCxJQUFJLENBQUM7SUFDM0UsT0FBT007QUFDWDtBQUNBOztDQUVDLEdBQ00sU0FBU0UsWUFBWSxHQUFHQyxNQUFNO0lBQ2pDLElBQUlDLE1BQU07SUFDVixJQUFLLElBQUkzQyxJQUFJLEdBQUdBLElBQUkwQyxPQUFPNUMsTUFBTSxFQUFFRSxJQUFLO1FBQ3BDLE1BQU1aLElBQUlzRCxNQUFNLENBQUMxQyxFQUFFO1FBQ25CUixPQUFPSjtRQUNQdUQsT0FBT3ZELEVBQUVVLE1BQU07SUFDbkI7SUFDQSxNQUFNeUMsTUFBTSxJQUFJbEQsV0FBV3NEO0lBQzNCLElBQUssSUFBSTNDLElBQUksR0FBRzRDLE1BQU0sR0FBRzVDLElBQUkwQyxPQUFPNUMsTUFBTSxFQUFFRSxJQUFLO1FBQzdDLE1BQU1aLElBQUlzRCxNQUFNLENBQUMxQyxFQUFFO1FBQ25CdUMsSUFBSU0sR0FBRyxDQUFDekQsR0FBR3dEO1FBQ1hBLE9BQU94RCxFQUFFVSxNQUFNO0lBQ25CO0lBQ0EsT0FBT3lDO0FBQ1g7QUFDQSwwQ0FBMEM7QUFDbkMsU0FBU08sV0FBVzFELENBQUMsRUFBRTJELENBQUM7SUFDM0IsSUFBSTNELEVBQUVVLE1BQU0sS0FBS2lELEVBQUVqRCxNQUFNLEVBQ3JCLE9BQU87SUFDWCxJQUFJa0QsT0FBTztJQUNYLElBQUssSUFBSWhELElBQUksR0FBR0EsSUFBSVosRUFBRVUsTUFBTSxFQUFFRSxJQUMxQmdELFFBQVE1RCxDQUFDLENBQUNZLEVBQUUsR0FBRytDLENBQUMsQ0FBQy9DLEVBQUU7SUFDdkIsT0FBT2dELFNBQVM7QUFDcEI7QUFDQTs7Q0FFQyxHQUNNLFNBQVNDLFlBQVlDLEdBQUc7SUFDM0IsSUFBSSxPQUFPQSxRQUFRLFVBQ2YsTUFBTSxJQUFJeEQsTUFBTSxDQUFDLGlDQUFpQyxFQUFFLE9BQU93RCxJQUFJLENBQUM7SUFDcEUsT0FBTyxJQUFJN0QsV0FBVyxJQUFJOEQsY0FBY0MsTUFBTSxDQUFDRixPQUFPLDRCQUE0QjtBQUN0RjtBQUNBLGlCQUFpQjtBQUNqQjs7O0NBR0MsR0FDTSxTQUFTRyxPQUFPckIsQ0FBQztJQUNwQixJQUFJQztJQUNKLElBQUtBLE1BQU0sR0FBR0QsSUFBSWpELEtBQUtpRCxNQUFNL0MsS0FBS2dELE9BQU87SUFFekMsT0FBT0E7QUFDWDtBQUNBOzs7O0NBSUMsR0FDTSxTQUFTcUIsT0FBT3RCLENBQUMsRUFBRXVCLEdBQUc7SUFDekIsT0FBTyxLQUFNdkUsT0FBT3VFLE9BQVF0RTtBQUNoQztBQUNBOztDQUVDLEdBQ00sU0FBU3VFLE9BQU94QixDQUFDLEVBQUV1QixHQUFHLEVBQUVFLEtBQUs7SUFDaEMsT0FBT3pCLElBQUssQ0FBQ3lCLFFBQVF4RSxNQUFNRixHQUFFLEtBQU1DLE9BQU91RTtBQUM5QztBQUNBOzs7Q0FHQyxHQUNNLE1BQU1HLFVBQVUsQ0FBQzFCLElBQU0sQ0FBQzlDLE9BQU9GLE9BQU9nRCxJQUFJLEVBQUMsSUFBSy9DLElBQUk7QUFDM0QsT0FBTztBQUNQLE1BQU0wRSxNQUFNLENBQUNDLE9BQVMsSUFBSXZFLFdBQVd1RSxPQUFPLHFCQUFxQjtBQUNqRSxNQUFNQyxPQUFPLENBQUNDLE1BQVF6RSxXQUFXUSxJQUFJLENBQUNpRSxNQUFNLG1CQUFtQjtBQUMvRDs7Ozs7O0NBTUMsR0FDTSxTQUFTQyxlQUFlQyxPQUFPLEVBQUVDLFFBQVEsRUFBRUMsTUFBTTtJQUNwRCxJQUFJLE9BQU9GLFlBQVksWUFBWUEsVUFBVSxHQUN6QyxNQUFNLElBQUl0RSxNQUFNO0lBQ3BCLElBQUksT0FBT3VFLGFBQWEsWUFBWUEsV0FBVyxHQUMzQyxNQUFNLElBQUl2RSxNQUFNO0lBQ3BCLElBQUksT0FBT3dFLFdBQVcsWUFDbEIsTUFBTSxJQUFJeEUsTUFBTTtJQUNwQixnREFBZ0Q7SUFDaEQsSUFBSXlFLElBQUlSLElBQUlLLFVBQVUscUVBQXFFO0lBQzNGLElBQUlJLElBQUlULElBQUlLLFVBQVUscUVBQXFFO0lBQzNGLElBQUloRSxJQUFJLEdBQUcsZ0RBQWdEO0lBQzNELE1BQU1xRSxRQUFRO1FBQ1ZGLEVBQUVHLElBQUksQ0FBQztRQUNQRixFQUFFRSxJQUFJLENBQUM7UUFDUHRFLElBQUk7SUFDUjtJQUNBLE1BQU11RSxJQUFJLENBQUMsR0FBR3hCLElBQU1tQixPQUFPRSxHQUFHRCxNQUFNcEIsSUFBSSx3QkFBd0I7SUFDaEUsTUFBTXlCLFNBQVMsQ0FBQ0MsT0FBT2QsS0FBSztRQUN4Qix5Q0FBeUM7UUFDekNTLElBQUlHLEVBQUVWLEtBQUs7WUFBQztTQUFLLEdBQUdZLE9BQU8sbUNBQW1DO1FBQzlETixJQUFJSSxLQUFLLG1CQUFtQjtRQUM1QixJQUFJRSxLQUFLM0UsTUFBTSxLQUFLLEdBQ2hCO1FBQ0pzRSxJQUFJRyxFQUFFVixLQUFLO1lBQUM7U0FBSyxHQUFHWSxPQUFPLG1DQUFtQztRQUM5RE4sSUFBSUksS0FBSyxtQkFBbUI7SUFDaEM7SUFDQSxNQUFNRyxNQUFNO1FBQ1IsZ0NBQWdDO1FBQ2hDLElBQUkxRSxPQUFPLE1BQ1AsTUFBTSxJQUFJTixNQUFNO1FBQ3BCLElBQUl1QyxNQUFNO1FBQ1YsTUFBTTBDLE1BQU0sRUFBRTtRQUNkLE1BQU8xQyxNQUFNZ0MsU0FBVTtZQUNuQkUsSUFBSUk7WUFDSixNQUFNSyxLQUFLVCxFQUFFVSxLQUFLO1lBQ2xCRixJQUFJRyxJQUFJLENBQUNGO1lBQ1QzQyxPQUFPa0MsRUFBRXJFLE1BQU07UUFDbkI7UUFDQSxPQUFPMkMsZUFBZWtDO0lBQzFCO0lBQ0EsTUFBTUksV0FBVyxDQUFDTixNQUFNTztRQUNwQlg7UUFDQUcsT0FBT0MsT0FBTyxZQUFZO1FBQzFCLElBQUlsQyxNQUFNWixXQUFXLHVDQUF1QztRQUM1RCxNQUFPLENBQUVZLENBQUFBLE1BQU15QyxLQUFLTixNQUFLLEVBQ3JCRjtRQUNKSDtRQUNBLE9BQU85QjtJQUNYO0lBQ0EsT0FBT3dDO0FBQ1g7QUFDQSwrQkFBK0I7QUFDL0IsTUFBTUUsZUFBZTtJQUNqQkMsUUFBUSxDQUFDQyxNQUFRLE9BQU9BLFFBQVE7SUFDaENDLFVBQVUsQ0FBQ0QsTUFBUSxPQUFPQSxRQUFRO0lBQ2xDRSxTQUFTLENBQUNGLE1BQVEsT0FBT0EsUUFBUTtJQUNqQ0csUUFBUSxDQUFDSCxNQUFRLE9BQU9BLFFBQVE7SUFDaENJLG9CQUFvQixDQUFDSixNQUFRLE9BQU9BLFFBQVEsWUFBWWhHLFFBQVFnRztJQUNoRUssZUFBZSxDQUFDTCxNQUFRTSxPQUFPRCxhQUFhLENBQUNMO0lBQzdDOUQsT0FBTyxDQUFDOEQsTUFBUXZGLE1BQU04RixPQUFPLENBQUNQO0lBQzlCUSxPQUFPLENBQUNSLEtBQUtTLFNBQVdBLE9BQU9DLEVBQUUsQ0FBQ0MsT0FBTyxDQUFDWDtJQUMxQ1ksTUFBTSxDQUFDWixNQUFRLE9BQU9BLFFBQVEsY0FBY00sT0FBT0QsYUFBYSxDQUFDTCxJQUFJYSxTQUFTO0FBQ2xGO0FBQ0Esd0VBQXdFO0FBQ2pFLFNBQVNDLGVBQWVMLE1BQU0sRUFBRU0sVUFBVSxFQUFFQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQ2pFLE1BQU1DLGFBQWEsQ0FBQ0MsV0FBV0MsTUFBTUM7UUFDakMsTUFBTUMsV0FBV3ZCLFlBQVksQ0FBQ3FCLEtBQUs7UUFDbkMsSUFBSSxPQUFPRSxhQUFhLFlBQ3BCLE1BQU0sSUFBSTlHLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRTRHLEtBQUssb0JBQW9CLENBQUM7UUFDcEUsTUFBTW5CLE1BQU1TLE1BQU0sQ0FBQ1MsVUFBVTtRQUM3QixJQUFJRSxjQUFjcEIsUUFBUXhELFdBQ3RCO1FBQ0osSUFBSSxDQUFDNkUsU0FBU3JCLEtBQUtTLFNBQVM7WUFDeEIsTUFBTSxJQUFJbEcsTUFBTSxDQUFDLGNBQWMsRUFBRStHLE9BQU9KLFdBQVcsQ0FBQyxFQUFFbEIsSUFBSSxFQUFFLEVBQUUsT0FBT0EsSUFBSSxZQUFZLEVBQUVtQixLQUFLLENBQUM7UUFDakc7SUFDSjtJQUNBLEtBQUssTUFBTSxDQUFDRCxXQUFXQyxLQUFLLElBQUlJLE9BQU9DLE9BQU8sQ0FBQ1QsWUFDM0NFLFdBQVdDLFdBQVdDLE1BQU07SUFDaEMsS0FBSyxNQUFNLENBQUNELFdBQVdDLEtBQUssSUFBSUksT0FBT0MsT0FBTyxDQUFDUixlQUMzQ0MsV0FBV0MsV0FBV0MsTUFBTTtJQUNoQyxPQUFPVjtBQUNYLEVBQ0Esc0JBQXNCO0NBQ3RCLHVFQUF1RTtDQUN2RSxnRkFBZ0Y7Q0FDaEYsNEJBQTRCO0NBQzVCLDJEQUEyRDtDQUMzRCxxRUFBcUU7Q0FDckUsK0RBQStEO0NBQy9ELDREQUE0RDtDQUM1RCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzPzEyNzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKTtcbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYWJ5dGVzKGl0ZW0pIHtcbiAgICBpZiAoIWlzQnl0ZXMoaXRlbSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xufVxuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBCaWcgRW5kaWFuXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgX0E6IDY1LCBfRjogNzAsIF9hOiA5NywgX2Y6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl8wICYmIGNoYXIgPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2hhciAtIGFzY2lpcy5fMDtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX0EgJiYgY2hhciA8PSBhc2NpaXMuX0YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX2EgJiYgY2hhciA8PSBhc2NpaXMuX2YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fYSAtIDEwKTtcbiAgICByZXR1cm47XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJCRShieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KGJ5dGVzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzTEUobiwgbGVuKSB7XG4gICAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pLnJldmVyc2UoKTtcbn1cbi8vIFVucGFkZGVkLCByYXJlbHkgdXNlZFxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvVmFyQnl0ZXNCRShuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobnVtYmVyVG9IZXhVbnBhZGRlZChuKSk7XG59XG4vKipcbiAqIFRha2VzIGhleCBzdHJpbmcgb3IgVWludDhBcnJheSwgY29udmVydHMgdG8gVWludDhBcnJheS5cbiAqIFZhbGlkYXRlcyBvdXRwdXQgbGVuZ3RoLlxuICogV2lsbCB0aHJvdyBlcnJvciBmb3Igb3RoZXIgdHlwZXMuXG4gKiBAcGFyYW0gdGl0bGUgZGVzY3JpcHRpdmUgdGl0bGUgZm9yIGFuIGVycm9yIGUuZy4gJ3ByaXZhdGUga2V5J1xuICogQHBhcmFtIGhleCBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlcbiAqIEBwYXJhbSBleHBlY3RlZExlbmd0aCBvcHRpb25hbCwgd2lsbCBjb21wYXJlIHRvIHJlc3VsdCBhcnJheSdzIGxlbmd0aFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUJ5dGVzKHRpdGxlLCBoZXgsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgbGV0IHJlcztcbiAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGhleFRvQnl0ZXMoaGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIHZhbGlkIGhleCBzdHJpbmcsIGdvdCBcIiR7aGV4fVwiLiBDYXVzZTogJHtlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQnl0ZXMoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBleHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlcywgZ290ICR7bGVufWApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgYWJ5dGVzKGEpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBDb21wYXJlcyAyIHU4YS1zIGluIGtpbmRhIGNvbnN0YW50IHRpbWVcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRpZmYgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgZGlmZiB8PSBhW2ldIF4gYltpXTtcbiAgICByZXR1cm4gZGlmZiA9PT0gMDtcbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLy8gQml0IG9wZXJhdGlvbnNcbi8qKlxuICogQ2FsY3VsYXRlcyBhbW91bnQgb2YgYml0cyBpbiBhIGJpZ2ludC5cbiAqIFNhbWUgYXMgYG4udG9TdHJpbmcoMikubGVuZ3RoYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0TGVuKG4pIHtcbiAgICBsZXQgbGVuO1xuICAgIGZvciAobGVuID0gMDsgbiA+IF8wbjsgbiA+Pj0gXzFuLCBsZW4gKz0gMSlcbiAgICAgICAgO1xuICAgIHJldHVybiBsZW47XG59XG4vKipcbiAqIEdldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqIE5PVEU6IGZpcnN0IGJpdCBwb3NpdGlvbiBpcyAwIChzYW1lIGFzIGFycmF5cylcbiAqIFNhbWUgYXMgYCEhK0FycmF5LmZyb20obi50b1N0cmluZygyKSkucmV2ZXJzZSgpW3Bvc11gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRHZXQobiwgcG9zKSB7XG4gICAgcmV0dXJuIChuID4+IEJpZ0ludChwb3MpKSAmIF8xbjtcbn1cbi8qKlxuICogU2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0U2V0KG4sIHBvcywgdmFsdWUpIHtcbiAgICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIG1hc2sgZm9yIE4gYml0cy4gTm90IHVzaW5nICoqIG9wZXJhdG9yIHdpdGggYmlnaW50cyBiZWNhdXNlIG9mIG9sZCBlbmdpbmVzLlxuICogU2FtZSBhcyBCaWdJbnQoYDBiJHtBcnJheShpKS5maWxsKCcxJykuam9pbignJyl9YClcbiAqL1xuZXhwb3J0IGNvbnN0IGJpdE1hc2sgPSAobikgPT4gKF8ybiA8PCBCaWdJbnQobiAtIDEpKSAtIF8xbjtcbi8vIERSQkdcbmNvbnN0IHU4biA9IChkYXRhKSA9PiBuZXcgVWludDhBcnJheShkYXRhKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG5jb25zdCB1OGZyID0gKGFycikgPT4gVWludDhBcnJheS5mcm9tKGFycik7IC8vIGFub3RoZXIgc2hvcnRjdXRcbi8qKlxuICogTWluaW1hbCBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRFJCRzxLZXk+KDMyLCAzMiwgaG1hYyk7XG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSG1hY0RyYmcoaGFzaExlbiwgcUJ5dGVMZW4sIGhtYWNGbikge1xuICAgIGlmICh0eXBlb2YgaGFzaExlbiAhPT0gJ251bWJlcicgfHwgaGFzaExlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBxQnl0ZUxlbiAhPT0gJ251bWJlcicgfHwgcUJ5dGVMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3FCeXRlTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIGhtYWNGbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdobWFjRm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgLy8gU3RlcCBCLCBTdGVwIEM6IHNldCBoYXNoTGVuIHRvIDgqY2VpbChobGVuLzgpXG4gICAgbGV0IHYgPSB1OG4oaGFzaExlbik7IC8vIE1pbmltYWwgbm9uLWZ1bGwtc3BlYyBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICAgIGxldCBrID0gdThuKGhhc2hMZW4pOyAvLyBTdGVwcyBCIGFuZCBDIG9mIFJGQzY5NzkgMy4yOiBzZXQgaGFzaExlbiwgaW4gb3VyIGNhc2UgYWx3YXlzIHNhbWVcbiAgICBsZXQgaSA9IDA7IC8vIEl0ZXJhdGlvbnMgY291bnRlciwgd2lsbCB0aHJvdyB3aGVuIG92ZXIgMTAwMFxuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICB2LmZpbGwoMSk7XG4gICAgICAgIGsuZmlsbCgwKTtcbiAgICAgICAgaSA9IDA7XG4gICAgfTtcbiAgICBjb25zdCBoID0gKC4uLmIpID0+IGhtYWNGbihrLCB2LCAuLi5iKTsgLy8gaG1hYyhrKSh2LCAuLi52YWx1ZXMpXG4gICAgY29uc3QgcmVzZWVkID0gKHNlZWQgPSB1OG4oKSkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgcmVzZWVkKCkgZnVuY3Rpb24uIFN0ZXBzIEQtR1xuICAgICAgICBrID0gaCh1OGZyKFsweDAwXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMCB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgayA9IGgodThmcihbMHgwMV0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDEgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgIH07XG4gICAgY29uc3QgZ2VuID0gKCkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgZ2VuZXJhdGUoKSBmdW5jdGlvblxuICAgICAgICBpZiAoaSsrID49IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RyYmc6IHRyaWVkIDEwMDAgdmFsdWVzJyk7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGxlbiA8IHFCeXRlTGVuKSB7XG4gICAgICAgICAgICB2ID0gaCgpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSB2LnNsaWNlKCk7XG4gICAgICAgICAgICBvdXQucHVzaChzbCk7XG4gICAgICAgICAgICBsZW4gKz0gdi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKC4uLm91dCk7XG4gICAgfTtcbiAgICBjb25zdCBnZW5VbnRpbCA9IChzZWVkLCBwcmVkKSA9PiB7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJlc2VlZChzZWVkKTsgLy8gU3RlcHMgRC1HXG4gICAgICAgIGxldCByZXMgPSB1bmRlZmluZWQ7IC8vIFN0ZXAgSDogZ3JpbmQgdW50aWwgayBpcyBpbiBbMS4ubi0xXVxuICAgICAgICB3aGlsZSAoIShyZXMgPSBwcmVkKGdlbigpKSkpXG4gICAgICAgICAgICByZXNlZWQoKTtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIHJldHVybiBnZW5VbnRpbDtcbn1cbi8vIFZhbGlkYXRpbmcgY3VydmVzIGFuZCBmaWVsZHNcbmNvbnN0IHZhbGlkYXRvckZucyA9IHtcbiAgICBiaWdpbnQ6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnLFxuICAgIGZ1bmN0aW9uOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuICAgIGJvb2xlYW46ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdib29sZWFuJyxcbiAgICBzdHJpbmc6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnLFxuICAgIHN0cmluZ09yVWludDhBcnJheTogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgaXNCeXRlcyh2YWwpLFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCB2YWxpZGF0b3JzLCBvcHRWYWxpZGF0b3JzID0ge30pIHtcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja1ZhbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgXCIke3R5cGV9XCIsIGV4cGVjdGVkIGZ1bmN0aW9uYCk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbSAke1N0cmluZyhmaWVsZE5hbWUpfT0ke3ZhbH0gKCR7dHlwZW9mIHZhbH0pLCBleHBlY3RlZCAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiXzBuIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwiaXNCeXRlcyIsImEiLCJVaW50OEFycmF5IiwiY29uc3RydWN0b3IiLCJuYW1lIiwiYWJ5dGVzIiwiaXRlbSIsIkVycm9yIiwiaGV4ZXMiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaSIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJieXRlc1RvSGV4IiwiYnl0ZXMiLCJoZXgiLCJudW1iZXJUb0hleFVucGFkZGVkIiwibnVtIiwiaGV4VG9OdW1iZXIiLCJhc2NpaXMiLCJfMCIsIl85IiwiX0EiLCJfRiIsIl9hIiwiX2YiLCJhc2NpaVRvQmFzZTE2IiwiY2hhciIsImhleFRvQnl0ZXMiLCJobCIsImFsIiwiYXJyYXkiLCJhaSIsImhpIiwibjEiLCJjaGFyQ29kZUF0IiwibjIiLCJ1bmRlZmluZWQiLCJieXRlc1RvTnVtYmVyQkUiLCJieXRlc1RvTnVtYmVyTEUiLCJyZXZlcnNlIiwibnVtYmVyVG9CeXRlc0JFIiwibiIsImxlbiIsIm51bWJlclRvQnl0ZXNMRSIsIm51bWJlclRvVmFyQnl0ZXNCRSIsImVuc3VyZUJ5dGVzIiwidGl0bGUiLCJleHBlY3RlZExlbmd0aCIsInJlcyIsImUiLCJjb25jYXRCeXRlcyIsImFycmF5cyIsInN1bSIsInBhZCIsInNldCIsImVxdWFsQnl0ZXMiLCJiIiwiZGlmZiIsInV0ZjhUb0J5dGVzIiwic3RyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJiaXRMZW4iLCJiaXRHZXQiLCJwb3MiLCJiaXRTZXQiLCJ2YWx1ZSIsImJpdE1hc2siLCJ1OG4iLCJkYXRhIiwidThmciIsImFyciIsImNyZWF0ZUhtYWNEcmJnIiwiaGFzaExlbiIsInFCeXRlTGVuIiwiaG1hY0ZuIiwidiIsImsiLCJyZXNldCIsImZpbGwiLCJoIiwicmVzZWVkIiwic2VlZCIsImdlbiIsIm91dCIsInNsIiwic2xpY2UiLCJwdXNoIiwiZ2VuVW50aWwiLCJwcmVkIiwidmFsaWRhdG9yRm5zIiwiYmlnaW50IiwidmFsIiwiZnVuY3Rpb24iLCJib29sZWFuIiwic3RyaW5nIiwic3RyaW5nT3JVaW50OEFycmF5IiwiaXNTYWZlSW50ZWdlciIsIk51bWJlciIsImlzQXJyYXkiLCJmaWVsZCIsIm9iamVjdCIsIkZwIiwiaXNWYWxpZCIsImhhc2giLCJvdXRwdXRMZW4iLCJ2YWxpZGF0ZU9iamVjdCIsInZhbGlkYXRvcnMiLCJvcHRWYWxpZGF0b3JzIiwiY2hlY2tGaWVsZCIsImZpZWxkTmFtZSIsInR5cGUiLCJpc09wdGlvbmFsIiwiY2hlY2tWYWwiLCJTdHJpbmciLCJPYmplY3QiLCJlbnRyaWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/@noble/curves/esm/abstract/utils.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Short Weierstrass curve. The formula is: y¬≤ = x¬≥ + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: \"field\",\n        b: \"field\"\n    }, {\n        allowedPrivateKeyLengths: \"array\",\n        wrapPrivateKey: \"boolean\",\n        isTorsionFree: \"function\",\n        clearCofactor: \"function\",\n        allowInfinityPoint: \"boolean\",\n        fromBytes: \"function\",\n        toBytes: \"function\"\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error(\"Endomorphism can only be defined for Koblitz curves that have a=0\");\n        }\n        if (typeof endo !== \"object\" || typeof endo.beta !== \"bigint\" || typeof endo.splitScalar !== \"function\") {\n            throw new Error(\"Expected endomorphism with beta: bigint and splitScalar: function\");\n        }\n    }\n    return Object.freeze({\n        ...opts\n    });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = \"\"){\n            super(m);\n        }\n    },\n    _parseInt (data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02) throw new E(\"Invalid signature integer tag\");\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len) throw new E(\"Invalid signature integer: wrong length\");\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 128) throw new E(\"Invalid signature integer: negative\");\n        if (res[0] === 0x00 && !(res[1] & 128)) throw new E(\"Invalid signature integer: unnecessary leading zero\");\n        return {\n            d: b2n(res),\n            l: data.subarray(len + 2)\n        }; // d is data, l is left\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === \"string\" ? h2b(hex) : hex;\n        _utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes(data);\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30) throw new E(\"Invalid signature tag\");\n        if (data[1] !== l - 2) throw new E(\"Invalid signature: incorrect length\");\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length) throw new E(\"Invalid signature: left bytes after parsing\");\n        return {\n            r,\n            s\n        };\n    },\n    hexFromSig (sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s)=>Number.parseInt(s[0], 16) & 8 ? \"00\" + s : s;\n        const h = (num)=>{\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{\n        const a = point.toAffine();\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([\n            0x04\n        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n    const fromBytes = CURVE.fromBytes || ((bytes)=>{\n        // const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n            x,\n            y\n        };\n    });\n    /**\n     * y¬≤ = x¬≥ + ax + b: Short weierstrass curve formula\n     * @returns y¬≤\n     */ function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error(\"bad generator point: equation left != right\");\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === \"bigint\" && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num)) throw new Error(\"Expected valid bigint: 0 < bigint < curve.n\");\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== \"bigint\") {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(key)) key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== \"string\" || !lengths.includes(key.length)) throw new Error(\"Invalid key\");\n            key = key.padStart(nByteLength * 2, \"0\");\n        }\n        let num;\n        try {\n            num = typeof key === \"bigint\" ? key : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"private key\", key, nByteLength));\n        } catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey) num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ProjectivePoint expected\");\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ‚àã (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        constructor(px, py, pz){\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px)) throw new Error(\"x required\");\n            if (py == null || !Fp.isValid(py)) throw new Error(\"y required\");\n            if (pz == null || !Fp.isValid(pz)) throw new Error(\"z required\");\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"invalid affine point\");\n            if (p instanceof Point) throw new Error(\"projective point not allowed\");\n            const is0 = (i)=>Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */ static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p)=>p.pz));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */ static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"pointHex\", hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;\n                throw new Error(\"bad point: ZERO\");\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"bad point: x or y not FE\");\n            const left = Fp.sqr(y); // y¬≤\n            const right = weierstrassEquation(x); // x¬≥ + ax + b\n            if (!Fp.eql(left, right)) throw new Error(\"bad point: equation left != right\");\n            if (!this.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd) return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */ equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */ negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp)=>{\n                const toInv = Fp.invertBatch(comp.map((p)=>p.pz));\n                return comp.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n) return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n) return this;\n            const { endo } = CURVE;\n            if (!endo) return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while(k1 > _0n || k2 > _0n){\n                if (k1 & _1n) k1p = k1p.add(d);\n                if (k2 & _1n) k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg) k1p = k1p.negate();\n            if (k2neg) k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            } else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */ multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ‚àã (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0) return {\n                x: Fp.ZERO,\n                y: Fp.ZERO\n            };\n            if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\");\n            return {\n                x: ax,\n                y: ay\n            };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n) return true; // No subgroups, always torsion-free\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: \"hash\",\n        hmac: \"function\",\n        randomBytes: \"function\"\n    }, {\n        bits2int: \"function\",\n        bits2int_modN: \"function\",\n        lowS: \"boolean\"\n    });\n    return Object.freeze({\n        lowS: true,\n        ...opts\n    });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({\n        ...CURVE,\n        toBytes (_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([\n                    point.hasEvenY() ? 0x02 : 0x03\n                ]), x);\n            } else {\n                return cat(Uint8Array.from([\n                    0x04\n                ]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes (bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x)) throw new Error(\"Point is not on curve\");\n                const y2 = weierstrassEquation(x); // y¬≤ = x¬≥ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y¬≤ ^ (p+1)/4\n                } catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? \": \" + sqrtError.message : \"\";\n                    throw new Error(\"Point is not on curve\" + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n                return {\n                    x,\n                    y\n                };\n            } else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return {\n                    x,\n                    y\n                };\n            } else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        }\n    });\n    const numToNByteStr = (num)=>_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to)=>_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */ class Signature {\n        constructor(r, s, recovery){\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"compactSignature\", hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"DER\", hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r)) throw new Error(\"r must be 0 < r < CURVE.n\");\n            if (!isWithinCurveOrder(this.s)) throw new Error(\"s must be 0 < s < CURVE.n\");\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash)); // Truncate hash\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error(\"recovery id invalid\");\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n            const prefix = (rec & 1) === 0 ? \"02\" : \"03\";\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q) throw new Error(\"point at infinify\"); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({\n                r: this.r,\n                s: this.s\n            });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey (privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */ randomPrivateKey: ()=>{\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */ precompute (windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        }\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        const arr = _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(item);\n        const str = typeof item === \"string\";\n        const len = (arr || str) && item.length;\n        if (arr) return len === compressedLen || len === uncompressedLen;\n        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point) return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA)) throw new Error(\"first arg must be private key\");\n        if (!isProbPub(publicB)) throw new Error(\"second arg must be public key\");\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int || function(bytes) {\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {\n        return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */ function int2octets(num) {\n        if (typeof num !== \"bigint\") throw new Error(\"bigint expected\");\n        if (!(_0n <= num && num < ORDER_MASK)) throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if ([\n            \"recovered\",\n            \"canonical\"\n        ].some((k)=>k in opts)) throw new Error(\"sign() legacy options not supported\");\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash);\n        if (prehash) msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"prehashed msgHash\", hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"extraEntropy\", e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n) return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ‚àà [1,q‚àí1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed,\n            k2sig\n        };\n    }\n    const defaultSigOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    const defaultVerOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G √ó k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */ function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1‚ãÖG - U2‚ãÖP\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"publicKey\", publicKey);\n        if (\"strict\" in opts) throw new Error(\"options.strict was renamed to lowS\");\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === \"string\" || _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(sg)) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                } catch (derError) {\n                    if (!(derError instanceof DER.Err)) throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            } else if (typeof sg === \"object\" && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\") {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            } else {\n                throw new Error(\"PARSE\");\n            }\n            P = Point.fromHex(publicKey);\n        } catch (error) {\n            if (error.message === \"PARSE\") throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS()) return false;\n        if (prehash) msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1‚ãÖG + u2‚ãÖP\n        if (!R) return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > _1n; i--){\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */ function mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd) throw new Error(\"Fp.isOdd is not implemented!\");\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return {\n            x,\n            y\n        };\n    };\n} //# sourceMappingURL=weierstrass.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUEsb0VBQW9FLEdBQ3BFLDREQUE0RDtBQUNYO0FBQ2I7QUFDSDtBQUNRO0FBQ3pDLFNBQVNLLGtCQUFrQkMsS0FBSztJQUM1QixNQUFNQyxPQUFPUCx3REFBYUEsQ0FBQ007SUFDM0JILHFEQUFpQixDQUFDSSxNQUFNO1FBQ3BCRSxHQUFHO1FBQ0hDLEdBQUc7SUFDUCxHQUFHO1FBQ0NDLDBCQUEwQjtRQUMxQkMsZ0JBQWdCO1FBQ2hCQyxlQUFlO1FBQ2ZDLGVBQWU7UUFDZkMsb0JBQW9CO1FBQ3BCQyxXQUFXO1FBQ1hDLFNBQVM7SUFDYjtJQUNBLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxFQUFFLEVBQUVWLENBQUMsRUFBRSxHQUFHRjtJQUN4QixJQUFJVyxNQUFNO1FBQ04sSUFBSSxDQUFDQyxHQUFHQyxHQUFHLENBQUNYLEdBQUdVLEdBQUdFLElBQUksR0FBRztZQUNyQixNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxJQUFJLE9BQU9KLFNBQVMsWUFDaEIsT0FBT0EsS0FBS0ssSUFBSSxLQUFLLFlBQ3JCLE9BQU9MLEtBQUtNLFdBQVcsS0FBSyxZQUFZO1lBQ3hDLE1BQU0sSUFBSUYsTUFBTTtRQUNwQjtJQUNKO0lBQ0EsT0FBT0csT0FBT0MsTUFBTSxDQUFDO1FBQUUsR0FBR25CLElBQUk7SUFBQztBQUNuQztBQUNBLCtCQUErQjtBQUMvQixNQUFNLEVBQUVvQixpQkFBaUJDLEdBQUcsRUFBRUMsWUFBWUMsR0FBRyxFQUFFLEdBQUczQixzQ0FBRUE7QUFDN0MsTUFBTTRCLE1BQU07SUFDZiwyQkFBMkI7SUFDM0JDLEtBQUssTUFBTUMsZUFBZVg7UUFDdEJZLFlBQVlDLElBQUksRUFBRSxDQUFFO1lBQ2hCLEtBQUssQ0FBQ0E7UUFDVjtJQUNKO0lBQ0FDLFdBQVVDLElBQUk7UUFDVixNQUFNLEVB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QUVoTixPQUFPLEVBQUV1TixLQUFLLEVBQUUsR0FBR1gsVUFBVUcsS0FBS2MsTUFBTSxpREFBaUQ7UUFDakc3UCxJQUFJN0QsR0FBR3FFLEdBQUcsQ0FBQ3NPLEtBQUtELElBQUkscUNBQXFDO1FBQ3pEN08sSUFBSTdELEdBQUdxRSxHQUFHLENBQUNSLEdBQUd1UCxRQUFRLG1CQUFtQjtRQUN6Q3hQLElBQUk1RCxHQUFHaVQsSUFBSSxDQUFDclAsR0FBR2lQLEtBQUtoTixVQUFVLHdDQUF3QztRQUN0RWhDLElBQUk3RCxHQUFHaVQsSUFBSSxDQUFDcFAsR0FBR3VQLE9BQU92TixVQUFVLHVDQUF1QztRQUN2RSxNQUFNc04sS0FBS25ULEdBQUdzSCxLQUFLLENBQUNvTCxPQUFPMVMsR0FBR3NILEtBQUssQ0FBQ3pELElBQUksK0JBQStCO1FBQ3ZFQSxJQUFJN0QsR0FBR2lULElBQUksQ0FBQ2pULEdBQUdpSSxHQUFHLENBQUNwRSxJQUFJQSxHQUFHc1AsS0FBSyw0QkFBNEI7UUFDM0R2UCxJQUFJNUQsR0FBRzJULEdBQUcsQ0FBQy9QLEdBQUdtUCxNQUFNLG9CQUFvQjtRQUN4QyxPQUFPO1lBQUVuUDtZQUFHQztRQUFFO0lBQ2xCO0FBQ0osRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzP2UyNTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gU2hvcnQgV2VpZXJzdHJhc3MgY3VydmUuIFRoZSBmb3JtdWxhIGlzOiB5wrIgPSB4wrMgKyBheCArIGJcbmltcG9ydCB7IHZhbGlkYXRlQmFzaWMsIHdOQUYgfSBmcm9tICcuL2N1cnZlLmpzJztcbmltcG9ydCAqIGFzIG1vZCBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0ICogYXMgdXQgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBlbnN1cmVCeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBhOiAnZmllbGQnLFxuICAgICAgICBiOiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxuICAgICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZW5kbywgRnAsIGEgfSA9IG9wdHM7XG4gICAgaWYgKGVuZG8pIHtcbiAgICAgICAgaWYgKCFGcC5lcWwoYSwgRnAuWkVSTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5kb21vcnBoaXNtIGNhbiBvbmx5IGJlIGRlZmluZWQgZm9yIEtvYmxpdHogY3VydmVzIHRoYXQgaGF2ZSBhPTAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuZG8gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZW5kb21vcnBoaXNtIHdpdGggYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG4vLyBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzXG5jb25zdCB7IGJ5dGVzVG9OdW1iZXJCRTogYjJuLCBoZXhUb0J5dGVzOiBoMmIgfSA9IHV0O1xuZXhwb3J0IGNvbnN0IERFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IGNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgY29uc3RydWN0b3IobSA9ICcnKSB7XG4gICAgICAgICAgICBzdXBlcihtKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3BhcnNlSW50KGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhWzBdICE9PSAweDAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnJyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgICAgIGNvbnN0IHJlcyA9IGRhdGEuc3ViYXJyYXkoMiwgbGVuICsgMik7XG4gICAgICAgIGlmICghbGVuIHx8IHJlcy5sZW5ndGggIT09IGxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGgnKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gICAgICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAgICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICAgICAgICBpZiAocmVzWzBdICYgMGIxMDAwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICBpZiAocmVzWzBdID09PSAweDAwICYmICEocmVzWzFdICYgMGIxMDAwMDAwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgIHJldHVybiB7IGQ6IGIybihyZXMpLCBsOiBkYXRhLnN1YmFycmF5KGxlbiArIDIpIH07IC8vIGQgaXMgZGF0YSwgbCBpcyBsZWZ0XG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgPyBoMmIoaGV4KSA6IGhleDtcbiAgICAgICAgdXQuYWJ5dGVzKGRhdGEpO1xuICAgICAgICBsZXQgbCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAobCA8IDIgfHwgZGF0YVswXSAhPSAweDMwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIHRhZycpO1xuICAgICAgICBpZiAoZGF0YVsxXSAhPT0gbCAtIDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmU6IGluY29ycmVjdCBsZW5ndGgnKTtcbiAgICAgICAgY29uc3QgeyBkOiByLCBsOiBzQnl0ZXMgfSA9IERFUi5fcGFyc2VJbnQoZGF0YS5zdWJhcnJheSgyKSk7XG4gICAgICAgIGNvbnN0IHsgZDogcywgbDogckJ5dGVzTGVmdCB9ID0gREVSLl9wYXJzZUludChzQnl0ZXMpO1xuICAgICAgICBpZiAockJ5dGVzTGVmdC5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xuICAgICAgICByZXR1cm4geyByLCBzIH07XG4gICAgfSxcbiAgICBoZXhGcm9tU2lnKHNpZykge1xuICAgICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvIGlmIGZpcnN0IGJ5dGUgaGFzIG5lZ2F0aXZlIGJpdCBlbmFibGVkLiBNb3JlIGRldGFpbHMgaW4gJ19wYXJzZUludCdcbiAgICAgICAgY29uc3Qgc2xpY2UgPSAocykgPT4gKE51bWJlci5wYXJzZUludChzWzBdLCAxNikgJiAwYjEwMDAgPyAnMDAnICsgcyA6IHMpO1xuICAgICAgICBjb25zdCBoID0gKG51bSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcyA9IHNsaWNlKGgoc2lnLnMpKTtcbiAgICAgICAgY29uc3QgciA9IHNsaWNlKGgoc2lnLnIpKTtcbiAgICAgICAgY29uc3Qgc2hsID0gcy5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCByaGwgPSByLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHNsID0gaChzaGwpO1xuICAgICAgICBjb25zdCBybCA9IGgocmhsKTtcbiAgICAgICAgcmV0dXJuIGAzMCR7aChyaGwgKyBzaGwgKyA0KX0wMiR7cmx9JHtyfTAyJHtzbH0ke3N9YDtcbiAgICB9LFxufTtcbi8vIEJlIGZyaWVuZGx5IHRvIGJhZCBFQ01BU2NyaXB0IHBhcnNlcnMgYnkgbm90IHVzaW5nIGJpZ2ludCBsaXRlcmFsc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyksIF80biA9IEJpZ0ludCg0KTtcbmV4cG9ydCBmdW5jdGlvbiB3ZWllcnN0cmFzc1BvaW50cyhvcHRzKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZVBvaW50T3B0cyhvcHRzKTtcbiAgICBjb25zdCB7IEZwIH0gPSBDVVJWRTsgLy8gQWxsIGN1cnZlcyBoYXMgc2FtZSBmaWVsZCAvIGdyb3VwIGxlbmd0aCBhcyBmb3Igbm93LCBidXQgdGhleSBjYW4gZGlmZmVyXG4gICAgY29uc3QgdG9CeXRlcyA9IENVUlZFLnRvQnl0ZXMgfHxcbiAgICAgICAgKChfYywgcG9pbnQsIF9pc0NvbXByZXNzZWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHV0LmNvbmNhdEJ5dGVzKFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCBGcC50b0J5dGVzKGEueCksIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgIH0pO1xuICAgIGNvbnN0IGZyb21CeXRlcyA9IENVUlZFLmZyb21CeXRlcyB8fFxuICAgICAgICAoKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICAvLyBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyBpZiAoaGVhZCAhPT0gMHgwNCkgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG5vbi1jb21wcmVzc2VkIGVuY29kaW5nIGlzIHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICB9KTtcbiAgICAvKipcbiAgICAgKiB5wrIgPSB4wrMgKyBheCArIGI6IFNob3J0IHdlaWVyc3RyYXNzIGN1cnZlIGZvcm11bGFcbiAgICAgKiBAcmV0dXJucyB5wrJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpIHtcbiAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgeDIgPSBGcC5zcXIoeCk7IC8vIHggKiB4XG4gICAgICAgIGNvbnN0IHgzID0gRnAubXVsKHgyLCB4KTsgLy8geDIgKiB4XG4gICAgICAgIHJldHVybiBGcC5hZGQoRnAuYWRkKHgzLCBGcC5tdWwoeCwgYSkpLCBiKTsgLy8geDMgKyBhICogeCArIGJcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgd2hldGhlciB0aGUgcGFzc2VkIGN1cnZlIHBhcmFtcyBhcmUgdmFsaWQuXG4gICAgLy8gV2UgY2hlY2sgaWYgY3VydmUgZXF1YXRpb24gd29ya3MgZm9yIGdlbmVyYXRvciBwb2ludC5cbiAgICAvLyBgYXNzZXJ0VmFsaWRpdHkoKWAgd29uJ3Qgd29yazogYGlzVG9yc2lvbkZyZWUoKWAgaXMgbm90IGF2YWlsYWJsZSBhdCB0aGlzIHBvaW50IGluIGJsczEyLTM4MS5cbiAgICAvLyBQcm9qZWN0aXZlUG9pbnQgY2xhc3MgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldC5cbiAgICBpZiAoIUZwLmVxbChGcC5zcXIoQ1VSVkUuR3kpLCB3ZWllcnN0cmFzc0VxdWF0aW9uKENVUlZFLkd4KSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGdlbmVyYXRvciBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgIC8vIFZhbGlkIGdyb3VwIGVsZW1lbnRzIHJlc2lkZSBpbiByYW5nZSAxLi5uLTFcbiAgICBmdW5jdGlvbiBpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbnVtID09PSAnYmlnaW50JyAmJiBfMG4gPCBudW0gJiYgbnVtIDwgQ1VSVkUubjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0R0UobnVtKSB7XG4gICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHZhbGlkIGJpZ2ludDogMCA8IGJpZ2ludCA8IGN1cnZlLm4nKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGVzIGlmIHByaXYga2V5IGlzIHZhbGlkIGFuZCBjb252ZXJ0cyBpdCB0byBiaWdpbnQuXG4gICAgLy8gU3VwcG9ydHMgb3B0aW9ucyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMgYW5kIHdyYXBQcml2YXRlS2V5LlxuICAgIGZ1bmN0aW9uIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIoa2V5KSB7XG4gICAgICAgIGNvbnN0IHsgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiBsZW5ndGhzLCBuQnl0ZUxlbmd0aCwgd3JhcFByaXZhdGVLZXksIG4gfSA9IENVUlZFO1xuICAgICAgICBpZiAobGVuZ3RocyAmJiB0eXBlb2Yga2V5ICE9PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgaWYgKHV0LmlzQnl0ZXMoa2V5KSlcbiAgICAgICAgICAgICAgICBrZXkgPSB1dC5ieXRlc1RvSGV4KGtleSk7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gaGV4IHN0cmluZywgcGFkLiBFLmcuIFA1MjEgd291bGQgbm9ybSAxMzAtMTMyIGNoYXIgaGV4IHRvIDEzMi1jaGFyIGJ5dGVzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwgIWxlbmd0aHMuaW5jbHVkZXMoa2V5Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgICAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbnVtID1cbiAgICAgICAgICAgICAgICB0eXBlb2Yga2V5ID09PSAnYmlnaW50J1xuICAgICAgICAgICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgICAgICAgICA6IHV0LmJ5dGVzVG9OdW1iZXJCRShlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXksIG5CeXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByaXZhdGUga2V5IG11c3QgYmUgJHtuQnl0ZUxlbmd0aH0gYnl0ZXMsIGhleCBvciBiaWdpbnQsIG5vdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxuICAgICAgICAgICAgbnVtID0gbW9kLm1vZChudW0sIG4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgYXNzZXJ0R0UobnVtKTsgLy8gbnVtIGluIHJhbmdlIFsxLi5OLTFdXG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3RpdmVQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOiAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXG4gICAgICogV2UncmUgZG9pbmcgY2FsY3VsYXRpb25zIGluIHByb2plY3RpdmUsIGJlY2F1c2UgaXRzIG9wZXJhdGlvbnMgZG9uJ3QgcmVxdWlyZSBjb3N0bHkgaW52ZXJzaW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHgsIHB5LCBweikge1xuICAgICAgICAgICAgdGhpcy5weCA9IHB4O1xuICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xuICAgICAgICAgICAgdGhpcy5weiA9IHB6O1xuICAgICAgICAgICAgaWYgKHB4ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB5ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneiByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcyhlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb24ndCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB3aW5kb3dTaXplO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSkge1xuICAgICAgICAgICAgICAgIC8vICgwLCAxLCAwKSBha2EgWkVSTyBpcyBpbnZhbGlkIGluIG1vc3QgY29udGV4dHMuXG4gICAgICAgICAgICAgICAgLy8gSW4gQkxTLCBaRVJPIGNhbiBiZSBzZXJpYWxpemVkLCBzbyB3ZSBhbGxvdyBpdC5cbiAgICAgICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgd3JvbmcgcmVwcmVzZW50YXRpb24gb2YgWkVSTyBhbmQgaXMgYWx3YXlzIGludmFsaWQuXG4gICAgICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHRoaXMucHkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWUgM3JkLXBhcnR5IHRlc3QgdmVjdG9ycyByZXF1aXJlIGRpZmZlcmVudCB3b3JkaW5nIGJldHdlZW4gaGVyZSAmIGBmcm9tQ29tcHJlc3NlZEhleGBcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBGRScpO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgaWYgKCFGcC5lcWwobGVmdCwgcmlnaHQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBwb2ludFByZWNvbXB1dGVzLCBuLCAoY29tcCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2goY29tcC5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcC5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUobikge1xuICAgICAgICAgICAgY29uc3QgSSA9IFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgYXNzZXJ0R0Uobik7IC8vIFdpbGwgdGhyb3cgb24gMFxuICAgICAgICAgICAgaWYgKG4gPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoIWVuZG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIG4pO1xuICAgICAgICAgICAgLy8gQXBwbHkgZW5kb21vcnBoaXNtXG4gICAgICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGFzc2VydEdFKHNjYWxhcik7XG4gICAgICAgICAgICBsZXQgbiA9IHNjYWxhcjtcbiAgICAgICAgICAgIGxldCBwb2ludCwgZmFrZTsgLy8gRmFrZSBwb2ludCBpcyB1c2VkIHRvIGNvbnN0LXRpbWUgbXVsdFxuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRWZmaWNpZW50bHkgY2FsY3VsYXRlIGBhUCArIGJRYC4gVW5zYWZlLCBjYW4gZXhwb3NlIHByaXZhdGUga2V5LCBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxuICAgICAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXG4gICAgICAgICAqIEByZXR1cm5zIG5vbi16ZXJvIGFmZmluZSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3QgRyA9IFBvaW50LkJBU0U7IC8vIE5vIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiB3ZSBoYXZlIDEwJSBmYXN0ZXIgRyBwcmVjb21wdXRlc1xuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxuICAgICAgICAgICAgKSA9PiAoYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCAhUC5lcXVhbHMoRykgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKSk7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBtdWwodGhpcywgYSkuYWRkKG11bChRLCBiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgICAgdG9BZmZpbmUoaXopIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IHgsIHB5OiB5LCBwejogeiB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IHRoaXMuaXMwKCk7XG4gICAgICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgICAgIGNvbnN0IGF4ID0gRnAubXVsKHgsIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IGF5ID0gRnAubXVsKHksIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgICAgIGlmIChpczApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcbiAgICAgICAgfVxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgaXNUb3JzaW9uRnJlZSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gc3ViZ3JvdXBzLCBhbHdheXMgdG9yc2lvbi1mcmVlXG4gICAgICAgICAgICBpZiAoaXNUb3JzaW9uRnJlZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBjbGVhckNvZmFjdG9yIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBGYXN0LXBhdGhcbiAgICAgICAgICAgIGlmIChjbGVhckNvZmFjdG9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhckNvZmFjdG9yKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKENVUlZFLmgpO1xuICAgICAgICB9XG4gICAgICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTtcbiAgICBjb25zdCBfYml0cyA9IENVUlZFLm5CaXRMZW5ndGg7XG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQsIENVUlZFLmVuZG8gPyBNYXRoLmNlaWwoX2JpdHMgLyAyKSA6IF9iaXRzKTtcbiAgICAvLyBWYWxpZGF0ZSBpZiBnZW5lcmF0b3IgcG9pbnQgaXMgb24gY3VydmVcbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgd2VpZXJzdHJhc3NFcXVhdGlvbixcbiAgICAgICAgaXNXaXRoaW5DdXJ2ZU9yZGVyLFxuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkRmllbGRFbGVtZW50KG51bSkge1xuICAgICAgICByZXR1cm4gXzBuIDwgbnVtICYmIG51bSA8IEZwLk9SREVSOyAvLyAwIGlzIGJhbm5lZCBzaW5jZSBpdCdzIG5vdCBpbnZlcnRpYmxlIEZFXG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vZE4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLm1vZChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludk4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLmludmVydChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGNvbnN0IHsgUHJvamVjdGl2ZVBvaW50OiBQb2ludCwgbm9ybVByaXZhdGVLZXlUb1NjYWxhciwgd2VpZXJzdHJhc3NFcXVhdGlvbiwgaXNXaXRoaW5DdXJ2ZU9yZGVyLCB9ID0gd2VpZXJzdHJhc3NQb2ludHMoe1xuICAgICAgICAuLi5DVVJWRSxcbiAgICAgICAgdG9CeXRlcyhfYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAudG9CeXRlcyhhLngpO1xuICAgICAgICAgICAgY29uc3QgY2F0ID0gdXQuY29uY2F0Qnl0ZXM7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oW3BvaW50Lmhhc0V2ZW5ZKCkgPyAweDAyIDogMHgwM10pLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFsweDA0XSksIHgsIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gdGhpcy5hc3NlcnRWYWxpZGl0eSgpIGlzIGRvbmUgaW5zaWRlIG9mIGZyb21IZXhcbiAgICAgICAgICAgIGlmIChsZW4gPT09IGNvbXByZXNzZWRMZW4gJiYgKGhlYWQgPT09IDB4MDIgfHwgaGVhZCA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gdXQuYnl0ZXNUb051bWJlckJFKHRhaWwpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEZpZWxkRWxlbWVudCh4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MiA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHnCsiA9IHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgICAgIGxldCB5O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBGcC5zcXJ0KHkyKTsgLy8geSA9IHnCsiBeIChwKzEpLzRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKHNxcnRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWZmaXggPSBzcXJ0RXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/ICc6ICcgKyBzcXJ0RXJyb3IubWVzc2FnZSA6ICcnO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScgKyBzdWZmaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpc1lPZGQgPSAoeSAmIF8xbikgPT09IF8xbjtcbiAgICAgICAgICAgICAgICAvLyBFQ0RTQVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzSGVhZE9kZCA9IChoZWFkICYgMSkgPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKGlzSGVhZE9kZCAhPT0gaXNZT2RkKVxuICAgICAgICAgICAgICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuICYmIGhlYWQgPT09IDB4MDQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9pbnQgb2YgbGVuZ3RoICR7bGVufSB3YXMgaW52YWxpZC4gRXhwZWN0ZWQgJHtjb21wcmVzc2VkTGVufSBjb21wcmVzc2VkIGJ5dGVzIG9yICR7dW5jb21wcmVzc2VkTGVufSB1bmNvbXByZXNzZWQgYnl0ZXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBudW1Ub05CeXRlU3RyID0gKG51bSkgPT4gdXQuYnl0ZXNUb0hleCh1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCkpO1xuICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcbiAgICAgICAgY29uc3QgSEFMRiA9IENVUlZFX09SREVSID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIG51bWJlciA+IEhBTEY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVMocykge1xuICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpID8gbW9kTigtcykgOiBzO1xuICAgIH1cbiAgICAvLyBzbGljZSBieXRlcyBudW1cbiAgICBjb25zdCBzbGNOdW0gPSAoYiwgZnJvbSwgdG8pID0+IHV0LmJ5dGVzVG9OdW1iZXJCRShiLnNsaWNlKGZyb20sIHRvKSk7XG4gICAgLyoqXG4gICAgICogRUNEU0Egc2lnbmF0dXJlIHdpdGggaXRzIChyLCBzKSBwcm9wZXJ0aWVzLiBTdXBwb3J0cyBERVIgJiBjb21wYWN0IHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cbiAgICBjbGFzcyBTaWduYXR1cmUge1xuICAgICAgICBjb25zdHJ1Y3RvcihyLCBzLCByZWNvdmVyeSkge1xuICAgICAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgICAgICB0aGlzLnJlY292ZXJ5ID0gcmVjb3Zlcnk7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFpciAoYnl0ZXMgb2YgciwgYnl0ZXMgb2YgcylcbiAgICAgICAgc3RhdGljIGZyb21Db21wYWN0KGhleCkge1xuICAgICAgICAgICAgY29uc3QgbCA9IENVUlZFLm5CeXRlTGVuZ3RoO1xuICAgICAgICAgICAgaGV4ID0gZW5zdXJlQnl0ZXMoJ2NvbXBhY3RTaWduYXR1cmUnLCBoZXgsIGwgKiAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHNsY051bShoZXgsIDAsIGwpLCBzbGNOdW0oaGV4LCBsLCAyICogbCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUiBlbmNvZGVkIEVDRFNBIHNpZ25hdHVyZVxuICAgICAgICAvLyBodHRwczovL2JpdGNvaW4uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzU3NjQ0L3doYXQtYXJlLXRoZS1wYXJ0cy1vZi1hLWJpdGNvaW4tdHJhbnNhY3Rpb24taW5wdXQtc2NyaXB0XG4gICAgICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBERVIudG9TaWcoZW5zdXJlQnl0ZXMoJ0RFUicsIGhleCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICAvLyBjYW4gdXNlIGFzc2VydEdFIGhlcmVcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyIG11c3QgYmUgMCA8IHIgPCBDVVJWRS5uJyk7XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncyBtdXN0IGJlIDAgPCBzIDwgQ1VSVkUubicpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFJlY292ZXJ5Qml0KHJlY292ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzLCByZWNvdmVyeTogcmVjIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4oZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKSk7IC8vIFRydW5jYXRlIGhhc2hcbiAgICAgICAgICAgIGlmIChyZWMgPT0gbnVsbCB8fCAhWzAsIDEsIDIsIDNdLmluY2x1ZGVzKHJlYykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCByYWRqID0gcmVjID09PSAyIHx8IHJlYyA9PT0gMyA/IHIgKyBDVVJWRS5uIDogcjtcbiAgICAgICAgICAgIGlmIChyYWRqID49IEZwLk9SREVSKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgMiBvciAzIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IChyZWMgJiAxKSA9PT0gMCA/ICcwMicgOiAnMDMnO1xuICAgICAgICAgICAgY29uc3QgUiA9IFBvaW50LmZyb21IZXgocHJlZml4ICsgbnVtVG9OQnl0ZVN0cihyYWRqKSk7XG4gICAgICAgICAgICBjb25zdCBpciA9IGludk4ocmFkaik7IC8vIHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUxID0gbW9kTigtaCAqIGlyKTsgLy8gLWhyXi0xXG4gICAgICAgICAgICBjb25zdCB1MiA9IG1vZE4ocyAqIGlyKTsgLy8gc3JeLTFcbiAgICAgICAgICAgIGNvbnN0IFEgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFIsIHUxLCB1Mik7IC8vIChzcl4tMSlSLShocl4tMSlHID0gLShocl4tMSlHICsgKHNyXi0xKVxuICAgICAgICAgICAgaWYgKCFRKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9pbnQgYXQgaW5maW5pZnknKTsgLy8gdW5zYWZlIGlzIGZpbmU6IG5vIHByaXYgZGF0YSBsZWFrZWRcbiAgICAgICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBRO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpZ25hdHVyZXMgc2hvdWxkIGJlIGxvdy1zLCB0byBwcmV2ZW50IG1hbGxlYWJpbGl0eS5cbiAgICAgICAgaGFzSGlnaFMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9ybWFsaXplUygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgU2lnbmF0dXJlKHRoaXMuciwgbW9kTigtdGhpcy5zKSwgdGhpcy5yZWNvdmVyeSkgOiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUi1lbmNvZGVkXG4gICAgICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvREVSSGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvREVSSGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIERFUi5oZXhGcm9tU2lnKHsgcjogdGhpcy5yLCBzOiB0aGlzLnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFkZGVkIGJ5dGVzIG9mIHIsIHRoZW4gcGFkZGVkIGJ5dGVzIG9mIHNcbiAgICAgICAgdG9Db21wYWN0UmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvQ29tcGFjdEhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0NvbXBhY3RIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtVG9OQnl0ZVN0cih0aGlzLnIpICsgbnVtVG9OQnl0ZVN0cih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICBpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXI6IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlcyBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHJpdmF0ZSBrZXkgZnJvbSByYW5kb20gb2Ygc2l6ZVxuICAgICAgICAgKiAoZ3JvdXBMZW4gKyBjZWlsKGdyb3VwTGVuIC8gMikpIHdpdGggbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IG1vZC5nZXRNaW5IYXNoTGVuZ3RoKENVUlZFLm4pO1xuICAgICAgICAgICAgcmV0dXJuIG1vZC5tYXBIYXNoVG9GaWVsZChDVVJWRS5yYW5kb21CeXRlcyhsZW5ndGgpLCBDVVJWRS5uKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgcHJlY29tcHV0ZSB0YWJsZSBmb3IgYW4gYXJiaXRyYXJ5IEVDIHBvaW50LiBNYWtlcyBwb2ludCBcImNhY2hlZFwiLlxuICAgICAgICAgKiBBbGxvd3MgdG8gbWFzc2l2ZWx5IHNwZWVkLXVwIGBwb2ludC5tdWx0aXBseShzY2FsYXIpYC5cbiAgICAgICAgICogQHJldHVybnMgY2FjaGVkIHBvaW50XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IGZhc3QgPSB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5mcm9tSGV4KHNvbWVvbmVzUHViS2V5KSk7XG4gICAgICAgICAqIGZhc3QubXVsdGlwbHkocHJpdktleSk7IC8vIG11Y2ggZmFzdGVyIEVDREggbm93XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTsgLy8gMyBpcyBhcmJpdHJhcnksIGp1c3QgbmVlZCBhbnkgbnVtYmVyIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXkuIENoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgYXJyID0gdXQuaXNCeXRlcyhpdGVtKTtcbiAgICAgICAgY29uc3Qgc3RyID0gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnO1xuICAgICAgICBjb25zdCBsZW4gPSAoYXJyIHx8IHN0cikgJiYgaXRlbS5sZW5ndGg7XG4gICAgICAgIGlmIChhcnIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuO1xuICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gMiAqIGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSAyICogdW5jb21wcmVzc2VkTGVuO1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRUNESCAoRWxsaXB0aWMgQ3VydmUgRGlmZmllIEhlbGxtYW4pLlxuICAgICAqIENvbXB1dGVzIHNoYXJlZCBwdWJsaWMga2V5IGZyb20gcHJpdmF0ZSBrZXkgYW5kIHB1YmxpYyBrZXkuXG4gICAgICogQ2hlY2tzOiAxKSBwcml2YXRlIGtleSB2YWxpZGl0eSAyKSBzaGFyZWQga2V5IGlzIG9uLWN1cnZlLlxuICAgICAqIERvZXMgTk9UIGhhc2ggdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUEgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gcHVibGljQiBkaWZmZXJlbnQgcHVibGljIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgc2hhcmVkIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQocHJpdmF0ZUEsIHB1YmxpY0IsIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgaWYgKGlzUHJvYlB1Yihwcml2YXRlQSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZyBtdXN0IGJlIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIGlmICghaXNQcm9iUHViKHB1YmxpY0IpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWNvbmQgYXJnIG11c3QgYmUgcHVibGljIGtleScpO1xuICAgICAgICBjb25zdCBiID0gUG9pbnQuZnJvbUhleChwdWJsaWNCKTsgLy8gY2hlY2sgZm9yIGJlaW5nIG9uLWN1cnZlXG4gICAgICAgIHJldHVybiBiLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUEpKS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8vIFJGQzY5Nzk6IGVuc3VyZSBFQ0RTQSBtc2cgaXMgWCBieXRlcyBhbmQgPCBOLiBSRkMgc3VnZ2VzdHMgb3B0aW9uYWwgdHJ1bmNhdGluZyB2aWEgYml0czJvY3RldHMuXG4gICAgLy8gRklQUyAxODYtNCA0LjYgc3VnZ2VzdHMgdGhlIGxlZnRtb3N0IG1pbihuQml0TGVuLCBvdXRMZW4pIGJpdHMsIHdoaWNoIG1hdGNoZXMgYml0czJpbnQuXG4gICAgLy8gYml0czJpbnQgY2FuIHByb2R1Y2UgcmVzPk4sIHdlIGNhbiBkbyBtb2QocmVzLCBOKSBzaW5jZSB0aGUgYml0TGVuIGlzIHRoZSBzYW1lLlxuICAgIC8vIGludDJvY3RldHMgY2FuJ3QgYmUgdXNlZDsgcGFkcyBzbWFsbCBtc2dzIHdpdGggMDogdW5hY2NlcHRhdGJsZSBmb3IgdHJ1bmMgYXMgcGVyIFJGQyB2ZWN0b3JzXG4gICAgY29uc3QgYml0czJpbnQgPSBDVVJWRS5iaXRzMmludCB8fFxuICAgICAgICBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIEZvciBjdXJ2ZXMgd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMDogYml0czJvY3RldHMoYml0czJvY3RldHMobSkpICE9PSBiaXRzMm9jdGV0cyhtKVxuICAgICAgICAgICAgLy8gZm9yIHNvbWUgY2FzZXMsIHNpbmNlIGJ5dGVzLmxlbmd0aCAqIDggaXMgbm90IGFjdHVhbCBiaXRMZW5ndGguXG4gICAgICAgICAgICBjb25zdCBudW0gPSB1dC5ieXRlc1RvTnVtYmVyQkUoYnl0ZXMpOyAvLyBjaGVjayBmb3IgPT0gdTggZG9uZSBoZXJlXG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGJ5dGVzLmxlbmd0aCAqIDggLSBDVVJWRS5uQml0TGVuZ3RoOyAvLyB0cnVuY2F0ZSB0byBuQml0TGVuZ3RoIGxlZnRtb3N0IGJpdHNcbiAgICAgICAgICAgIHJldHVybiBkZWx0YSA+IDAgPyBudW0gPj4gQmlnSW50KGRlbHRhKSA6IG51bTtcbiAgICAgICAgfTtcbiAgICBjb25zdCBiaXRzMmludF9tb2ROID0gQ1VSVkUuYml0czJpbnRfbW9kTiB8fFxuICAgICAgICBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2ROKGJpdHMyaW50KGJ5dGVzKSk7IC8vIGNhbid0IHVzZSBieXRlc1RvTnVtYmVyQkUgaGVyZVxuICAgICAgICB9O1xuICAgIC8vIE5PVEU6IHBhZHMgb3V0cHV0IHdpdGggemVybyBhcyBwZXIgc3BlY1xuICAgIGNvbnN0IE9SREVSX01BU0sgPSB1dC5iaXRNYXNrKENVUlZFLm5CaXRMZW5ndGgpO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRvIGJ5dGVzLiBDaGVja3MgaWYgbnVtIGluIGBbMC4uT1JERVJfTUFTSy0xXWAgZS5nLjogYFswLi4yXjI1Ni0xXWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50Mm9jdGV0cyhudW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaWdpbnQgZXhwZWN0ZWQnKTtcbiAgICAgICAgaWYgKCEoXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUl9NQVNLKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmlnaW50IGV4cGVjdGVkIDwgMl4ke0NVUlZFLm5CaXRMZW5ndGh9YCk7XG4gICAgICAgIC8vIHdvcmtzIHdpdGggb3JkZXIsIGNhbiBoYXZlIGRpZmZlcmVudCBzaXplIHRoYW4gbnVtVG9GaWVsZCFcbiAgICAgICAgcmV0dXJuIHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMlxuICAgIC8vIENyZWF0ZXMgUkZDNjk3OSBzZWVkOyBjb252ZXJ0cyBtc2cvcHJpdktleSB0byBudW1iZXJzLlxuICAgIC8vIFVzZWQgb25seSBpbiBzaWduLCBub3QgaW4gdmVyaWZ5LlxuICAgIC8vIE5PVEU6IHdlIGNhbm5vdCBhc3N1bWUgaGVyZSB0aGF0IG1zZ0hhc2ggaGFzIHNhbWUgYW1vdW50IG9mIGJ5dGVzIGFzIGN1cnZlIG9yZGVyLCB0aGlzIHdpbGwgYmUgd3JvbmcgYXQgbGVhc3QgZm9yIFA1MjEuXG4gICAgLy8gQWxzbyBpdCBjYW4gYmUgYmlnZ2VyIGZvciBQMjI0ICsgU0hBMjU2XG4gICAgZnVuY3Rpb24gcHJlcFNpZyhtc2dIYXNoLCBwcml2YXRlS2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgaWYgKFsncmVjb3ZlcmVkJywgJ2Nhbm9uaWNhbCddLnNvbWUoKGspID0+IGsgaW4gb3B0cykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24oKSBsZWdhY3kgb3B0aW9ucyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIGNvbnN0IHsgaGFzaCwgcmFuZG9tQnl0ZXMgfSA9IENVUlZFO1xuICAgICAgICBsZXQgeyBsb3dTLCBwcmVoYXNoLCBleHRyYUVudHJvcHk6IGVudCB9ID0gb3B0czsgLy8gZ2VuZXJhdGVzIGxvdy1zIHNpZ3MgYnkgZGVmYXVsdFxuICAgICAgICBpZiAobG93UyA9PSBudWxsKVxuICAgICAgICAgICAgbG93UyA9IHRydWU7IC8vIFJGQzY5NzkgMy4yOiB3ZSBza2lwIHN0ZXAgQSwgYmVjYXVzZSB3ZSBhbHJlYWR5IHByb3ZpZGUgaGFzaFxuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ3ByZWhhc2hlZCBtc2dIYXNoJywgaGFzaChtc2dIYXNoKSk7XG4gICAgICAgIC8vIFdlIGNhbid0IGxhdGVyIGNhbGwgYml0czJvY3RldHMsIHNpbmNlIG5lc3RlZCBiaXRzMmludCBpcyBicm9rZW4gZm9yIGN1cnZlc1xuICAgICAgICAvLyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwLiBCZWNhdXNlIG9mIHRoYXQsIHdlIHVud3JhcCBpdCBoZXJlIGFzIGludDJvY3RldHMgY2FsbC5cbiAgICAgICAgLy8gY29uc3QgYml0czJvY3RldHMgPSAoYml0cykgPT4gaW50Mm9jdGV0cyhiaXRzMmludF9tb2ROKGJpdHMpKVxuICAgICAgICBjb25zdCBoMWludCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IGQgPSBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpOyAvLyB2YWxpZGF0ZSBwcml2YXRlIGtleSwgY29udmVydCB0byBiaWdpbnRcbiAgICAgICAgY29uc3Qgc2VlZEFyZ3MgPSBbaW50Mm9jdGV0cyhkKSwgaW50Mm9jdGV0cyhoMWludCldO1xuICAgICAgICAvLyBleHRyYUVudHJvcHkuIFJGQzY5NzkgMy42OiBhZGRpdGlvbmFsIGsnIChvcHRpb25hbCkuXG4gICAgICAgIGlmIChlbnQgIT0gbnVsbCAmJiBlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlbnQgPT09IHRydWUgPyByYW5kb21CeXRlcyhGcC5CWVRFUykgOiBlbnQ7IC8vIGdlbmVyYXRlIHJhbmRvbSBieXRlcyBPUiBwYXNzIGFzLWlzXG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKGVuc3VyZUJ5dGVzKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoIH0gPSBvcHRzO1xuICAgICAgICBsZXQgX3NpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IFA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCB1dC5pc0J5dGVzKHNnKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKm5CeXRlTGVuZ3RoKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHNnLnIgPT09ICdiaWdpbnQnICYmIHR5cGVvZiBzZy5zID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gc2c7XG4gICAgICAgICAgICAgICAgX3NpZyA9IG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BBUlNFJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQID0gUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UgPT09ICdQQVJTRScpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduYXR1cmUgbXVzdCBiZSBTaWduYXR1cmUgaW5zdGFuY2UsIFVpbnQ4QXJyYXkgb3IgaGV4IHN0cmluZ2ApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dTICYmIF9zaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gQ1VSVkUuaGFzaChtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSBfc2lnO1xuICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICBjb25zdCBpcyA9IGludk4ocyk7IC8vIHNeLTFcbiAgICAgICAgY29uc3QgdTEgPSBtb2ROKGggKiBpcyk7IC8vIHUxID0gaHNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgdTIgPSBtb2ROKHIgKiBpcyk7IC8vIHUyID0gcnNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdTEsIHUyKT8udG9BZmZpbmUoKTsgLy8gUiA9IHUx4ouFRyArIHUy4ouFUFxuICAgICAgICBpZiAoIVIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHYgPSBtb2ROKFIueCk7XG4gICAgICAgIHJldHVybiB2ID09PSByO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgZ2V0UHVibGljS2V5LFxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQsXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgU2lnbmF0dXJlLFxuICAgICAgICB1dGlscyxcbiAgICB9O1xufVxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2hhbGx1ZSBhbmQgdmFuIGRlIFdvZXN0aWpuZSBtZXRob2QgZm9yIGFueSB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIFRPRE86IGNoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIG1lcmdlIHRoaXMgd2l0aCB1dlJhdGlvIGluIEVkd2FyZHM7IG1vdmUgdG8gbW9kdWxhci5cbiAqIGIgPSBUcnVlIGFuZCB5ID0gc3FydCh1IC8gdikgaWYgKHUgLyB2KSBpcyBzcXVhcmUgaW4gRiwgYW5kXG4gKiBiID0gRmFsc2UgYW5kIHkgPSBzcXJ0KFogKiAodSAvIHYpKSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gRnBcbiAqIEBwYXJhbSBaXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gU1dVRnBTcXJ0UmF0aW8oRnAsIFopIHtcbiAgICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgcSA9IEZwLk9SREVSO1xuICAgIGxldCBsID0gXzBuO1xuICAgIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKVxuICAgICAgICBsICs9IF8xbjtcbiAgICBjb25zdCBjMSA9IGw7IC8vIDEuIGMxLCB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHN1Y2ggdGhhdCAyXmMxIGRpdmlkZXMgcSAtIDEuXG4gICAgLy8gV2UgbmVlZCAybiAqKiBjMSBhbmQgMm4gKiogKGMxLTEpLiBXZSBjYW4ndCB1c2UgKio7IGJ1dCB3ZSBjYW4gdXNlIDw8LlxuICAgIC8vIDJuICoqIGMxID09IDJuIDw8IChjMS0xKVxuICAgIGNvbnN0IF8ybl9wb3dfYzFfMSA9IF8ybiA8PCAoYzEgLSBfMW4gLSBfMW4pO1xuICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XG4gICAgY29uc3QgYzIgPSAocSAtIF8xbikgLyBfMm5fcG93X2MxOyAvLyAyLiBjMiA9IChxIC0gMSkgLyAoMl5jMSkgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzMgPSAoYzIgLSBfMW4pIC8gXzJuOyAvLyAzLiBjMyA9IChjMiAtIDEpIC8gMiAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzQgPSBfMm5fcG93X2MxIC0gXzFuOyAvLyA0LiBjNCA9IDJeYzEgLSAxICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzUgPSBfMm5fcG93X2MxXzE7IC8vIDUuIGM1ID0gMl4oYzEgLSAxKSAgICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzYgPSBGcC5wb3coWiwgYzIpOyAvLyA2LiBjNiA9IFpeYzJcbiAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW4pIC8gXzJuKTsgLy8gNy4gYzcgPSBaXigoYzIgKyAxKSAvIDIpXG4gICAgbGV0IHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgIGxldCB0djEgPSBjNjsgLy8gMS4gdHYxID0gYzZcbiAgICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcbiAgICAgICAgbGV0IHR2MyA9IEZwLnNxcih0djIpOyAvLyAzLiB0djMgPSB0djJeMlxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCB2KTsgLy8gNC4gdHYzID0gdHYzICogdlxuICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NSwgYzMpOyAvLyA2LiB0djUgPSB0djVeYzNcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NSwgdHYyKTsgLy8gNy4gdHY1ID0gdHY1ICogdHYyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XG4gICAgICAgIHR2MyA9IEZwLm11bCh0djUsIHUpOyAvLyA5LiB0djMgPSB0djUgKiB1XG4gICAgICAgIGxldCB0djQgPSBGcC5tdWwodHYzLCB0djIpOyAvLyAxMC4gdHY0ID0gdHYzICogdHYyXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxuICAgICAgICBsZXQgaXNRUiA9IEZwLmVxbCh0djUsIEZwLk9ORSk7IC8vIDEyLiBpc1FSID0gdHY1ID09IDFcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MywgYzcpOyAvLyAxMy4gdHYyID0gdHYzICogYzdcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBpc1FSKTsgLy8gMTUuIHR2MyA9IENNT1YodHYyLCB0djMsIGlzUVIpXG4gICAgICAgIHR2NCA9IEZwLmNtb3YodHY1LCB0djQsIGlzUVIpOyAvLyAxNi4gdHY0ID0gQ01PVih0djUsIHR2NCwgaXNRUilcbiAgICAgICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxuICAgICAgICBmb3IgKGxldCBpID0gYzE7IGkgPiBfMW47IGktLSkge1xuICAgICAgICAgICAgbGV0IHR2NSA9IGkgLSBfMm47IC8vIDE4LiAgICB0djUgPSBpIC0gMlxuICAgICAgICAgICAgdHY1ID0gXzJuIDw8ICh0djUgLSBfMW4pOyAvLyAxOS4gICAgdHY1ID0gMl50djVcbiAgICAgICAgICAgIGxldCB0dnY1ID0gRnAucG93KHR2NCwgdHY1KTsgLy8gMjAuICAgIHR2NSA9IHR2NF50djVcbiAgICAgICAgICAgIGNvbnN0IGUxID0gRnAuZXFsKHR2djUsIEZwLk9ORSk7IC8vIDIxLiAgICBlMSA9IHR2NSA9PSAxXG4gICAgICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpOyAvLyAyMi4gICAgdHYyID0gdHYzICogdHYxXG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djEpOyAvLyAyMy4gICAgdHYxID0gdHYxICogdHYxXG4gICAgICAgICAgICB0dnY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMjQuICAgIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpOyAvLyAyNS4gICAgdHYzID0gQ01PVih0djIsIHR2MywgZTEpXG4gICAgICAgICAgICB0djQgPSBGcC5jbW92KHR2djUsIHR2NCwgZTEpOyAvLyAyNi4gICAgdHY0ID0gQ01PVih0djUsIHR2NCwgZTEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuICAgIH07XG4gICAgaWYgKEZwLk9SREVSICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxuICAgICAgICBjb25zdCBjMSA9IChGcC5PUkRFUiAtIF8zbikgLyBfNG47IC8vIDEuIGMxID0gKHEgLSAzKSAvIDQgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIGNvbnN0IGMyID0gRnAuc3FydChGcC5uZWcoWikpOyAvLyAyLiBjMiA9IHNxcnQoLVopXG4gICAgICAgIHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHYxID0gRnAuc3FyKHYpOyAvLyAxLiB0djEgPSB2XjJcbiAgICAgICAgICAgIGNvbnN0IHR2MiA9IEZwLm11bCh1LCB2KTsgLy8gMi4gdHYyID0gdSAqIHZcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxuICAgICAgICAgICAgbGV0IHkxID0gRnAucG93KHR2MSwgYzEpOyAvLyA0LiB5MSA9IHR2MV5jMVxuICAgICAgICAgICAgeTEgPSBGcC5tdWwoeTEsIHR2Mik7IC8vIDUuIHkxID0geTEgKiB0djJcbiAgICAgICAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxuICAgICAgICAgICAgY29uc3QgdHYzID0gRnAubXVsKEZwLnNxcih5MSksIHYpOyAvLyA3LiB0djMgPSB5MV4yOyA4LiB0djMgPSB0djMgKiB2XG4gICAgICAgICAgICBjb25zdCBpc1FSID0gRnAuZXFsKHR2MywgdSk7IC8vIDkuIGlzUVIgPSB0djMgPT0gdVxuICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogeSB9OyAvLyAxMS4gcmV0dXJuIChpc1FSLCB5KSBpc1FSID8geSA6IHkqYzJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTm8gY3VydmVzIHVzZXMgdGhhdFxuICAgIC8vIGlmIChGcC5PUkRFUiAlIF84biA9PT0gXzVuKSAvLyBzcXJ0X3JhdGlvXzVtb2Q4XG4gICAgcmV0dXJuIHNxcnRSYXRpbztcbn1cbi8qKlxuICogU2ltcGxpZmllZCBTaGFsbHVlLXZhbiBkZSBXb2VzdGlqbmUtVWxhcyBNZXRob2RcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNi42LjJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIG9wdHMpIHtcbiAgICBtb2QudmFsaWRhdGVGaWVsZChGcCk7XG4gICAgaWYgKCFGcC5pc1ZhbGlkKG9wdHMuQSkgfHwgIUZwLmlzVmFsaWQob3B0cy5CKSB8fCAhRnAuaXNWYWxpZChvcHRzLlopKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICAgIGNvbnN0IHNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvKEZwLCBvcHRzLlopO1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnAuaXNPZGQgaXMgbm90IGltcGxlbWVudGVkIScpO1xuICAgIC8vIElucHV0OiB1LCBhbiBlbGVtZW50IG9mIEYuXG4gICAgLy8gT3V0cHV0OiAoeCwgeSksIGEgcG9pbnQgb24gRS5cbiAgICByZXR1cm4gKHUpID0+IHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCB0djEsIHR2MiwgdHYzLCB0djQsIHR2NSwgdHY2LCB4LCB5O1xuICAgICAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcbiAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgb3B0cy5aKTsgLy8gMi4gIHR2MSA9IFogKiB0djFcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXG4gICAgICAgIHR2MyA9IEZwLmFkZCh0djIsIEZwLk9ORSk7IC8vIDUuICB0djMgPSB0djIgKyAxXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIG9wdHMuQik7IC8vIDYuICB0djMgPSBCICogdHYzXG4gICAgICAgIHR2NCA9IEZwLmNtb3Yob3B0cy5aLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXG4gICAgICAgIHR2NCA9IEZwLm11bCh0djQsIG9wdHMuQSk7IC8vIDguICB0djQgPSBBICogdHY0XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkEpOyAvLyAxMS4gdHY1ID0gQSAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxMi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICAgICAgdHY2ID0gRnAubXVsKHR2NiwgdHY0KTsgLy8gMTQuIHR2NiA9IHR2NiAqIHR2NFxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkIpOyAvLyAxNS4gdHY1ID0gQiAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHggPSBGcC5tdWwodHYxLCB0djMpOyAvLyAxNy4gICB4ID0gdHYxICogdHYzXG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWUgfSA9IHNxcnRSYXRpbyh0djIsIHR2Nik7IC8vIDE4LiAoaXNfZ3gxX3NxdWFyZSwgeTEpID0gc3FydF9yYXRpbyh0djIsIHR2NilcbiAgICAgICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXG4gICAgICAgIHkgPSBGcC5tdWwoeSwgdmFsdWUpOyAvLyAyMC4gICB5ID0geSAqIHkxXG4gICAgICAgIHggPSBGcC5jbW92KHgsIHR2MywgaXNWYWxpZCk7IC8vIDIxLiAgIHggPSBDTU9WKHgsIHR2MywgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgY29uc3QgZTEgPSBGcC5pc09kZCh1KSA9PT0gRnAuaXNPZGQoeSk7IC8vIDIzLiAgZTEgPSBzZ24wKHUpID09IHNnbjAoeSlcbiAgICAgICAgeSA9IEZwLmNtb3YoRnAubmVnKHkpLCB5LCBlMSk7IC8vIDI0LiAgIHkgPSBDTU9WKC15LCB5LCBlMSlcbiAgICAgICAgeCA9IEZwLmRpdih4LCB0djQpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlaWVyc3RyYXNzLmpzLm1hcCJdLCJuYW1lcyI6WyJ2YWxpZGF0ZUJhc2ljIiwid05BRiIsIm1vZCIsInV0IiwiZW5zdXJlQnl0ZXMiLCJ2YWxpZGF0ZVBvaW50T3B0cyIsImN1cnZlIiwib3B0cyIsInZhbGlkYXRlT2JqZWN0IiwiYSIsImIiLCJhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMiLCJ3cmFwUHJpdmF0ZUtleSIsImlzVG9yc2lvbkZyZWUiLCJjbGVhckNvZmFjdG9yIiwiYWxsb3dJbmZpbml0eVBvaW50IiwiZnJvbUJ5dGVzIiwidG9CeXRlcyIsImVuZG8iLCJGcCIsImVxbCIsIlpFUk8iLCJFcnJvciIsImJldGEiLCJzcGxpdFNjYWxhciIsIk9iamVjdCIsImZyZWV6ZSIsImJ5dGVzVG9OdW1iZXJCRSIsImIybiIsImhleFRvQnl0ZXMiLCJoMmIiLCJERVIiLCJFcnIiLCJERVJFcnIiLCJjb25zdHJ1Y3RvciIsIm0iLCJfcGFyc2VJbnQiLCJkYXRhIiwiRSIsImxlbmd0aCIsImxlbiIsInJlcyIsInN1YmFycmF5IiwiZCIsImwiLCJ0b1NpZyIsImhleCIsImFieXRlcyIsInIiLCJzQnl0ZXMiLCJzIiwickJ5dGVzTGVmdCIsImhleEZyb21TaWciLCJzaWciLCJzbGljZSIsIk51bWJlciIsInBhcnNlSW50IiwiaCIsIm51bSIsInRvU3RyaW5nIiwic2hsIiwicmhsIiwic2wiLCJybCIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl8zbiIsIl80biIsIndlaWVyc3RyYXNzUG9pbnRzIiwiQ1VSVkUiLCJfYyIsInBvaW50IiwiX2lzQ29tcHJlc3NlZCIsInRvQWZmaW5lIiwiY29uY2F0Qnl0ZXMiLCJVaW50OEFycmF5IiwiZnJvbSIsIngiLCJ5IiwiYnl0ZXMiLCJ0YWlsIiwiQllURVMiLCJ3ZWllcnN0cmFzc0VxdWF0aW9uIiwieDIiLCJzcXIiLCJ4MyIsIm11bCIsImFkZCIsIkd5IiwiR3giLCJpc1dpdGhpbkN1cnZlT3JkZXIiLCJuIiwiYXNzZXJ0R0UiLCJub3JtUHJpdmF0ZUtleVRvU2NhbGFyIiwia2V5IiwibGVuZ3RocyIsIm5CeXRlTGVuZ3RoIiwiaXNCeXRlcyIsImJ5dGVzVG9IZXgiLCJpbmNsdWRlcyIsInBhZFN0YXJ0IiwiZXJyb3IiLCJwb2ludFByZWNvbXB1dGVzIiwiTWFwIiwiYXNzZXJ0UHJqUG9pbnQiLCJvdGhlciIsIlBvaW50IiwicHgiLCJweSIsInB6IiwiaXNWYWxpZCIsImZyb21BZmZpbmUiLCJwIiwiaXMwIiwiaSIsIk9ORSIsIm5vcm1hbGl6ZVoiLCJwb2ludHMiLCJ0b0ludiIsImludmVydEJhdGNoIiwibWFwIiwiZnJvbUhleCIsIlAiLCJhc3NlcnRWYWxpZGl0eSIsImZyb21Qcml2YXRlS2V5IiwicHJpdmF0ZUtleSIsIkJBU0UiLCJtdWx0aXBseSIsIl9zZXRXaW5kb3dTaXplIiwid2luZG93U2l6ZSIsIl9XSU5ET1dfU0laRSIsImRlbGV0ZSIsImxlZnQiLCJyaWdodCIsImhhc0V2ZW5ZIiwiaXNPZGQiLCJlcXVhbHMiLCJYMSIsIlkxIiwiWjEiLCJYMiIsIlkyIiwiWjIiLCJVMSIsIlUyIiwibmVnYXRlIiwibmVnIiwiZG91YmxlIiwiYjMiLCJYMyIsIlkzIiwiWjMiLCJ0MCIsInQxIiwidDIiLCJ0MyIsInN1YiIsInQ0IiwidDUiLCJzdWJ0cmFjdCIsInduYWYiLCJ3TkFGQ2FjaGVkIiwiY29tcCIsIm11bHRpcGx5VW5zYWZlIiwiSSIsInVuc2FmZUxhZGRlciIsImsxbmVnIiwiazEiLCJrMm5lZyIsImsyIiwiazFwIiwiazJwIiwic2NhbGFyIiwiZmFrZSIsImYiLCJmMXAiLCJmMnAiLCJjb25zdFRpbWVOZWdhdGUiLCJtdWx0aXBseUFuZEFkZFVuc2FmZSIsIlEiLCJHIiwic3VtIiwidW5kZWZpbmVkIiwiaXoiLCJ6IiwiaW52IiwiYXgiLCJheSIsInp6IiwiY29mYWN0b3IiLCJ0b1Jhd0J5dGVzIiwiaXNDb21wcmVzc2VkIiwidG9IZXgiLCJfYml0cyIsIm5CaXRMZW5ndGgiLCJNYXRoIiwiY2VpbCIsIlByb2plY3RpdmVQb2ludCIsInZhbGlkYXRlT3B0cyIsImhhc2giLCJobWFjIiwicmFuZG9tQnl0ZXMiLCJiaXRzMmludCIsImJpdHMyaW50X21vZE4iLCJsb3dTIiwid2VpZXJzdHJhc3MiLCJjdXJ2ZURlZiIsIkNVUlZFX09SREVSIiwiY29tcHJlc3NlZExlbiIsInVuY29tcHJlc3NlZExlbiIsImlzVmFsaWRGaWVsZEVsZW1lbnQiLCJPUkRFUiIsIm1vZE4iLCJpbnZOIiwiaW52ZXJ0IiwiY2F0IiwiaGVhZCIsInkyIiwic3FydCIsInNxcnRFcnJvciIsInN1ZmZpeCIsIm1lc3NhZ2UiLCJpc1lPZGQiLCJpc0hlYWRPZGQiLCJudW1Ub05CeXRlU3RyIiwibnVtYmVyVG9CeXRlc0JFIiwiaXNCaWdnZXJUaGFuSGFsZk9yZGVyIiwibnVtYmVyIiwiSEFMRiIsIm5vcm1hbGl6ZVMiLCJzbGNOdW0iLCJ0byIsIlNpZ25hdHVyZSIsInJlY292ZXJ5IiwiZnJvbUNvbXBhY3QiLCJmcm9tREVSIiwiYWRkUmVjb3ZlcnlCaXQiLCJyZWNvdmVyUHVibGljS2V5IiwibXNnSGFzaCIsInJlYyIsInJhZGoiLCJwcmVmaXgiLCJSIiwiaXIiLCJ1MSIsInUyIiwiaGFzSGlnaFMiLCJ0b0RFUlJhd0J5dGVzIiwidG9ERVJIZXgiLCJ0b0NvbXBhY3RSYXdCeXRlcyIsInRvQ29tcGFjdEhleCIsInV0aWxzIiwiaXNWYWxpZFByaXZhdGVLZXkiLCJyYW5kb21Qcml2YXRlS2V5IiwiZ2V0TWluSGFzaExlbmd0aCIsIm1hcEhhc2hUb0ZpZWxkIiwicHJlY29tcHV0ZSIsImdldFB1YmxpY0tleSIsImlzUHJvYlB1YiIsIml0ZW0iLCJhcnIiLCJzdHIiLCJnZXRTaGFyZWRTZWNyZXQiLCJwcml2YXRlQSIsInB1YmxpY0IiLCJkZWx0YSIsIk9SREVSX01BU0siLCJiaXRNYXNrIiwiaW50Mm9jdGV0cyIsInByZXBTaWciLCJkZWZhdWx0U2lnT3B0cyIsInNvbWUiLCJrIiwicHJlaGFzaCIsImV4dHJhRW50cm9weSIsImVudCIsImgxaW50Iiwic2VlZEFyZ3MiLCJlIiwicHVzaCIsInNlZWQiLCJrMnNpZyIsImtCeXRlcyIsImlrIiwicSIsIm5vcm1TIiwiZGVmYXVsdFZlck9wdHMiLCJzaWduIiwicHJpdktleSIsIkMiLCJkcmJnIiwiY3JlYXRlSG1hY0RyYmciLCJvdXRwdXRMZW4iLCJ2ZXJpZnkiLCJzaWduYXR1cmUiLCJwdWJsaWNLZXkiLCJzZyIsIl9zaWciLCJkZXJFcnJvciIsImlzIiwidiIsIlNXVUZwU3FydFJhdGlvIiwiWiIsIm8iLCJjMSIsIl8ybl9wb3dfYzFfMSIsIl8ybl9wb3dfYzEiLCJjMiIsImMzIiwiYzQiLCJjNSIsImM2IiwicG93IiwiYzciLCJzcXJ0UmF0aW8iLCJ1IiwidHYxIiwidHYyIiwidHYzIiwidHY1IiwidHY0IiwiaXNRUiIsImNtb3YiLCJ0dnY1IiwiZTEiLCJ2YWx1ZSIsInkxIiwibWFwVG9DdXJ2ZVNpbXBsZVNXVSIsInZhbGlkYXRlRmllbGQiLCJBIiwiQiIsInR2NiIsImRpdiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/@noble/curves/esm/abstract/weierstrass.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/@noble/curves/esm/ed25519.js":
/*!****************************************************!*\
  !*** ../node_modules/@noble/curves/esm/ed25519.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ED25519_TORSION_SUBGROUP: () => (/* binding */ ED25519_TORSION_SUBGROUP),\n/* harmony export */   RistrettoPoint: () => (/* binding */ RistrettoPoint),\n/* harmony export */   ed25519: () => (/* binding */ ed25519),\n/* harmony export */   ed25519ctx: () => (/* binding */ ed25519ctx),\n/* harmony export */   ed25519ph: () => (/* binding */ ed25519ph),\n/* harmony export */   edwardsToMontgomery: () => (/* binding */ edwardsToMontgomery),\n/* harmony export */   edwardsToMontgomeryPriv: () => (/* binding */ edwardsToMontgomeryPriv),\n/* harmony export */   edwardsToMontgomeryPub: () => (/* binding */ edwardsToMontgomeryPub),\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   hashToRistretto255: () => (/* binding */ hashToRistretto255),\n/* harmony export */   hash_to_ristretto255: () => (/* binding */ hash_to_ristretto255),\n/* harmony export */   x25519: () => (/* binding */ x25519)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"(rsc)/../node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/utils */ \"(rsc)/../node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/edwards.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/edwards.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/montgomery.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/montgomery.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/utils.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\n/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n */ const ED25519_P = BigInt(\"57896044618658097711785492504343953926634992332820282019728792003956564819949\");\n// ‚àö(-1) aka ‚àö(a) aka 2^((p-1)/4)\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt(\"19681161376707505956807079304988542015446066515923890162744021073123829784752\");\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\nfunction ed25519_pow_2_252_3(x) {\n    // prettier-ignore\n    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n    const P = ED25519_P;\n    const x2 = x * x % P;\n    const b2 = x2 * x % P; // x^3, 11\n    const b4 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b2, _2n, P) * b2 % P; // x^15, 1111\n    const b5 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b4, _1n, P) * x % P; // x^31\n    const b10 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b5, _5n, P) * b5 % P;\n    const b20 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b10, _10n, P) * b10 % P;\n    const b40 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b20, _20n, P) * b20 % P;\n    const b80 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b40, _40n, P) * b40 % P;\n    const b160 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b80, _80n, P) * b80 % P;\n    const b240 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b160, _80n, P) * b80 % P;\n    const b250 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b240, _10n, P) * b10 % P;\n    const pow_p_5_8 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b250, _2n, P) * x % P;\n    // ^ To pow to (p+3)/8, multiply it by x.\n    return {\n        pow_p_5_8,\n        b2\n    };\n}\nfunction adjustScalarBytes(bytes) {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 127; // 0b0111_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n}\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n    const P = ED25519_P;\n    const v3 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * v * v, P); // v¬≥\n    const v7 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v3 * v3 * v, P); // v‚Å∑\n    // (p+3)/8 and (p-5)/8\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(u * v3 * pow, P); // (uv¬≥)(uv‚Å∑)^(p-5)/8\n    const vx2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * x * x, P); // vx¬≤\n    const root1 = x; // First root candidate\n    const root2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x * ED25519_SQRT_M1, P); // Second root candidate\n    const useRoot1 = vx2 === u; // If vx¬≤ = u (mod p), x is a square root\n    const useRoot2 = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u, P); // If vx¬≤ = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx¬≤ = -u‚àö(-1)\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n    if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P)) x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-x, P);\n    return {\n        isValid: useRoot1 || useRoot2,\n        value: x\n    };\n}\n// Just in case\nconst ED25519_TORSION_SUBGROUP = [\n    \"0100000000000000000000000000000000000000000000000000000000000000\",\n    \"c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a\",\n    \"0000000000000000000000000000000000000000000000000000000000000080\",\n    \"26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05\",\n    \"ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f\",\n    \"26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85\",\n    \"0000000000000000000000000000000000000000000000000000000000000000\",\n    \"c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa\"\n];\nconst Fp = /* @__PURE__ */ (()=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(ED25519_P, undefined, true))();\nconst ed25519Defaults = /* @__PURE__ */ (()=>({\n        // Param: a\n        a: BigInt(-1),\n        // d is equal to -121665/121666 over finite field.\n        // Negative number is P - number, and division is invert(number, P)\n        d: BigInt(\"37095705934669439343138083508754565189542113879843219016388785533085940283555\"),\n        // Finite field ùîΩp over which we'll do calculations; 2n**255n - 19n\n        Fp,\n        // Subgroup order: how many points curve has\n        // 2n**252n + 27742317777372353535851937790883648493n;\n        n: BigInt(\"7237005577332262213973186563042994240857116359379907606001950938285454250989\"),\n        // Cofactor\n        h: _8n,\n        // Base point (x, y) aka generator point\n        Gx: BigInt(\"15112221349535400772501151409588531511454012693041857206046113283949847762202\"),\n        Gy: BigInt(\"46316835694926478169428394003475163141307993866256225615783033603165251855960\"),\n        hash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512,\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.randomBytes,\n        adjustScalarBytes,\n        // dom2\n        // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n        // Constant-time, u/‚àöv\n        uvRatio\n    }))();\nconst ed25519 = /* @__PURE__ */ (()=>(0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)(ed25519Defaults))();\nfunction ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255) throw new Error(\"Context is too big\");\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.concatBytes)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.utf8ToBytes)(\"SigEd25519 no Ed25519 collisions\"), new Uint8Array([\n        phflag ? 1 : 0,\n        ctx.length\n    ]), ctx, data);\n}\nconst ed25519ctx = /* @__PURE__ */ (()=>(0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)({\n        ...ed25519Defaults,\n        domain: ed25519_domain\n    }))();\nconst ed25519ph = /* @__PURE__ */ (()=>(0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)(Object.assign({}, ed25519Defaults, {\n        domain: ed25519_domain,\n        prehash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512\n    })))();\nconst x25519 = /* @__PURE__ */ (()=>(0,_abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__.montgomery)({\n        P: ED25519_P,\n        a: BigInt(486662),\n        montgomeryBits: 255,\n        nByteLength: 32,\n        Gu: BigInt(9),\n        powPminus2: (x)=>{\n            const P = ED25519_P;\n            // x^(p-2) aka x^(2^255-21)\n            const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n            return (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(pow_p_5_8, _3n, P) * b2, P);\n        },\n        adjustScalarBytes,\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.randomBytes\n    }))();\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */ function edwardsToMontgomeryPub(edwardsPub) {\n    const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n    const _1n = BigInt(1);\n    return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nconst edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */ function edwardsToMontgomeryPriv(edwardsPriv) {\n    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = /* @__PURE__ */ (()=>(Fp.ORDER + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (()=>Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (()=>Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u) {\n    const ELL2_C4 = (Fp.ORDER - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n    const ELL2_J = BigInt(486662);\n    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n    return {\n        xMn: xn,\n        xMd: xd,\n        yMn: y,\n        yMd: _1n\n    }; //  39. return (xn, xd, y, 1)\n}\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (()=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n    // map_to_curve_elligator2_curve25519(u)\n    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n    const inv = Fp.invertBatch([\n        xd,\n        yd\n    ]); // batch division\n    return {\n        x: Fp.mul(xn, inv[0]),\n        y: Fp.mul(yn, inv[1])\n    }; //  13. return (xn, xd, yn, yd)\n}\nconst htf = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(ed25519.ExtendedPoint, (scalars)=>map_to_curve_elligator2_edwards25519(scalars[0]), {\n        DST: \"edwards25519_XMD:SHA-512_ELL2_RO_\",\n        encodeDST: \"edwards25519_XMD:SHA-512_ELL2_NU_\",\n        p: Fp.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512\n    }))();\nconst hashToCurve = /* @__PURE__ */ (()=>htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (()=>htf.encodeToCurve)();\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistPoint)) throw new Error(\"RistrettoPoint expected\");\n}\n// ‚àö(-1) aka ‚àö(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// ‚àö(ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt(\"25063068953384623474111414158702152701244531502492656460079210482610430750235\");\n// 1 / ‚àö(a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt(\"54469307008909316920995813868745141605393597292927456921205312896311721017578\");\n// 1-d¬≤\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt(\"1159843021668779879193775521855586647937357759715417654439879720876111806838\");\n// (d-1)¬≤\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt(\"40440834346308536858101042469323190826248399146238708352240133220865137265952\");\n// Calculates 1/‚àö(number)\nconst invertSqrt = (number)=>uvRatio(_1n, number);\nconst MAX_255B = /* @__PURE__ */ BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nconst bytes255ToNumberLE = (bytes)=>ed25519.CURVE.Fp.create((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToNumberLE)(bytes) & MAX_255B);\n// Computes Elligator map for Ristretto\n// https://ristretto.group/formulas/elligator.html\nfunction calcElligatorRistrettoMap(r0) {\n    const { d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const r = mod(SQRT_M1 * r0 * r0); // 1\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n    let c = BigInt(-1); // 3\n    const D = mod((c - d * r) * mod(r + d)); // 4\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n    let s_ = mod(s * r0); // 6\n    if (!(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s_, P)) s_ = mod(-s_);\n    if (!Ns_D_is_sq) s = s_; // 7\n    if (!Ns_D_is_sq) c = r; // 8\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n    const s2 = s * s;\n    const W0 = mod((s + s) * D); // 10\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n    const W2 = mod(_1n - s2); // 12\n    const W3 = mod(_1n + s2); // 13\n    return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448\n */ class RistPoint {\n    // Private property to discourage combining ExtendedPoint + RistrettoPoint\n    // Always use Ristretto encoding/decoding instead.\n    constructor(ep){\n        this.ep = ep;\n    }\n    static fromAffine(ap) {\n        return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n    }\n    /**\n     * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n     * The hash-to-group operation applies Elligator twice and adds the results.\n     * **Note:** this is one-way map, there is no conversion from point to hash.\n     * https://ristretto.group/formulas/elligator.html\n     * @param hex 64-byte output of a hash function\n     */ static hashToCurve(hex) {\n        hex = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)(\"ristrettoHash\", hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = calcElligatorRistrettoMap(r2);\n        return new RistPoint(R1.add(R2));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * https://ristretto.group/formulas/decoding.html\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */ static fromHex(hex) {\n        hex = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)(\"ristrettoHex\", hex, 32);\n        const { a, d } = ed25519.CURVE;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const emsg = \"RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint\";\n        const s = bytes255ToNumberLE(hex);\n        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n        // 3. Check that s is non-negative, or else abort\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.equalBytes)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.numberToBytesLE)(s, 32), hex) || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P)) throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n        const u2 = mod(_1n - a * s2); // 5\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2); // 6\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n        const Dx = mod(I * u2); // 8\n        const Dy = mod(I * Dx * v); // 9\n        let x = mod((s + s) * Dx); // 10\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P)) x = mod(-x); // 10\n        const y = mod(u1 * Dy); // 11\n        const t = mod(x * y); // 12\n        if (!isValid || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(t, P) || y === _0n) throw new Error(emsg);\n        return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * https://ristretto.group/formulas/encoding.html\n     */ toRawBytes() {\n        let { ex: x, ey: y, ez: z, et: t } = this.ep;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const u1 = mod(mod(z + y) * mod(z - y)); // 1\n        const u2 = mod(x * y); // 2\n        // Square root always exists\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n        const D1 = mod(invsqrt * u1); // 4\n        const D2 = mod(invsqrt * u2); // 5\n        const zInv = mod(D1 * D2 * t); // 6\n        let D; // 7\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(t * zInv, P)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        } else {\n            D = D2; // 8\n        }\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x * zInv, P)) y = mod(-y); // 9\n        let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P)) s = mod(-s);\n        return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.numberToBytesLE)(s, 32); // 11\n    }\n    toHex() {\n        return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    // Compare one point to another.\n    equals(other) {\n        assertRstPoint(other);\n        const { ex: X1, ey: Y1 } = this.ep;\n        const { ex: X2, ey: Y2 } = other.ep;\n        const mod = ed25519.CURVE.Fp.create;\n        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n        const one = mod(X1 * Y2) === mod(Y1 * X2);\n        const two = mod(Y1 * Y2) === mod(X1 * X2);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistPoint(this.ep.multiplyUnsafe(scalar));\n    }\n    double() {\n        return new RistPoint(this.ep.double());\n    }\n    negate() {\n        return new RistPoint(this.ep.negate());\n    }\n}\nconst RistrettoPoint = /* @__PURE__ */ (()=>{\n    if (!RistPoint.BASE) RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n    if (!RistPoint.ZERO) RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n    return RistPoint;\n})();\n// Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B\nconst hashToRistretto255 = (msg, options)=>{\n    const d = options.DST;\n    const DST = typeof d === \"string\" ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.utf8ToBytes)(d) : d;\n    const uniform_bytes = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.expand_message_xmd)(msg, DST, 64, _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512);\n    const P = RistPoint.hashToCurve(uniform_bytes);\n    return P;\n};\nconst hash_to_ristretto255 = hashToRistretto255; // legacy\n //# sourceMappingURL=ed25519.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2VkMjU1MTkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDdEI7QUFDOEI7QUFDckI7QUFDd0I7QUFDSTtBQUM3QjtBQUN1RDtBQUM3Rzs7Ozs7Q0FLQyxHQUNELE1BQU1rQixZQUFZQyxPQUFPO0FBQ3pCLGlDQUFpQztBQUNqQyxNQUFNQyxrQkFBa0IsYUFBYSxHQUFHRCxPQUFPO0FBQy9DLGtCQUFrQjtBQUNsQixNQUFNRSxNQUFNRixPQUFPLElBQUlHLE1BQU1ILE9BQU8sSUFBSUksTUFBTUosT0FBTyxJQUFJSyxNQUFNTCxPQUFPO0FBQ3RFLGtCQUFrQjtBQUNsQixNQUFNTSxNQUFNTixPQUFPLElBQUlPLE1BQU1QLE9BQU87QUFDcEMsU0FBU1Esb0JBQW9CQyxDQUFDO0lBQzFCLGtCQUFrQjtJQUNsQixNQUFNQyxPQUFPVixPQUFPLEtBQUtXLE9BQU9YLE9BQU8sS0FBS1ksT0FBT1osT0FBTyxLQUFLYSxPQUFPYixPQUFPO0lBQzdFLE1BQU1jLElBQUlmO0lBQ1YsTUFBTWdCLEtBQUssSUFBS04sSUFBS0s7SUFDckIsTUFBTUUsS0FBSyxLQUFNUCxJQUFLSyxHQUFHLFVBQVU7SUFDbkMsTUFBTUcsS0FBSywyREFBTUQsSUFBSVosS0FBS1UsS0FBS0UsS0FBTUYsR0FBRyxhQUFhO0lBQ3JELE1BQU1JLEtBQUssMkRBQU1ELElBQUlkLEtBQUtXLEtBQUtMLElBQUtLLEdBQUcsT0FBTztJQUM5QyxNQUFNSyxNQUFNLDJEQUFNRCxJQUFJWixLQUFLUSxLQUFLSSxLQUFNSjtJQUN0QyxNQUFNTSxNQUFNLDJEQUFNRCxLQUFLVCxNQUFNSSxLQUFLSyxNQUFPTDtJQUN6QyxNQUFNTyxNQUFNLDJEQUFNRCxLQUFLVCxNQUFNRyxLQUFLTSxNQUFPTjtJQUN6QyxNQUFNUSxNQUFNLDJEQUFNRCxLQUFLVCxNQUFNRSxLQUFLTyxNQUFPUDtJQUN6QyxN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LElBQUk7SUFDN0QsSUFBSSxDQUFDMUUsVUFBVWQsSUFBSSxFQUNmYyxVQUFVZCxJQUFJLEdBQUcsSUFBSWMsVUFBVTVGLFFBQVFzQixhQUFhLENBQUN3RCxJQUFJO0lBQzdELE9BQU9jO0FBQ1gsS0FBSztBQUNMLDZFQUE2RTtBQUN0RSxNQUFNMkUscUJBQXFCLENBQUNDLEtBQUtDO0lBQ3BDLE1BQU0vSyxJQUFJK0ssUUFBUXZGLEdBQUc7SUFDckIsTUFBTUEsTUFBTSxPQUFPeEYsTUFBTSxXQUFXaEUsZ0VBQVdBLENBQUNnRSxLQUFLQTtJQUNyRCxNQUFNZ0wsZ0JBQWdCN08sOEVBQWtCQSxDQUFDMk8sS0FBS3RGLEtBQUssSUFBSTNKLHdEQUFNQTtJQUM3RCxNQUFNaUMsSUFBSW9JLFVBQVVKLFdBQVcsQ0FBQ2tGO0lBQ2hDLE9BQU9sTjtBQUNYLEVBQUU7QUFDSyxNQUFNbU4sdUJBQXVCSixtQkFBbUIsQ0FBQyxTQUFTO0NBQ2pFLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vZWQyNTUxOS5qcz8zOGUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTUxMiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhNTEyJztcbmltcG9ydCB7IGNvbmNhdEJ5dGVzLCByYW5kb21CeXRlcywgdXRmOFRvQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IHR3aXN0ZWRFZHdhcmRzIH0gZnJvbSAnLi9hYnN0cmFjdC9lZHdhcmRzLmpzJztcbmltcG9ydCB7IGNyZWF0ZUhhc2hlciwgZXhwYW5kX21lc3NhZ2VfeG1kIH0gZnJvbSAnLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzJztcbmltcG9ydCB7IEZpZWxkLCBGcFNxcnRFdmVuLCBpc05lZ2F0aXZlTEUsIG1vZCwgcG93MiB9IGZyb20gJy4vYWJzdHJhY3QvbW9kdWxhci5qcyc7XG5pbXBvcnQgeyBtb250Z29tZXJ5IH0gZnJvbSAnLi9hYnN0cmFjdC9tb250Z29tZXJ5LmpzJztcbmltcG9ydCB7IGJ5dGVzVG9IZXgsIGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIGVxdWFsQnl0ZXMsIG51bWJlclRvQnl0ZXNMRSwgfSBmcm9tICcuL2Fic3RyYWN0L3V0aWxzLmpzJztcbi8qKlxuICogZWQyNTUxOSBUd2lzdGVkIEVkd2FyZHMgY3VydmUgd2l0aCBmb2xsb3dpbmcgYWRkb25zOlxuICogLSBYMjU1MTkgRUNESFxuICogLSBSaXN0cmV0dG8gY29mYWN0b3IgZWxpbWluYXRpb25cbiAqIC0gRWxsaWdhdG9yIGhhc2gtdG8tZ3JvdXAgLyBwb2ludCBpbmRpc3Rpbmd1aXNoYWJpbGl0eVxuICovXG5jb25zdCBFRDI1NTE5X1AgPSBCaWdJbnQoJzU3ODk2MDQ0NjE4NjU4MDk3NzExNzg1NDkyNTA0MzQzOTUzOTI2NjM0OTkyMzMyODIwMjgyMDE5NzI4NzkyMDAzOTU2NTY0ODE5OTQ5Jyk7XG4vLyDiiJooLTEpIGFrYSDiiJooYSkgYWthIDJeKChwLTEpLzQpXG5jb25zdCBFRDI1NTE5X1NRUlRfTTEgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCcxOTY4MTE2MTM3NjcwNzUwNTk1NjgwNzA3OTMwNDk4ODU0MjAxNTQ0NjA2NjUxNTkyMzg5MDE2Mjc0NDAyMTA3MzEyMzgyOTc4NDc1MicpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF81biA9IEJpZ0ludCg1KSwgXzhuID0gQmlnSW50KDgpO1xuZnVuY3Rpb24gZWQyNTUxOV9wb3dfMl8yNTJfMyh4KSB7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzEwbiA9IEJpZ0ludCgxMCksIF8yMG4gPSBCaWdJbnQoMjApLCBfNDBuID0gQmlnSW50KDQwKSwgXzgwbiA9IEJpZ0ludCg4MCk7XG4gICAgY29uc3QgUCA9IEVEMjU1MTlfUDtcbiAgICBjb25zdCB4MiA9ICh4ICogeCkgJSBQO1xuICAgIGNvbnN0IGIyID0gKHgyICogeCkgJSBQOyAvLyB4XjMsIDExXG4gICAgY29uc3QgYjQgPSAocG93MihiMiwgXzJuLCBQKSAqIGIyKSAlIFA7IC8vIHheMTUsIDExMTFcbiAgICBjb25zdCBiNSA9IChwb3cyKGI0LCBfMW4sIFApICogeCkgJSBQOyAvLyB4XjMxXG4gICAgY29uc3QgYjEwID0gKHBvdzIoYjUsIF81biwgUCkgKiBiNSkgJSBQO1xuICAgIGNvbnN0IGIyMCA9IChwb3cyKGIxMCwgXzEwbiwgUCkgKiBiMTApICUgUDtcbiAgICBjb25zdCBiNDAgPSAocG93MihiMjAsIF8yMG4sIFApICogYjIwKSAlIFA7XG4gICAgY29uc3QgYjgwID0gKHBvdzIoYjQwLCBfNDBuLCBQKSAqIGI0MCkgJSBQO1xuICAgIGNvbnN0IGIxNjAgPSAocG93MihiODAsIF84MG4sIFApICogYjgwKSAlIFA7XG4gICAgY29uc3QgYjI0MCA9IChwb3cyKGIxNjAsIF84MG4sIFApICogYjgwKSAlIFA7XG4gICAgY29uc3QgYjI1MCA9IChwb3cyKGIyNDAsIF8xMG4sIFApICogYjEwKSAlIFA7XG4gICAgY29uc3QgcG93X3BfNV84ID0gKHBvdzIoYjI1MCwgXzJuLCBQKSAqIHgpICUgUDtcbiAgICAvLyBeIFRvIHBvdyB0byAocCszKS84LCBtdWx0aXBseSBpdCBieSB4LlxuICAgIHJldHVybiB7IHBvd19wXzVfOCwgYjIgfTtcbn1cbmZ1bmN0aW9uIGFkanVzdFNjYWxhckJ5dGVzKGJ5dGVzKSB7XG4gICAgLy8gU2VjdGlvbiA1OiBGb3IgWDI1NTE5LCBpbiBvcmRlciB0byBkZWNvZGUgMzIgcmFuZG9tIGJ5dGVzIGFzIGFuIGludGVnZXIgc2NhbGFyLFxuICAgIC8vIHNldCB0aGUgdGhyZWUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyBvZiB0aGUgZmlyc3QgYnl0ZVxuICAgIGJ5dGVzWzBdICY9IDI0ODsgLy8gMGIxMTExXzEwMDBcbiAgICAvLyBhbmQgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBsYXN0IHRvIHplcm8sXG4gICAgYnl0ZXNbMzFdICY9IDEyNzsgLy8gMGIwMTExXzExMTFcbiAgICAvLyBzZXQgdGhlIHNlY29uZCBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgbGFzdCBieXRlIHRvIDFcbiAgICBieXRlc1szMV0gfD0gNjQ7IC8vIDBiMDEwMF8wMDAwXG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLy8gc3FydCh1L3YpXG5mdW5jdGlvbiB1dlJhdGlvKHUsIHYpIHtcbiAgICBjb25zdCBQID0gRUQyNTUxOV9QO1xuICAgIGNvbnN0IHYzID0gbW9kKHYgKiB2ICogdiwgUCk7IC8vIHbCs1xuICAgIGNvbnN0IHY3ID0gbW9kKHYzICogdjMgKiB2LCBQKTsgLy8gduKBt1xuICAgIC8vIChwKzMpLzggYW5kIChwLTUpLzhcbiAgICBjb25zdCBwb3cgPSBlZDI1NTE5X3Bvd18yXzI1Ml8zKHUgKiB2NykucG93X3BfNV84O1xuICAgIGxldCB4ID0gbW9kKHUgKiB2MyAqIHBvdywgUCk7IC8vICh1dsKzKSh1duKBtyleKHAtNSkvOFxuICAgIGNvbnN0IHZ4MiA9IG1vZCh2ICogeCAqIHgsIFApOyAvLyB2eMKyXG4gICAgY29uc3Qgcm9vdDEgPSB4OyAvLyBGaXJzdCByb290IGNhbmRpZGF0ZVxuICAgIGNvbnN0IHJvb3QyID0gbW9kKHggKiBFRDI1NTE5X1NRUlRfTTEsIFApOyAvLyBTZWNvbmQgcm9vdCBjYW5kaWRhdGVcbiAgICBjb25zdCB1c2VSb290MSA9IHZ4MiA9PT0gdTsgLy8gSWYgdnjCsiA9IHUgKG1vZCBwKSwgeCBpcyBhIHNxdWFyZSByb290XG4gICAgY29uc3QgdXNlUm9vdDIgPSB2eDIgPT09IG1vZCgtdSwgUCk7IC8vIElmIHZ4wrIgPSAtdSwgc2V0IHggPC0tIHggKiAyXigocC0xKS80KVxuICAgIGNvbnN0IG5vUm9vdCA9IHZ4MiA9PT0gbW9kKC11ICogRUQyNTUxOV9TUVJUX00xLCBQKTsgLy8gVGhlcmUgaXMgbm8gdmFsaWQgcm9vdCwgdnjCsiA9IC114oiaKC0xKVxuICAgIGlmICh1c2VSb290MSlcbiAgICAgICAgeCA9IHJvb3QxO1xuICAgIGlmICh1c2VSb290MiB8fCBub1Jvb3QpXG4gICAgICAgIHggPSByb290MjsgLy8gV2UgcmV0dXJuIHJvb3QyIGFueXdheSwgZm9yIGNvbnN0LXRpbWVcbiAgICBpZiAoaXNOZWdhdGl2ZUxFKHgsIFApKVxuICAgICAgICB4ID0gbW9kKC14LCBQKTtcbiAgICByZXR1cm4geyBpc1ZhbGlkOiB1c2VSb290MSB8fCB1c2VSb290MiwgdmFsdWU6IHggfTtcbn1cbi8vIEp1c3QgaW4gY2FzZVxuZXhwb3J0IGNvbnN0IEVEMjU1MTlfVE9SU0lPTl9TVUJHUk9VUCA9IFtcbiAgICAnMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ2M3MTc2YTcwM2Q0ZGQ4NGZiYTNjMGI3NjBkMTA2NzBmMmEyMDUzZmEyYzM5Y2NjNjRlYzdmZDc3OTJhYzAzN2EnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgwJyxcbiAgICAnMjZlODk1OGZjMmIyMjdiMDQ1YzNmNDg5ZjJlZjk4ZjBkNWRmYWMwNWQzYzYzMzM5YjEzODAyODg2ZDUzZmMwNScsXG4gICAgJ2VjZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmN2YnLFxuICAgICcyNmU4OTU4ZmMyYjIyN2IwNDVjM2Y0ODlmMmVmOThmMGQ1ZGZhYzA1ZDNjNjMzMzliMTM4MDI4ODZkNTNmYzg1JyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ2M3MTc2YTcwM2Q0ZGQ4NGZiYTNjMGI3NjBkMTA2NzBmMmEyMDUzZmEyYzM5Y2NjNjRlYzdmZDc3OTJhYzAzZmEnLFxuXTtcbmNvbnN0IEZwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBGaWVsZChFRDI1NTE5X1AsIHVuZGVmaW5lZCwgdHJ1ZSkpKCk7XG5jb25zdCBlZDI1NTE5RGVmYXVsdHMgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgLy8gUGFyYW06IGFcbiAgICBhOiBCaWdJbnQoLTEpLCAvLyBGcC5jcmVhdGUoLTEpIGlzIHByb3Blcjsgb3VyIHdheSBzdGlsbCB3b3JrcyBhbmQgaXMgZmFzdGVyXG4gICAgLy8gZCBpcyBlcXVhbCB0byAtMTIxNjY1LzEyMTY2NiBvdmVyIGZpbml0ZSBmaWVsZC5cbiAgICAvLyBOZWdhdGl2ZSBudW1iZXIgaXMgUCAtIG51bWJlciwgYW5kIGRpdmlzaW9uIGlzIGludmVydChudW1iZXIsIFApXG4gICAgZDogQmlnSW50KCczNzA5NTcwNTkzNDY2OTQzOTM0MzEzODA4MzUwODc1NDU2NTE4OTU0MjExMzg3OTg0MzIxOTAxNjM4ODc4NTUzMzA4NTk0MDI4MzU1NScpLFxuICAgIC8vIEZpbml0ZSBmaWVsZCDwnZS9cCBvdmVyIHdoaWNoIHdlJ2xsIGRvIGNhbGN1bGF0aW9uczsgMm4qKjI1NW4gLSAxOW5cbiAgICBGcCxcbiAgICAvLyBTdWJncm91cCBvcmRlcjogaG93IG1hbnkgcG9pbnRzIGN1cnZlIGhhc1xuICAgIC8vIDJuKioyNTJuICsgMjc3NDIzMTc3NzczNzIzNTM1MzU4NTE5Mzc3OTA4ODM2NDg0OTNuO1xuICAgIG46IEJpZ0ludCgnNzIzNzAwNTU3NzMzMjI2MjIxMzk3MzE4NjU2MzA0Mjk5NDI0MDg1NzExNjM1OTM3OTkwNzYwNjAwMTk1MDkzODI4NTQ1NDI1MDk4OScpLFxuICAgIC8vIENvZmFjdG9yXG4gICAgaDogXzhuLFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCcxNTExMjIyMTM0OTUzNTQwMDc3MjUwMTE1MTQwOTU4ODUzMTUxMTQ1NDAxMjY5MzA0MTg1NzIwNjA0NjExMzI4Mzk0OTg0Nzc2MjIwMicpLFxuICAgIEd5OiBCaWdJbnQoJzQ2MzE2ODM1Njk0OTI2NDc4MTY5NDI4Mzk0MDAzNDc1MTYzMTQxMzA3OTkzODY2MjU2MjI1NjE1NzgzMDMzNjAzMTY1MjUxODU1OTYwJyksXG4gICAgaGFzaDogc2hhNTEyLFxuICAgIHJhbmRvbUJ5dGVzLFxuICAgIGFkanVzdFNjYWxhckJ5dGVzLFxuICAgIC8vIGRvbTJcbiAgICAvLyBSYXRpbyBvZiB1IHRvIHYuIEFsbG93cyB1cyB0byBjb21iaW5lIGludmVyc2lvbiBhbmQgc3F1YXJlIHJvb3QuIFVzZXMgYWxnbyBmcm9tIFJGQzgwMzIgNS4xLjMuXG4gICAgLy8gQ29uc3RhbnQtdGltZSwgdS/iiJp2XG4gICAgdXZSYXRpbyxcbn0pKSgpO1xuZXhwb3J0IGNvbnN0IGVkMjU1MTkgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHR3aXN0ZWRFZHdhcmRzKGVkMjU1MTlEZWZhdWx0cykpKCk7XG5mdW5jdGlvbiBlZDI1NTE5X2RvbWFpbihkYXRhLCBjdHgsIHBoZmxhZykge1xuICAgIGlmIChjdHgubGVuZ3RoID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRleHQgaXMgdG9vIGJpZycpO1xuICAgIHJldHVybiBjb25jYXRCeXRlcyh1dGY4VG9CeXRlcygnU2lnRWQyNTUxOSBubyBFZDI1NTE5IGNvbGxpc2lvbnMnKSwgbmV3IFVpbnQ4QXJyYXkoW3BoZmxhZyA/IDEgOiAwLCBjdHgubGVuZ3RoXSksIGN0eCwgZGF0YSk7XG59XG5leHBvcnQgY29uc3QgZWQyNTUxOWN0eCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdHdpc3RlZEVkd2FyZHMoe1xuICAgIC4uLmVkMjU1MTlEZWZhdWx0cyxcbiAgICBkb21haW46IGVkMjU1MTlfZG9tYWluLFxufSkpKCk7XG5leHBvcnQgY29uc3QgZWQyNTUxOXBoID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB0d2lzdGVkRWR3YXJkcyhPYmplY3QuYXNzaWduKHt9LCBlZDI1NTE5RGVmYXVsdHMsIHtcbiAgICBkb21haW46IGVkMjU1MTlfZG9tYWluLFxuICAgIHByZWhhc2g6IHNoYTUxMixcbn0pKSkoKTtcbmV4cG9ydCBjb25zdCB4MjU1MTkgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1vbnRnb21lcnkoe1xuICAgIFA6IEVEMjU1MTlfUCxcbiAgICBhOiBCaWdJbnQoNDg2NjYyKSxcbiAgICBtb250Z29tZXJ5Qml0czogMjU1LCAvLyBuIGlzIDI1MyBiaXRzXG4gICAgbkJ5dGVMZW5ndGg6IDMyLFxuICAgIEd1OiBCaWdJbnQoOSksXG4gICAgcG93UG1pbnVzMjogKHgpID0+IHtcbiAgICAgICAgY29uc3QgUCA9IEVEMjU1MTlfUDtcbiAgICAgICAgLy8geF4ocC0yKSBha2EgeF4oMl4yNTUtMjEpXG4gICAgICAgIGNvbnN0IHsgcG93X3BfNV84LCBiMiB9ID0gZWQyNTUxOV9wb3dfMl8yNTJfMyh4KTtcbiAgICAgICAgcmV0dXJuIG1vZChwb3cyKHBvd19wXzVfOCwgXzNuLCBQKSAqIGIyLCBQKTtcbiAgICB9LFxuICAgIGFkanVzdFNjYWxhckJ5dGVzLFxuICAgIHJhbmRvbUJ5dGVzLFxufSkpKCk7XG4vKipcbiAqIENvbnZlcnRzIGVkMjU1MTkgcHVibGljIGtleSB0byB4MjU1MTkgcHVibGljIGtleS4gVXNlcyBmb3JtdWxhOlxuICogKiBgKHUsIHYpID0gKCgxK3kpLygxLXkpLCBzcXJ0KC00ODY2NjQpKnUveClgXG4gKiAqIGAoeCwgeSkgPSAoc3FydCgtNDg2NjY0KSp1L3YsICh1LTEpLyh1KzEpKWBcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IHNvbWVvbmVzUHViID0gZWQyNTUxOS5nZXRQdWJsaWNLZXkoZWQyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCkpO1xuICogICBjb25zdCBhUHJpdiA9IHgyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG4gKiAgIHgyNTUxOS5nZXRTaGFyZWRTZWNyZXQoYVByaXYsIGVkd2FyZHNUb01vbnRnb21lcnlQdWIoc29tZW9uZXNQdWIpKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWR3YXJkc1RvTW9udGdvbWVyeVB1YihlZHdhcmRzUHViKSB7XG4gICAgY29uc3QgeyB5IH0gPSBlZDI1NTE5LkV4dGVuZGVkUG9pbnQuZnJvbUhleChlZHdhcmRzUHViKTtcbiAgICBjb25zdCBfMW4gPSBCaWdJbnQoMSk7XG4gICAgcmV0dXJuIEZwLnRvQnl0ZXMoRnAuY3JlYXRlKChfMW4gKyB5KSAqIEZwLmludihfMW4gLSB5KSkpO1xufVxuZXhwb3J0IGNvbnN0IGVkd2FyZHNUb01vbnRnb21lcnkgPSBlZHdhcmRzVG9Nb250Z29tZXJ5UHViOyAvLyBkZXByZWNhdGVkXG4vKipcbiAqIENvbnZlcnRzIGVkMjU1MTkgc2VjcmV0IGtleSB0byB4MjU1MTkgc2VjcmV0IGtleS5cbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IHNvbWVvbmVzUHViID0geDI1NTE5LmdldFB1YmxpY0tleSh4MjU1MTkudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpKTtcbiAqICAgY29uc3QgYVByaXYgPSBlZDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAqICAgeDI1NTE5LmdldFNoYXJlZFNlY3JldChlZHdhcmRzVG9Nb250Z29tZXJ5UHJpdihhUHJpdiksIHNvbWVvbmVzUHViKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWR3YXJkc1RvTW9udGdvbWVyeVByaXYoZWR3YXJkc1ByaXYpIHtcbiAgICBjb25zdCBoYXNoZWQgPSBlZDI1NTE5RGVmYXVsdHMuaGFzaChlZHdhcmRzUHJpdi5zdWJhcnJheSgwLCAzMikpO1xuICAgIHJldHVybiBlZDI1NTE5RGVmYXVsdHMuYWRqdXN0U2NhbGFyQnl0ZXMoaGFzaGVkKS5zdWJhcnJheSgwLCAzMik7XG59XG4vLyBIYXNoIFRvIEN1cnZlIEVsbGlnYXRvcjIgTWFwIChOT1RFOiBkaWZmZXJlbnQgZnJvbSByaXN0cmV0dG8yNTUgZWxsaWdhdG9yKVxuLy8gTk9URTogdmVyeSBpbXBvcnRhbnQgcGFydCBpcyB1c2FnZSBvZiBGcFNxcnRFdmVuIGZvciBFTEwyX0MxX0VEV0FSRFMsIHNpbmNlXG4vLyBTYWdlTWF0aCByZXR1cm5zIGRpZmZlcmVudCByb290IGZpcnN0IGFuZCBldmVyeXRoaW5nIGZhbGxzIGFwYXJ0XG5jb25zdCBFTEwyX0MxID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoRnAuT1JERVIgKyBfM24pIC8gXzhuKSgpOyAvLyAxLiBjMSA9IChxICsgMykgLyA4ICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG5jb25zdCBFTEwyX0MyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBGcC5wb3coXzJuLCBFTEwyX0MxKSkoKTsgLy8gMi4gYzIgPSAyXmMxXG5jb25zdCBFTEwyX0MzID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBGcC5zcXJ0KEZwLm5lZyhGcC5PTkUpKSkoKTsgLy8gMy4gYzMgPSBzcXJ0KC0xKVxuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5KHUpIHtcbiAgICBjb25zdCBFTEwyX0M0ID0gKEZwLk9SREVSIC0gXzVuKSAvIF84bjsgLy8gNC4gYzQgPSAocSAtIDUpIC8gOCAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IEVMTDJfSiA9IEJpZ0ludCg0ODY2NjIpO1xuICAgIGxldCB0djEgPSBGcC5zcXIodSk7IC8vICAxLiAgdHYxID0gdV4yXG4gICAgdHYxID0gRnAubXVsKHR2MSwgXzJuKTsgLy8gIDIuICB0djEgPSAyICogdHYxXG4gICAgbGV0IHhkID0gRnAuYWRkKHR2MSwgRnAuT05FKTsgLy8gIDMuICAgeGQgPSB0djEgKyAxICAgICAgICAgIyBOb256ZXJvOiAtMSBpcyBzcXVhcmUgKG1vZCBwKSwgdHYxIGlzIG5vdFxuICAgIGxldCB4MW4gPSBGcC5uZWcoRUxMMl9KKTsgLy8gIDQuICB4MW4gPSAtSiAgICAgICAgICAgICAgIyB4MSA9IHgxbiAvIHhkID0gLUogLyAoMSArIDIgKiB1XjIpXG4gICAgbGV0IHR2MiA9IEZwLnNxcih4ZCk7IC8vICA1LiAgdHYyID0geGReMlxuICAgIGxldCBneGQgPSBGcC5tdWwodHYyLCB4ZCk7IC8vICA2LiAgZ3hkID0gdHYyICogeGQgICAgICAgICMgZ3hkID0geGReM1xuICAgIGxldCBneDEgPSBGcC5tdWwodHYxLCBFTEwyX0opOyAvLyAgNy4gIGd4MSA9IEogKiB0djEgICAgICAgICAjIHgxbiArIEogKiB4ZFxuICAgIGd4MSA9IEZwLm11bChneDEsIHgxbik7IC8vICA4LiAgZ3gxID0gZ3gxICogeDFuICAgICAgICMgeDFuXjIgKyBKICogeDFuICogeGRcbiAgICBneDEgPSBGcC5hZGQoZ3gxLCB0djIpOyAvLyAgOS4gIGd4MSA9IGd4MSArIHR2MiAgICAgICAjIHgxbl4yICsgSiAqIHgxbiAqIHhkICsgeGReMlxuICAgIGd4MSA9IEZwLm11bChneDEsIHgxbik7IC8vICAxMC4gZ3gxID0gZ3gxICogeDFuICAgICAgICMgeDFuXjMgKyBKICogeDFuXjIgKiB4ZCArIHgxbiAqIHhkXjJcbiAgICBsZXQgdHYzID0gRnAuc3FyKGd4ZCk7IC8vICAxMS4gdHYzID0gZ3hkXjJcbiAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gIDEyLiB0djIgPSB0djNeMiAgICAgICAgICAgIyBneGReNFxuICAgIHR2MyA9IEZwLm11bCh0djMsIGd4ZCk7IC8vICAxMy4gdHYzID0gdHYzICogZ3hkICAgICAgICMgZ3hkXjNcbiAgICB0djMgPSBGcC5tdWwodHYzLCBneDEpOyAvLyAgMTQuIHR2MyA9IHR2MyAqIGd4MSAgICAgICAjIGd4MSAqIGd4ZF4zXG4gICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgLy8gIDE1LiB0djIgPSB0djIgKiB0djMgICAgICAgIyBneDEgKiBneGReN1xuICAgIGxldCB5MTEgPSBGcC5wb3codHYyLCBFTEwyX0M0KTsgLy8gIDE2LiB5MTEgPSB0djJeYzQgICAgICAgICMgKGd4MSAqIGd4ZF43KV4oKHAgLSA1KSAvIDgpXG4gICAgeTExID0gRnAubXVsKHkxMSwgdHYzKTsgLy8gIDE3LiB5MTEgPSB5MTEgKiB0djMgICAgICAgIyBneDEqZ3hkXjMqKGd4MSpneGReNyleKChwLTUpLzgpXG4gICAgbGV0IHkxMiA9IEZwLm11bCh5MTEsIEVMTDJfQzMpOyAvLyAgMTguIHkxMiA9IHkxMSAqIGMzXG4gICAgdHYyID0gRnAuc3FyKHkxMSk7IC8vICAxOS4gdHYyID0geTExXjJcbiAgICB0djIgPSBGcC5tdWwodHYyLCBneGQpOyAvLyAgMjAuIHR2MiA9IHR2MiAqIGd4ZFxuICAgIGxldCBlMSA9IEZwLmVxbCh0djIsIGd4MSk7IC8vICAyMS4gIGUxID0gdHYyID09IGd4MVxuICAgIGxldCB5MSA9IEZwLmNtb3YoeTEyLCB5MTEsIGUxKTsgLy8gIDIyLiAgeTEgPSBDTU9WKHkxMiwgeTExLCBlMSkgICMgSWYgZyh4MSkgaXMgc3F1YXJlLCB0aGlzIGlzIGl0cyBzcXJ0XG4gICAgbGV0IHgybiA9IEZwLm11bCh4MW4sIHR2MSk7IC8vICAyMy4geDJuID0geDFuICogdHYxICAgICAgICMgeDIgPSB4Mm4gLyB4ZCA9IDIgKiB1XjIgKiB4MW4gLyB4ZFxuICAgIGxldCB5MjEgPSBGcC5tdWwoeTExLCB1KTsgLy8gIDI0LiB5MjEgPSB5MTEgKiB1XG4gICAgeTIxID0gRnAubXVsKHkyMSwgRUxMMl9DMik7IC8vICAyNS4geTIxID0geTIxICogYzJcbiAgICBsZXQgeTIyID0gRnAubXVsKHkyMSwgRUxMMl9DMyk7IC8vICAyNi4geTIyID0geTIxICogYzNcbiAgICBsZXQgZ3gyID0gRnAubXVsKGd4MSwgdHYxKTsgLy8gIDI3LiBneDIgPSBneDEgKiB0djEgICAgICAgIyBnKHgyKSA9IGd4MiAvIGd4ZCA9IDIgKiB1XjIgKiBnKHgxKVxuICAgIHR2MiA9IEZwLnNxcih5MjEpOyAvLyAgMjguIHR2MiA9IHkyMV4yXG4gICAgdHYyID0gRnAubXVsKHR2MiwgZ3hkKTsgLy8gIDI5LiB0djIgPSB0djIgKiBneGRcbiAgICBsZXQgZTIgPSBGcC5lcWwodHYyLCBneDIpOyAvLyAgMzAuICBlMiA9IHR2MiA9PSBneDJcbiAgICBsZXQgeTIgPSBGcC5jbW92KHkyMiwgeTIxLCBlMik7IC8vICAzMS4gIHkyID0gQ01PVih5MjIsIHkyMSwgZTIpICAjIElmIGcoeDIpIGlzIHNxdWFyZSwgdGhpcyBpcyBpdHMgc3FydFxuICAgIHR2MiA9IEZwLnNxcih5MSk7IC8vICAzMi4gdHYyID0geTFeMlxuICAgIHR2MiA9IEZwLm11bCh0djIsIGd4ZCk7IC8vICAzMy4gdHYyID0gdHYyICogZ3hkXG4gICAgbGV0IGUzID0gRnAuZXFsKHR2MiwgZ3gxKTsgLy8gIDM0LiAgZTMgPSB0djIgPT0gZ3gxXG4gICAgbGV0IHhuID0gRnAuY21vdih4Mm4sIHgxbiwgZTMpOyAvLyAgMzUuICB4biA9IENNT1YoeDJuLCB4MW4sIGUzKSAgIyBJZiBlMywgeCA9IHgxLCBlbHNlIHggPSB4MlxuICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGUzKTsgLy8gIDM2LiAgIHkgPSBDTU9WKHkyLCB5MSwgZTMpICAgICMgSWYgZTMsIHkgPSB5MSwgZWxzZSB5ID0geTJcbiAgICBsZXQgZTQgPSBGcC5pc09kZCh5KTsgLy8gIDM3LiAgZTQgPSBzZ24wKHkpID09IDEgICAgICAgICMgRml4IHNpZ24gb2YgeVxuICAgIHkgPSBGcC5jbW92KHksIEZwLm5lZyh5KSwgZTMgIT09IGU0KTsgLy8gIDM4LiAgIHkgPSBDTU9WKHksIC15LCBlMyBYT1IgZTQpXG4gICAgcmV0dXJuIHsgeE1uOiB4biwgeE1kOiB4ZCwgeU1uOiB5LCB5TWQ6IF8xbiB9OyAvLyAgMzkuIHJldHVybiAoeG4sIHhkLCB5LCAxKVxufVxuY29uc3QgRUxMMl9DMV9FRFdBUkRTID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBGcFNxcnRFdmVuKEZwLCBGcC5uZWcoQmlnSW50KDQ4NjY2NCkpKSkoKTsgLy8gc2duMChjMSkgTVVTVCBlcXVhbCAwXG5mdW5jdGlvbiBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9lZHdhcmRzMjU1MTkodSkge1xuICAgIGNvbnN0IHsgeE1uLCB4TWQsIHlNbiwgeU1kIH0gPSBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5KHUpOyAvLyAgMS4gICh4TW4sIHhNZCwgeU1uLCB5TWQpID1cbiAgICAvLyBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5KHUpXG4gICAgbGV0IHhuID0gRnAubXVsKHhNbiwgeU1kKTsgLy8gIDIuICB4biA9IHhNbiAqIHlNZFxuICAgIHhuID0gRnAubXVsKHhuLCBFTEwyX0MxX0VEV0FSRFMpOyAvLyAgMy4gIHhuID0geG4gKiBjMVxuICAgIGxldCB4ZCA9IEZwLm11bCh4TWQsIHlNbik7IC8vICA0LiAgeGQgPSB4TWQgKiB5TW4gICAgIyB4biAvIHhkID0gYzEgKiB4TSAvIHlNXG4gICAgbGV0IHluID0gRnAuc3ViKHhNbiwgeE1kKTsgLy8gIDUuICB5biA9IHhNbiAtIHhNZFxuICAgIGxldCB5ZCA9IEZwLmFkZCh4TW4sIHhNZCk7IC8vICA2LiAgeWQgPSB4TW4gKyB4TWQgICAgIyAobiAvIGQgLSAxKSAvIChuIC8gZCArIDEpID0gKG4gLSBkKSAvIChuICsgZClcbiAgICBsZXQgdHYxID0gRnAubXVsKHhkLCB5ZCk7IC8vICA3LiB0djEgPSB4ZCAqIHlkXG4gICAgbGV0IGUgPSBGcC5lcWwodHYxLCBGcC5aRVJPKTsgLy8gIDguICAgZSA9IHR2MSA9PSAwXG4gICAgeG4gPSBGcC5jbW92KHhuLCBGcC5aRVJPLCBlKTsgLy8gIDkuICB4biA9IENNT1YoeG4sIDAsIGUpXG4gICAgeGQgPSBGcC5jbW92KHhkLCBGcC5PTkUsIGUpOyAvLyAgMTAuIHhkID0gQ01PVih4ZCwgMSwgZSlcbiAgICB5biA9IEZwLmNtb3YoeW4sIEZwLk9ORSwgZSk7IC8vICAxMS4geW4gPSBDTU9WKHluLCAxLCBlKVxuICAgIHlkID0gRnAuY21vdih5ZCwgRnAuT05FLCBlKTsgLy8gIDEyLiB5ZCA9IENNT1YoeWQsIDEsIGUpXG4gICAgY29uc3QgaW52ID0gRnAuaW52ZXJ0QmF0Y2goW3hkLCB5ZF0pOyAvLyBiYXRjaCBkaXZpc2lvblxuICAgIHJldHVybiB7IHg6IEZwLm11bCh4biwgaW52WzBdKSwgeTogRnAubXVsKHluLCBpbnZbMV0pIH07IC8vICAxMy4gcmV0dXJuICh4biwgeGQsIHluLCB5ZClcbn1cbmNvbnN0IGh0ZiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKGVkMjU1MTkuRXh0ZW5kZWRQb2ludCwgKHNjYWxhcnMpID0+IG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2Vkd2FyZHMyNTUxOShzY2FsYXJzWzBdKSwge1xuICAgIERTVDogJ2Vkd2FyZHMyNTUxOV9YTUQ6U0hBLTUxMl9FTEwyX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnZWR3YXJkczI1NTE5X1hNRDpTSEEtNTEyX0VMTDJfTlVfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTUxMixcbn0pKSgpO1xuZXhwb3J0IGNvbnN0IGhhc2hUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmVuY29kZVRvQ3VydmUpKCk7XG5mdW5jdGlvbiBhc3NlcnRSc3RQb2ludChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUmlzdFBvaW50KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSaXN0cmV0dG9Qb2ludCBleHBlY3RlZCcpO1xufVxuLy8g4oiaKC0xKSBha2Eg4oiaKGEpIGFrYSAyXigocC0xKS80KVxuY29uc3QgU1FSVF9NMSA9IEVEMjU1MTlfU1FSVF9NMTtcbi8vIOKImihhZCAtIDEpXG5jb25zdCBTUVJUX0FEX01JTlVTX09ORSA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoJzI1MDYzMDY4OTUzMzg0NjIzNDc0MTExNDE0MTU4NzAyMTUyNzAxMjQ0NTMxNTAyNDkyNjU2NDYwMDc5MjEwNDgyNjEwNDMwNzUwMjM1Jyk7XG4vLyAxIC8g4oiaKGEtZClcbmNvbnN0IElOVlNRUlRfQV9NSU5VU19EID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgnNTQ0NjkzMDcwMDg5MDkzMTY5MjA5OTU4MTM4Njg3NDUxNDE2MDUzOTM1OTcyOTI5Mjc0NTY5MjEyMDUzMTI4OTYzMTE3MjEwMTc1NzgnKTtcbi8vIDEtZMKyXG5jb25zdCBPTkVfTUlOVVNfRF9TUSA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoJzExNTk4NDMwMjE2Njg3Nzk4NzkxOTM3NzU1MjE4NTU1ODY2NDc5MzczNTc3NTk3MTU0MTc2NTQ0Mzk4Nzk3MjA4NzYxMTE4MDY4MzgnKTtcbi8vIChkLTEpwrJcbmNvbnN0IERfTUlOVVNfT05FX1NRID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgnNDA0NDA4MzQzNDYzMDg1MzY4NTgxMDEwNDI0NjkzMjMxOTA4MjYyNDgzOTkxNDYyMzg3MDgzNTIyNDAxMzMyMjA4NjUxMzcyNjU5NTInKTtcbi8vIENhbGN1bGF0ZXMgMS/iiJoobnVtYmVyKVxuY29uc3QgaW52ZXJ0U3FydCA9IChudW1iZXIpID0+IHV2UmF0aW8oXzFuLCBudW1iZXIpO1xuY29uc3QgTUFYXzI1NUIgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYnKTtcbmNvbnN0IGJ5dGVzMjU1VG9OdW1iZXJMRSA9IChieXRlcykgPT4gZWQyNTUxOS5DVVJWRS5GcC5jcmVhdGUoYnl0ZXNUb051bWJlckxFKGJ5dGVzKSAmIE1BWF8yNTVCKTtcbi8vIENvbXB1dGVzIEVsbGlnYXRvciBtYXAgZm9yIFJpc3RyZXR0b1xuLy8gaHR0cHM6Ly9yaXN0cmV0dG8uZ3JvdXAvZm9ybXVsYXMvZWxsaWdhdG9yLmh0bWxcbmZ1bmN0aW9uIGNhbGNFbGxpZ2F0b3JSaXN0cmV0dG9NYXAocjApIHtcbiAgICBjb25zdCB7IGQgfSA9IGVkMjU1MTkuQ1VSVkU7XG4gICAgY29uc3QgUCA9IGVkMjU1MTkuQ1VSVkUuRnAuT1JERVI7XG4gICAgY29uc3QgbW9kID0gZWQyNTUxOS5DVVJWRS5GcC5jcmVhdGU7XG4gICAgY29uc3QgciA9IG1vZChTUVJUX00xICogcjAgKiByMCk7IC8vIDFcbiAgICBjb25zdCBOcyA9IG1vZCgociArIF8xbikgKiBPTkVfTUlOVVNfRF9TUSk7IC8vIDJcbiAgICBsZXQgYyA9IEJpZ0ludCgtMSk7IC8vIDNcbiAgICBjb25zdCBEID0gbW9kKChjIC0gZCAqIHIpICogbW9kKHIgKyBkKSk7IC8vIDRcbiAgICBsZXQgeyBpc1ZhbGlkOiBOc19EX2lzX3NxLCB2YWx1ZTogcyB9ID0gdXZSYXRpbyhOcywgRCk7IC8vIDVcbiAgICBsZXQgc18gPSBtb2QocyAqIHIwKTsgLy8gNlxuICAgIGlmICghaXNOZWdhdGl2ZUxFKHNfLCBQKSlcbiAgICAgICAgc18gPSBtb2QoLXNfKTtcbiAgICBpZiAoIU5zX0RfaXNfc3EpXG4gICAgICAgIHMgPSBzXzsgLy8gN1xuICAgIGlmICghTnNfRF9pc19zcSlcbiAgICAgICAgYyA9IHI7IC8vIDhcbiAgICBjb25zdCBOdCA9IG1vZChjICogKHIgLSBfMW4pICogRF9NSU5VU19PTkVfU1EgLSBEKTsgLy8gOVxuICAgIGNvbnN0IHMyID0gcyAqIHM7XG4gICAgY29uc3QgVzAgPSBtb2QoKHMgKyBzKSAqIEQpOyAvLyAxMFxuICAgIGNvbnN0IFcxID0gbW9kKE50ICogU1FSVF9BRF9NSU5VU19PTkUpOyAvLyAxMVxuICAgIGNvbnN0IFcyID0gbW9kKF8xbiAtIHMyKTsgLy8gMTJcbiAgICBjb25zdCBXMyA9IG1vZChfMW4gKyBzMik7IC8vIDEzXG4gICAgcmV0dXJuIG5ldyBlZDI1NTE5LkV4dGVuZGVkUG9pbnQobW9kKFcwICogVzMpLCBtb2QoVzIgKiBXMSksIG1vZChXMSAqIFczKSwgbW9kKFcwICogVzIpKTtcbn1cbi8qKlxuICogRWFjaCBlZDI1NTE5L0V4dGVuZGVkUG9pbnQgaGFzIDggZGlmZmVyZW50IGVxdWl2YWxlbnQgcG9pbnRzLiBUaGlzIGNhbiBiZVxuICogYSBzb3VyY2Ugb2YgYnVncyBmb3IgcHJvdG9jb2xzIGxpa2UgcmluZyBzaWduYXR1cmVzLiBSaXN0cmV0dG8gd2FzIGNyZWF0ZWQgdG8gc29sdmUgdGhpcy5cbiAqIFJpc3RyZXR0byBwb2ludCBvcGVyYXRlcyBpbiBYOlk6WjpUIGV4dGVuZGVkIGNvb3JkaW5hdGVzIGxpa2UgRXh0ZW5kZWRQb2ludCxcbiAqIGJ1dCBpdCBzaG91bGQgd29yayBpbiBpdHMgb3duIG5hbWVzcGFjZTogZG8gbm90IGNvbWJpbmUgdGhvc2UgdHdvLlxuICogaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmctcmlzdHJldHRvMjU1LWRlY2FmNDQ4XG4gKi9cbmNsYXNzIFJpc3RQb2ludCB7XG4gICAgLy8gUHJpdmF0ZSBwcm9wZXJ0eSB0byBkaXNjb3VyYWdlIGNvbWJpbmluZyBFeHRlbmRlZFBvaW50ICsgUmlzdHJldHRvUG9pbnRcbiAgICAvLyBBbHdheXMgdXNlIFJpc3RyZXR0byBlbmNvZGluZy9kZWNvZGluZyBpbnN0ZWFkLlxuICAgIGNvbnN0cnVjdG9yKGVwKSB7XG4gICAgICAgIHRoaXMuZXAgPSBlcDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21BZmZpbmUoYXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQoZWQyNTUxOS5FeHRlbmRlZFBvaW50LmZyb21BZmZpbmUoYXApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZXMgdW5pZm9ybSBvdXRwdXQgb2YgNjQtYnl0ZSBoYXNoIGZ1bmN0aW9uIGxpa2Ugc2hhNTEyIGFuZCBjb252ZXJ0cyBpdCB0byBgUmlzdHJldHRvUG9pbnRgLlxuICAgICAqIFRoZSBoYXNoLXRvLWdyb3VwIG9wZXJhdGlvbiBhcHBsaWVzIEVsbGlnYXRvciB0d2ljZSBhbmQgYWRkcyB0aGUgcmVzdWx0cy5cbiAgICAgKiAqKk5vdGU6KiogdGhpcyBpcyBvbmUtd2F5IG1hcCwgdGhlcmUgaXMgbm8gY29udmVyc2lvbiBmcm9tIHBvaW50IHRvIGhhc2guXG4gICAgICogaHR0cHM6Ly9yaXN0cmV0dG8uZ3JvdXAvZm9ybXVsYXMvZWxsaWdhdG9yLmh0bWxcbiAgICAgKiBAcGFyYW0gaGV4IDY0LWJ5dGUgb3V0cHV0IG9mIGEgaGFzaCBmdW5jdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBoYXNoVG9DdXJ2ZShoZXgpIHtcbiAgICAgICAgaGV4ID0gZW5zdXJlQnl0ZXMoJ3Jpc3RyZXR0b0hhc2gnLCBoZXgsIDY0KTtcbiAgICAgICAgY29uc3QgcjEgPSBieXRlczI1NVRvTnVtYmVyTEUoaGV4LnNsaWNlKDAsIDMyKSk7XG4gICAgICAgIGNvbnN0IFIxID0gY2FsY0VsbGlnYXRvclJpc3RyZXR0b01hcChyMSk7XG4gICAgICAgIGNvbnN0IHIyID0gYnl0ZXMyNTVUb051bWJlckxFKGhleC5zbGljZSgzMiwgNjQpKTtcbiAgICAgICAgY29uc3QgUjIgPSBjYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwKHIyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQoUjEuYWRkKFIyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHJpc3RyZXR0by1lbmNvZGVkIHN0cmluZyB0byByaXN0cmV0dG8gcG9pbnQuXG4gICAgICogaHR0cHM6Ly9yaXN0cmV0dG8uZ3JvdXAvZm9ybXVsYXMvZGVjb2RpbmcuaHRtbFxuICAgICAqIEBwYXJhbSBoZXggUmlzdHJldHRvLWVuY29kZWQgMzIgYnl0ZXMuIE5vdCBldmVyeSAzMi1ieXRlIHN0cmluZyBpcyB2YWxpZCByaXN0cmV0dG8gZW5jb2RpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgaGV4ID0gZW5zdXJlQnl0ZXMoJ3Jpc3RyZXR0b0hleCcsIGhleCwgMzIpO1xuICAgICAgICBjb25zdCB7IGEsIGQgfSA9IGVkMjU1MTkuQ1VSVkU7XG4gICAgICAgIGNvbnN0IFAgPSBlZDI1NTE5LkNVUlZFLkZwLk9SREVSO1xuICAgICAgICBjb25zdCBtb2QgPSBlZDI1NTE5LkNVUlZFLkZwLmNyZWF0ZTtcbiAgICAgICAgY29uc3QgZW1zZyA9ICdSaXN0cmV0dG9Qb2ludC5mcm9tSGV4OiB0aGUgaGV4IGlzIG5vdCB2YWxpZCBlbmNvZGluZyBvZiBSaXN0cmV0dG9Qb2ludCc7XG4gICAgICAgIGNvbnN0IHMgPSBieXRlczI1NVRvTnVtYmVyTEUoaGV4KTtcbiAgICAgICAgLy8gMS4gQ2hlY2sgdGhhdCBzX2J5dGVzIGlzIHRoZSBjYW5vbmljYWwgZW5jb2Rpbmcgb2YgYSBmaWVsZCBlbGVtZW50LCBvciBlbHNlIGFib3J0LlxuICAgICAgICAvLyAzLiBDaGVjayB0aGF0IHMgaXMgbm9uLW5lZ2F0aXZlLCBvciBlbHNlIGFib3J0XG4gICAgICAgIGlmICghZXF1YWxCeXRlcyhudW1iZXJUb0J5dGVzTEUocywgMzIpLCBoZXgpIHx8IGlzTmVnYXRpdmVMRShzLCBQKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlbXNnKTtcbiAgICAgICAgY29uc3QgczIgPSBtb2QocyAqIHMpO1xuICAgICAgICBjb25zdCB1MSA9IG1vZChfMW4gKyBhICogczIpOyAvLyA0IChhIGlzIC0xKVxuICAgICAgICBjb25zdCB1MiA9IG1vZChfMW4gLSBhICogczIpOyAvLyA1XG4gICAgICAgIGNvbnN0IHUxXzIgPSBtb2QodTEgKiB1MSk7XG4gICAgICAgIGNvbnN0IHUyXzIgPSBtb2QodTIgKiB1Mik7XG4gICAgICAgIGNvbnN0IHYgPSBtb2QoYSAqIGQgKiB1MV8yIC0gdTJfMik7IC8vIDZcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCB2YWx1ZTogSSB9ID0gaW52ZXJ0U3FydChtb2QodiAqIHUyXzIpKTsgLy8gN1xuICAgICAgICBjb25zdCBEeCA9IG1vZChJICogdTIpOyAvLyA4XG4gICAgICAgIGNvbnN0IER5ID0gbW9kKEkgKiBEeCAqIHYpOyAvLyA5XG4gICAgICAgIGxldCB4ID0gbW9kKChzICsgcykgKiBEeCk7IC8vIDEwXG4gICAgICAgIGlmIChpc05lZ2F0aXZlTEUoeCwgUCkpXG4gICAgICAgICAgICB4ID0gbW9kKC14KTsgLy8gMTBcbiAgICAgICAgY29uc3QgeSA9IG1vZCh1MSAqIER5KTsgLy8gMTFcbiAgICAgICAgY29uc3QgdCA9IG1vZCh4ICogeSk7IC8vIDEyXG4gICAgICAgIGlmICghaXNWYWxpZCB8fCBpc05lZ2F0aXZlTEUodCwgUCkgfHwgeSA9PT0gXzBuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVtc2cpO1xuICAgICAgICByZXR1cm4gbmV3IFJpc3RQb2ludChuZXcgZWQyNTUxOS5FeHRlbmRlZFBvaW50KHgsIHksIF8xbiwgdCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHJpc3RyZXR0byBwb2ludCB0byBVaW50OEFycmF5LlxuICAgICAqIGh0dHBzOi8vcmlzdHJldHRvLmdyb3VwL2Zvcm11bGFzL2VuY29kaW5nLmh0bWxcbiAgICAgKi9cbiAgICB0b1Jhd0J5dGVzKCkge1xuICAgICAgICBsZXQgeyBleDogeCwgZXk6IHksIGV6OiB6LCBldDogdCB9ID0gdGhpcy5lcDtcbiAgICAgICAgY29uc3QgUCA9IGVkMjU1MTkuQ1VSVkUuRnAuT1JERVI7XG4gICAgICAgIGNvbnN0IG1vZCA9IGVkMjU1MTkuQ1VSVkUuRnAuY3JlYXRlO1xuICAgICAgICBjb25zdCB1MSA9IG1vZChtb2QoeiArIHkpICogbW9kKHogLSB5KSk7IC8vIDFcbiAgICAgICAgY29uc3QgdTIgPSBtb2QoeCAqIHkpOyAvLyAyXG4gICAgICAgIC8vIFNxdWFyZSByb290IGFsd2F5cyBleGlzdHNcbiAgICAgICAgY29uc3QgdTJzcSA9IG1vZCh1MiAqIHUyKTtcbiAgICAgICAgY29uc3QgeyB2YWx1ZTogaW52c3FydCB9ID0gaW52ZXJ0U3FydChtb2QodTEgKiB1MnNxKSk7IC8vIDNcbiAgICAgICAgY29uc3QgRDEgPSBtb2QoaW52c3FydCAqIHUxKTsgLy8gNFxuICAgICAgICBjb25zdCBEMiA9IG1vZChpbnZzcXJ0ICogdTIpOyAvLyA1XG4gICAgICAgIGNvbnN0IHpJbnYgPSBtb2QoRDEgKiBEMiAqIHQpOyAvLyA2XG4gICAgICAgIGxldCBEOyAvLyA3XG4gICAgICAgIGlmIChpc05lZ2F0aXZlTEUodCAqIHpJbnYsIFApKSB7XG4gICAgICAgICAgICBsZXQgX3ggPSBtb2QoeSAqIFNRUlRfTTEpO1xuICAgICAgICAgICAgbGV0IF95ID0gbW9kKHggKiBTUVJUX00xKTtcbiAgICAgICAgICAgIHggPSBfeDtcbiAgICAgICAgICAgIHkgPSBfeTtcbiAgICAgICAgICAgIEQgPSBtb2QoRDEgKiBJTlZTUVJUX0FfTUlOVVNfRCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBEID0gRDI7IC8vIDhcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOZWdhdGl2ZUxFKHggKiB6SW52LCBQKSlcbiAgICAgICAgICAgIHkgPSBtb2QoLXkpOyAvLyA5XG4gICAgICAgIGxldCBzID0gbW9kKCh6IC0geSkgKiBEKTsgLy8gMTAgKGNoZWNrIGZvb3RlcidzIG5vdGUsIG5vIHNxcnQoLWEpKVxuICAgICAgICBpZiAoaXNOZWdhdGl2ZUxFKHMsIFApKVxuICAgICAgICAgICAgcyA9IG1vZCgtcyk7XG4gICAgICAgIHJldHVybiBudW1iZXJUb0J5dGVzTEUocywgMzIpOyAvLyAxMVxuICAgIH1cbiAgICB0b0hleCgpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKCkpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9IZXgoKTtcbiAgICB9XG4gICAgLy8gQ29tcGFyZSBvbmUgcG9pbnQgdG8gYW5vdGhlci5cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0UnN0UG9pbnQob3RoZXIpO1xuICAgICAgICBjb25zdCB7IGV4OiBYMSwgZXk6IFkxIH0gPSB0aGlzLmVwO1xuICAgICAgICBjb25zdCB7IGV4OiBYMiwgZXk6IFkyIH0gPSBvdGhlci5lcDtcbiAgICAgICAgY29uc3QgbW9kID0gZWQyNTUxOS5DVVJWRS5GcC5jcmVhdGU7XG4gICAgICAgIC8vICh4MSAqIHkyID09IHkxICogeDIpIHwgKHkxICogeTIgPT0geDEgKiB4MilcbiAgICAgICAgY29uc3Qgb25lID0gbW9kKFgxICogWTIpID09PSBtb2QoWTEgKiBYMik7XG4gICAgICAgIGNvbnN0IHR3byA9IG1vZChZMSAqIFkyKSA9PT0gbW9kKFgxICogWDIpO1xuICAgICAgICByZXR1cm4gb25lIHx8IHR3bztcbiAgICB9XG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIGFzc2VydFJzdFBvaW50KG90aGVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5hZGQob3RoZXIuZXApKTtcbiAgICB9XG4gICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0UnN0UG9pbnQob3RoZXIpO1xuICAgICAgICByZXR1cm4gbmV3IFJpc3RQb2ludCh0aGlzLmVwLnN1YnRyYWN0KG90aGVyLmVwKSk7XG4gICAgfVxuICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICByZXR1cm4gbmV3IFJpc3RQb2ludCh0aGlzLmVwLm11bHRpcGx5KHNjYWxhcikpO1xuICAgIH1cbiAgICBtdWx0aXBseVVuc2FmZShzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5tdWx0aXBseVVuc2FmZShzY2FsYXIpKTtcbiAgICB9XG4gICAgZG91YmxlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJpc3RQb2ludCh0aGlzLmVwLmRvdWJsZSgpKTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJpc3RQb2ludCh0aGlzLmVwLm5lZ2F0ZSgpKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgUmlzdHJldHRvUG9pbnQgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgICBpZiAoIVJpc3RQb2ludC5CQVNFKVxuICAgICAgICBSaXN0UG9pbnQuQkFTRSA9IG5ldyBSaXN0UG9pbnQoZWQyNTUxOS5FeHRlbmRlZFBvaW50LkJBU0UpO1xuICAgIGlmICghUmlzdFBvaW50LlpFUk8pXG4gICAgICAgIFJpc3RQb2ludC5aRVJPID0gbmV3IFJpc3RQb2ludChlZDI1NTE5LkV4dGVuZGVkUG9pbnQuWkVSTyk7XG4gICAgcmV0dXJuIFJpc3RQb2ludDtcbn0pKCk7XG4vLyBIYXNoaW5nIHRvIHJpc3RyZXR0bzI1NS4gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjYXBwZW5kaXgtQlxuZXhwb3J0IGNvbnN0IGhhc2hUb1Jpc3RyZXR0bzI1NSA9IChtc2csIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBkID0gb3B0aW9ucy5EU1Q7XG4gICAgY29uc3QgRFNUID0gdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gdXRmOFRvQnl0ZXMoZCkgOiBkO1xuICAgIGNvbnN0IHVuaWZvcm1fYnl0ZXMgPSBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIDY0LCBzaGE1MTIpO1xuICAgIGNvbnN0IFAgPSBSaXN0UG9pbnQuaGFzaFRvQ3VydmUodW5pZm9ybV9ieXRlcyk7XG4gICAgcmV0dXJuIFA7XG59O1xuZXhwb3J0IGNvbnN0IGhhc2hfdG9fcmlzdHJldHRvMjU1ID0gaGFzaFRvUmlzdHJldHRvMjU1OyAvLyBsZWdhY3lcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVkMjU1MTkuanMubWFwIl0sIm5hbWVzIjpbInNoYTUxMiIsImNvbmNhdEJ5dGVzIiwicmFuZG9tQnl0ZXMiLCJ1dGY4VG9CeXRlcyIsInR3aXN0ZWRFZHdhcmRzIiwiY3JlYXRlSGFzaGVyIiwiZXhwYW5kX21lc3NhZ2VfeG1kIiwiRmllbGQiLCJGcFNxcnRFdmVuIiwiaXNOZWdhdGl2ZUxFIiwibW9kIiwicG93MiIsIm1vbnRnb21lcnkiLCJieXRlc1RvSGV4IiwiYnl0ZXNUb051bWJlckxFIiwiZW5zdXJlQnl0ZXMiLCJlcXVhbEJ5dGVzIiwibnVtYmVyVG9CeXRlc0xFIiwiRUQyNTUxOV9QIiwiQmlnSW50IiwiRUQyNTUxOV9TUVJUX00xIiwiXzBuIiwiXzFuIiwiXzJuIiwiXzNuIiwiXzVuIiwiXzhuIiwiZWQyNTUxOV9wb3dfMl8yNTJfMyIsIngiLCJfMTBuIiwiXzIwbiIsIl80MG4iLCJfODBuIiwiUCIsIngyIiwiYjIiLCJiNCIsImI1IiwiYjEwIiwiYjIwIiwiYjQwIiwiYjgwIiwiYjE2MCIsImIyNDAiLCJiMjUwIiwicG93X3BfNV84IiwiYWRqdXN0U2NhbGFyQnl0ZXMiLCJieXRlcyIsInV2UmF0aW8iLCJ1IiwidiIsInYzIiwidjciLCJwb3ciLCJ2eDIiLCJyb290MSIsInJvb3QyIiwidXNlUm9vdDEiLCJ1c2VSb290MiIsIm5vUm9vdCIsImlzVmFsaWQiLCJ2YWx1ZSIsIkVEMjU1MTlfVE9SU0lPTl9TVUJHUk9VUCIsIkZwIiwidW5kZWZpbmVkIiwiZWQyNTUxOURlZmF1bHRzIiwiYSIsImQiLCJuIiwiaCIsIkd4IiwiR3kiLCJoYXNoIiwiZWQyNTUxOSIsImVkMjU1MTlfZG9tYWluIiwiZGF0YSIsImN0eCIsInBoZmxhZyIsImxlbmd0aCIsIkVycm9yIiwiVWludDhBcnJheSIsImVkMjU1MTljdHgiLCJkb21haW4iLCJlZDI1NTE5cGgiLCJPYmplY3QiLCJhc3NpZ24iLCJwcmVoYXNoIiwieDI1NTE5IiwibW9udGdvbWVyeUJpdHMiLCJuQnl0ZUxlbmd0aCIsIkd1IiwicG93UG1pbnVzMiIsImVkd2FyZHNUb01vbnRnb21lcnlQdWIiLCJlZHdhcmRzUHViIiwieSIsIkV4dGVuZGVkUG9pbnQiLCJmcm9tSGV4IiwidG9CeXRlcyIsImNyZWF0ZSIsImludiIsImVkd2FyZHNUb01vbnRnb21lcnkiLCJlZHdhcmRzVG9Nb250Z29tZXJ5UHJpdiIsImVkd2FyZHNQcml2IiwiaGFzaGVkIiwic3ViYXJyYXkiLCJFTEwyX0MxIiwiT1JERVIiLCJFTEwyX0MyIiwiRUxMMl9DMyIsInNxcnQiLCJuZWciLCJPTkUiLCJtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5IiwiRUxMMl9DNCIsIkVMTDJfSiIsInR2MSIsInNxciIsIm11bCIsInhkIiwiYWRkIiwieDFuIiwidHYyIiwiZ3hkIiwiZ3gxIiwidHYzIiwieTExIiwieTEyIiwiZTEiLCJlcWwiLCJ5MSIsImNtb3YiLCJ4Mm4iLCJ5MjEiLCJ5MjIiLCJneDIiLCJlMiIsInkyIiwiZTMiLCJ4biIsImU0IiwiaXNPZGQiLCJ4TW4iLCJ4TWQiLCJ5TW4iLCJ5TWQiLCJFTEwyX0MxX0VEV0FSRFMiLCJtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9lZHdhcmRzMjU1MTkiLCJ5biIsInN1YiIsInlkIiwiZSIsIlpFUk8iLCJpbnZlcnRCYXRjaCIsImh0ZiIsInNjYWxhcnMiLCJEU1QiLCJlbmNvZGVEU1QiLCJwIiwibSIsImsiLCJleHBhbmQiLCJoYXNoVG9DdXJ2ZSIsImVuY29kZVRvQ3VydmUiLCJhc3NlcnRSc3RQb2ludCIsIm90aGVyIiwiUmlzdFBvaW50IiwiU1FSVF9NMSIsIlNRUlRfQURfTUlOVVNfT05FIiwiSU5WU1FSVF9BX01JTlVTX0QiLCJPTkVfTUlOVVNfRF9TUSIsIkRfTUlOVVNfT05FX1NRIiwiaW52ZXJ0U3FydCIsIm51bWJlciIsIk1BWF8yNTVCIiwiYnl0ZXMyNTVUb051bWJlckxFIiwiQ1VSVkUiLCJjYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwIiwicjAiLCJyIiwiTnMiLCJjIiwiRCIsIk5zX0RfaXNfc3EiLCJzIiwic18iLCJOdCIsInMyIiwiVzAiLCJXMSIsIlcyIiwiVzMiLCJjb25zdHJ1Y3RvciIsImVwIiwiZnJvbUFmZmluZSIsImFwIiwiaGV4IiwicjEiLCJzbGljZSIsIlIxIiwicjIiLCJSMiIsImVtc2ciLCJ1MSIsInUyIiwidTFfMiIsInUyXzIiLCJJIiwiRHgiLCJEeSIsInQiLCJ0b1Jhd0J5dGVzIiwiZXgiLCJleSIsImV6IiwieiIsImV0IiwidTJzcSIsImludnNxcnQiLCJEMSIsIkQyIiwiekludiIsIl94IiwiX3kiLCJ0b0hleCIsInRvU3RyaW5nIiwiZXF1YWxzIiwiWDEiLCJZMSIsIlgyIiwiWTIiLCJvbmUiLCJ0d28iLCJzdWJ0cmFjdCIsIm11bHRpcGx5Iiwic2NhbGFyIiwibXVsdGlwbHlVbnNhZmUiLCJkb3VibGUiLCJuZWdhdGUiLCJSaXN0cmV0dG9Qb2ludCIsIkJBU0UiLCJoYXNoVG9SaXN0cmV0dG8yNTUiLCJtc2ciLCJvcHRpb25zIiwidW5pZm9ybV9ieXRlcyIsImhhc2hfdG9fcmlzdHJldHRvMjU1Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/@noble/curves/esm/ed25519.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/@noble/curves/esm/secp256k1.js":
/*!******************************************************!*\
  !*** ../node_modules/@noble/curves/esm/secp256k1.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(rsc)/../node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(rsc)/../node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(rsc)/../node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(rsc)/../node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\nconst secp256k1P = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\");\nconst secp256k1N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b)=>(a + b / _2n) / b;\n/**\n * ‚àön = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2 % P;\n    const b22 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, {\n    sqrt: sqrtMod\n});\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n    Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */ endo: {\n        beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n        splitScalar: (k)=>{\n            const n = secp256k1N;\n            const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\n            const b1 = -_1n * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\n            const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\n            const b2 = a1;\n            const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\"); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg) k1 = n - k1;\n            if (k2neg) k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error(\"splitScalar: Endomorphism failed, k=\" + k);\n            }\n            return {\n                k1neg,\n                k1,\n                k2neg,\n                k2\n            };\n        }\n    }\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x)=>typeof x === \"bigint\" && _0n < x && x < secp256k1P;\nconst ge = (x)=>typeof x === \"bigint\" && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point)=>point.toRawBytes(true).slice(1);\nconst numTo32b = (n)=>(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b)=>Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'‚ãÖG; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return {\n        scalar: scalar,\n        bytes: pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function lift_x(x) {\n    if (!fe(x)) throw new Error(\"bad x: need 0 < x < p\"); // Fail if x ‚â• p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x¬≥ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function challenge(...args) {\n    return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash(\"BIP0340/challenge\", ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'‚â•n. Ret bytes(d'‚ãÖG)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"auxRand\", auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash(\"BIP0340/aux\", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash(\"BIP0340/nonce\", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n) throw new Error(\"sign failed: k is zero\"); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'‚ãÖG.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px)) throw new Error(\"sign: Invalid signature produced\");\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"signature\", signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"publicKey\", publicKey, 32);\n    try {\n        const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ‚â• p.\n        if (!fe(r)) return false;\n        const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ‚â• n.\n        if (!ge(s)) return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s‚ãÖG - e‚ãÖP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ‚â† r.\n    } catch (error) {\n        return false;\n    }\n}\nconst schnorr = /* @__PURE__ */ (()=>({\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        utils: {\n            randomPrivateKey: secp256k1.utils.randomPrivateKey,\n            lift_x,\n            pointToBytes,\n            numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n            bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n            taggedHash,\n            mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod\n        }\n    }))();\nconst isoMap = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fp, [\n        // xNum\n        [\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n            \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n            \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n        ],\n        // xDen\n        [\n            \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n            \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ],\n        // yNum\n        [\n            \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n            \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n            \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n            \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n        ],\n        // yDen\n        [\n            \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n            \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n            \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (()=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fp, {\n        A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n        B: BigInt(\"1771\"),\n        Z: Fp.create(BigInt(\"-11\"))\n    }))();\nconst htf = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars)=>{\n        const { x, y } = mapSWU(Fp.create(scalars[0]));\n        return isoMap(x, y);\n    }, {\n        DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n        p: Fp.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256\n    }))();\nconst hashToCurve = /* @__PURE__ */ (()=>htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (()=>htf.encodeToCurve)(); //# sourceMappingURL=secp256k1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL3NlY3AyNTZrMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLG9FQUFvRSxHQUN0QjtBQUNJO0FBQ0Q7QUFDc0I7QUFDZDtBQUN3QztBQUNqQztBQUNoRSxNQUFNYSxhQUFhQyxPQUFPO0FBQzFCLE1BQU1DLGFBQWFELE9BQU87QUFDMUIsTUFBTUUsTUFBTUYsT0FBTztBQUNuQixNQUFNRyxNQUFNSCxPQUFPO0FBQ25CLE1BQU1JLGFBQWEsQ0FBQ0MsR0FBR0MsSUFBTSxDQUFDRCxJQUFJQyxJQUFJSCxHQUFFLElBQUtHO0FBQzdDOzs7Q0FHQyxHQUNELFNBQVNDLFFBQVFDLENBQUM7SUFDZCxNQUFNQyxJQUFJVjtJQUNWLGtCQUFrQjtJQUNsQixNQUFNVyxNQUFNVixPQUFPLElBQUlXLE1BQU1YLE9BQU8sSUFBSVksT0FBT1osT0FBTyxLQUFLYSxPQUFPYixPQUFPO0lBQ3pFLGtCQUFrQjtJQUNsQixNQUFNYyxPQUFPZCxPQUFPLEtBQUtlLE9BQU9mLE9BQU8sS0FBS2dCLE9BQU9oQixPQUFPO0lBQzFELE1BQU1pQixLQUFLLElBQUtULElBQUlBLElBQUtDLEdBQUcsVUFBVTtJQUN0QyxNQUFNUyxLQUFLLEtBQU1ELEtBQUtULElBQUtDLEdBQUcsTUFBTTtJQUNwQyxNQUFNVSxLQUFLLDJEQUFNRCxJQUFJUixLQUFLRCxLQUFLUyxLQUFNVDtJQUNyQyxNQUFNVyxLQUFLLDJEQUFNRCxJQUFJVCxLQUFLRCxLQUFLUyxLQUFNVDtJQUNyQyxNQUFNWSxNQUFNLDJEQUFNRCxJQUFJakIsS0FBS00sS0FBS1EsS0FBTVI7SUFDdEMsTUFBTWEsTUFBTSwyREFBTUQsS0FBS1QsTUFBTUgsS0FBS1ksTUFBT1o7SUFDekMsTUFBTWMsTUFBTSwyREFBTUQsS0FBS1QsTUFBTUosS0FBS2EsTUFBT2I7SUFDekMsTUFBTWUsTUFBTSwyREFBTUQsS0FBS1IsTUFBTU4sS0FBS2MsTUFBT2Q7SUFD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bkQ7SUFDckIsR0FBRztRQUNDb0ksS0FBSztRQUNMQyxXQUFXO1FBQ1hwRCxHQUFHMUQsR0FBRytHLEtBQUs7UUFDWHRDLEdBQUc7UUFDSDFELEdBQUc7UUFDSGlHLFFBQVE7UUFDUkMsTUFBTTlKLHdEQUFNQTtJQUNoQixFQUFDO0FBQ00sTUFBTStKLGNBQThCLGFBQUgsR0FBSSxLQUFNUCxJQUFJTyxXQUFXLElBQUk7QUFDOUQsTUFBTUMsZ0JBQWdDLGFBQUgsR0FBSSxLQUFNUixJQUFJUSxhQUFhLElBQUksQ0FDekUscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanM/ZjUwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlQ3VydmUgfSBmcm9tICcuL19zaG9ydHdfdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyLCBpc29nZW55TWFwIH0gZnJvbSAnLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzJztcbmltcG9ydCB7IEZpZWxkLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSB9IGZyb20gJy4vYWJzdHJhY3QvdXRpbHMuanMnO1xuaW1wb3J0IHsgbWFwVG9DdXJ2ZVNpbXBsZVNXVSB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuY29uc3Qgc2VjcDI1NmsxUCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyk7XG5jb25zdCBzZWNwMjU2azFOID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IGRpdk5lYXJlc3QgPSAoYSwgYikgPT4gKGEgKyBiIC8gXzJuKSAvIGI7XG4vKipcbiAqIOKImm4gPSBuXigocCsxKS80KSBmb3IgZmllbGRzIHAgPSAzIG1vZCA0LiBXZSB1bndyYXAgdGhlIGxvb3AgYW5kIG11bHRpcGx5IGJpdC1ieS1iaXQuXG4gKiAoUCsxbi80bikudG9TdHJpbmcoMikgd291bGQgcHJvZHVjZSBiaXRzIFsyMjN4IDEsIDAsIDIyeCAxLCA0eCAwLCAxMSwgMDBdXG4gKi9cbmZ1bmN0aW9uIHNxcnRNb2QoeSkge1xuICAgIGNvbnN0IFAgPSBzZWNwMjU2azFQO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8zbiA9IEJpZ0ludCgzKSwgXzZuID0gQmlnSW50KDYpLCBfMTFuID0gQmlnSW50KDExKSwgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcbiAgICBjb25zdCBiMiA9ICh5ICogeSAqIHkpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7IC8vIHheN1xuICAgIGNvbnN0IGI2ID0gKHBvdzIoYjMsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGI5ID0gKHBvdzIoYjYsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGIxMSA9IChwb3cyKGI5LCBfMm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCBiMjIgPSAocG93MihiMTEsIF8xMW4sIFApICogYjExKSAlIFA7XG4gICAgY29uc3QgYjQ0ID0gKHBvdzIoYjIyLCBfMjJuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IGI4OCA9IChwb3cyKGI0NCwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMTc2ID0gKHBvdzIoYjg4LCBfODhuLCBQKSAqIGI4OCkgJSBQO1xuICAgIGNvbnN0IGIyMjAgPSAocG93MihiMTc2LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIyMjMgPSAocG93MihiMjIwLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCB0MSA9IChwb3cyKGIyMjMsIF8yM24sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgdDIgPSAocG93Mih0MSwgXzZuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3Qgcm9vdCA9IHBvdzIodDIsIF8ybiwgUCk7XG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCB5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgIHJldHVybiByb290O1xufVxuY29uc3QgRnAgPSBGaWVsZChzZWNwMjU2azFQLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeyBzcXJ0OiBzcXJ0TW9kIH0pO1xuZXhwb3J0IGNvbnN0IHNlY3AyNTZrMSA9IGNyZWF0ZUN1cnZlKHtcbiAgICBhOiBCaWdJbnQoMCksIC8vIGVxdWF0aW9uIHBhcmFtczogYSwgYlxuICAgIGI6IEJpZ0ludCg3KSwgLy8gU2VlbSB0byBiZSByaWdpZDogYml0Y29pbnRhbGsub3JnL2luZGV4LnBocD90b3BpYz0yODk3OTUubXNnMzE4Mzk3NSNtc2czMTgzOTc1XG4gICAgRnAsIC8vIEZpZWxkJ3MgcHJpbWU6IDJuKioyNTZuIC0gMm4qKjMybiAtIDJuKio5biAtIDJuKio4biAtIDJuKio3biAtIDJuKio2biAtIDJuKio0biAtIDFuXG4gICAgbjogc2VjcDI1NmsxTiwgLy8gQ3VydmUgb3JkZXIsIHRvdGFsIGNvdW50IG9mIHZhbGlkIHBvaW50cyBpbiB0aGUgZmllbGRcbiAgICAvLyBCYXNlIHBvaW50ICh4LCB5KSBha2EgZ2VuZXJhdG9yIHBvaW50XG4gICAgR3g6IEJpZ0ludCgnNTUwNjYyNjMwMjIyNzczNDM2Njk1Nzg3MTg4OTUxNjg1MzQzMjYyNTA2MDM0NTM3Nzc1OTQxNzU1MDAxODczNjAzODkxMTY3MjkyNDAnKSxcbiAgICBHeTogQmlnSW50KCczMjY3MDUxMDAyMDc1ODgxNjk3ODA4MzA4NTEzMDUwNzA0MzE4NDQ3MTI3MzM4MDY1OTI0MzI3NTkzODkwNDMzNTc1NzMzNzQ4MjQyNCcpLFxuICAgIGg6IEJpZ0ludCgxKSwgLy8gQ29mYWN0b3JcbiAgICBsb3dTOiB0cnVlLCAvLyBBbGxvdyBvbmx5IGxvdy1TIHNpZ25hdHVyZXMgYnkgZGVmYXVsdCBpbiBzaWduKCkgYW5kIHZlcmlmeSgpXG4gICAgLyoqXG4gICAgICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cbiAgICAgKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAgICAgKiBGb3IgcHJlY29tcHV0ZWQgd05BRiBpdCB0cmFkZXMgb2ZmIDEvMiBpbml0IHRpbWUgJiAxLzMgcmFtIGZvciAyMCUgcGVyZiBoaXQuXG4gICAgICogRXhwbGFuYXRpb246IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NlxuICAgICAqL1xuICAgIGVuZG86IHtcbiAgICAgICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcbiAgICAgICAgc3BsaXRTY2FsYXI6IChrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gc2VjcDI1NmsxTjtcbiAgICAgICAgICAgIGNvbnN0IGExID0gQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1Jyk7XG4gICAgICAgICAgICBjb25zdCBiMSA9IC1fMW4gKiBCaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKTtcbiAgICAgICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICAgICAgY29uc3QgYjIgPSBhMTtcbiAgICAgICAgICAgIGNvbnN0IFBPV18yXzEyOCA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTsgLy8gKDJuKioxMjhuKS50b1N0cmluZygxNilcbiAgICAgICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgICAgICAgICAgbGV0IGsxID0gbW9kKGsgLSBjMSAqIGExIC0gYzIgKiBhMiwgbik7XG4gICAgICAgICAgICBsZXQgazIgPSBtb2QoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBjb25zdCBrMm5lZyA9IGsyID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxID0gbiAtIGsxO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICAgICAgaWYgKGsxID4gUE9XXzJfMTI4IHx8IGsyID4gUE9XXzJfMTI4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhcjogRW5kb21vcnBoaXNtIGZhaWxlZCwgaz0nICsgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgICAgICB9LFxuICAgIH0sXG59LCBzaGEyNTYpO1xuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBmZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxUDtcbmNvbnN0IGdlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFOO1xuLyoqIEFuIG9iamVjdCBtYXBwaW5nIHRhZ3MgdG8gdGhlaXIgdGFnZ2VkIGhhc2ggcHJlZml4IG9mIFtTSEEyNTYodGFnKSB8IFNIQTI1Nih0YWcpXSAqL1xuY29uc3QgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcbmZ1bmN0aW9uIHRhZ2dlZEhhc2godGFnLCAuLi5tZXNzYWdlcykge1xuICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICBpZiAodGFnUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRhZ0ggPSBzaGEyNTYoVWludDhBcnJheS5mcm9tKHRhZywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgIH1cbiAgICByZXR1cm4gc2hhMjU2KGNvbmNhdEJ5dGVzKHRhZ1AsIC4uLm1lc3NhZ2VzKSk7XG59XG4vLyBFQ0RTQSBjb21wYWN0IHBvaW50cyBhcmUgMzMtYnl0ZS4gU2Nobm9yciBpcyAzMjogd2Ugc3RyaXAgZmlyc3QgYnl0ZSAweDAyIG9yIDB4MDNcbmNvbnN0IHBvaW50VG9CeXRlcyA9IChwb2ludCkgPT4gcG9pbnQudG9SYXdCeXRlcyh0cnVlKS5zbGljZSgxKTtcbmNvbnN0IG51bVRvMzJiID0gKG4pID0+IG51bWJlclRvQnl0ZXNCRShuLCAzMik7XG5jb25zdCBtb2RQID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFQKTtcbmNvbnN0IG1vZE4gPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMU4pO1xuY29uc3QgUG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50O1xuY29uc3QgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBzZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTsgLy8gc2FtZSBtZXRob2QgZXhlY3V0ZWQgaW4gZnJvbVByaXZhdGVLZXlcbiAgICBsZXQgcCA9IFBvaW50LmZyb21Qcml2YXRlS2V5KGRfKTsgLy8gUCA9IGQn4ouFRzsgMCA8IGQnIDwgbiBjaGVjayBpcyBkb25lIGluc2lkZVxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xuICAgIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgaWYgKCFmZSh4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgeDogbmVlZCAwIDwgeCA8IHAnKTsgLy8gRmFpbCBpZiB4IOKJpSBwLlxuICAgIGNvbnN0IHh4ID0gbW9kUCh4ICogeCk7XG4gICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuICAgIGxldCB5ID0gc3FydE1vZChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuXG4gICAgaWYgKHkgJSBfMm4gIT09IF8wbilcbiAgICAgICAgeSA9IG1vZFAoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcbiAgICBjb25zdCBwID0gbmV3IFBvaW50KHgsIHksIF8xbik7IC8vIHkoUCkgPSB5IGlmIHkgbW9kIDIgPSAwIG9yIHkoUCkgPSBwLXkgb3RoZXJ3aXNlLlxuICAgIHAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBtb2ROKGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gcmFuZG9tQnl0ZXMoMzIpKSB7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgICBjb25zdCBhID0gZW5zdXJlQnl0ZXMoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeIGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGEpKSk7IC8vIExldCB0IGJlIHRoZSBieXRlLXdpc2UgeG9yIG9mIGJ5dGVzKGQpIGFuZCBoYXNoL2F1eChhKVxuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICAgIGNvbnN0IGtfID0gbW9kTihieXRlc1RvTnVtYmVyQkUocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cbiAgICBpZiAoa18gPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogayBpcyB6ZXJvJyk7IC8vIEZhaWwgaWYgaycgPSAwLlxuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cbiAgICBjb25zdCBzaWcgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIExldCBzaWcgPSBieXRlcyhSKSB8fCBieXRlcygoayArIGVkKSBtb2QgbikuXG4gICAgc2lnLnNldChyeCwgMCk7XG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XG4gICAgLy8gSWYgVmVyaWZ5KGJ5dGVzKFApLCBtLCBzaWcpIChzZWUgYmVsb3cpIHJldHVybnMgZmFpbHVyZSwgYWJvcnRcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgcHViID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3goYnl0ZXNUb051bWJlckJFKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9IGJ5dGVzVG9OdW1iZXJCRShzaWcuc3ViYXJyYXkoMCwgMzIpKTsgLy8gTGV0IHIgPSBpbnQoc2lnWzA6MzJdKTsgZmFpbCBpZiByIOKJpSBwLlxuICAgICAgICBpZiAoIWZlKHIpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFnZShzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZSA9IGNoYWxsZW5nZShudW1UbzMyYihyKSwgcG9pbnRUb0J5dGVzKFApLCBtKTsgLy8gaW50KGNoYWxsZW5nZShieXRlcyhyKXx8Ynl0ZXMoUCl8fG0pKSVuXG4gICAgICAgIGNvbnN0IFIgPSBHbXVsQWRkKFAsIHMsIG1vZE4oLWUpKTsgLy8gUiA9IHPii4VHIC0gZeKLhVBcbiAgICAgICAgaWYgKCFSIHx8ICFSLmhhc0V2ZW5ZKCkgfHwgUi50b0FmZmluZSgpLnggIT09IHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIC1lUCA9PSAobi1lKVBcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEZhaWwgaWYgaXNfaW5maW5pdGUoUikgLyBub3QgaGFzX2V2ZW5feShSKSAvIHgoUikg4omgIHIuXG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICAgICAgbGlmdF94LFxuICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgIG51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpc29nZW55TWFwKEZwLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCB7XG4gICAgQTogQmlnSW50KCcweDNmODczMWFiZGQ2NjFhZGNhMDhhNTU1OGYwZjVkMjcyZTk1M2QzNjNjYjZmMGU1ZDQwNTQ0N2MwMWE0NDQ1MzMnKSxcbiAgICBCOiBCaWdJbnQoJzE3NzEnKSxcbiAgICBaOiBGcC5jcmVhdGUoQmlnSW50KCctMTEnKSksXG59KSkoKTtcbmNvbnN0IGh0ZiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnAuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTI1Nixcbn0pKSgpO1xuZXhwb3J0IGNvbnN0IGhhc2hUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmVuY29kZVRvQ3VydmUpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNwMjU2azEuanMubWFwIl0sIm5hbWVzIjpbInNoYTI1NiIsInJhbmRvbUJ5dGVzIiwiY3JlYXRlQ3VydmUiLCJjcmVhdGVIYXNoZXIiLCJpc29nZW55TWFwIiwiRmllbGQiLCJtb2QiLCJwb3cyIiwiYnl0ZXNUb051bWJlckJFIiwiY29uY2F0Qnl0ZXMiLCJlbnN1cmVCeXRlcyIsIm51bWJlclRvQnl0ZXNCRSIsIm1hcFRvQ3VydmVTaW1wbGVTV1UiLCJzZWNwMjU2azFQIiwiQmlnSW50Iiwic2VjcDI1NmsxTiIsIl8xbiIsIl8ybiIsImRpdk5lYXJlc3QiLCJhIiwiYiIsInNxcnRNb2QiLCJ5IiwiUCIsIl8zbiIsIl82biIsIl8xMW4iLCJfMjJuIiwiXzIzbiIsIl80NG4iLCJfODhuIiwiYjIiLCJiMyIsImI2IiwiYjkiLCJiMTEiLCJiMjIiLCJiNDQiLCJiODgiLCJiMTc2IiwiYjIyMCIsImIyMjMiLCJ0MSIsInQyIiwicm9vdCIsIkZwIiwiZXFsIiwic3FyIiwiRXJyb3IiLCJ1bmRlZmluZWQiLCJzcXJ0Iiwic2VjcDI1NmsxIiwibiIsIkd4IiwiR3kiLCJoIiwibG93UyIsImVuZG8iLCJiZXRhIiwic3BsaXRTY2FsYXIiLCJrIiwiYTEiLCJiMSIsImEyIiwiUE9XXzJfMTI4IiwiYzEiLCJjMiIsImsxIiwiazIiLCJrMW5lZyIsImsybmVnIiwiXzBuIiwiZmUiLCJ4IiwiZ2UiLCJUQUdHRURfSEFTSF9QUkVGSVhFUyIsInRhZ2dlZEhhc2giLCJ0YWciLCJtZXNzYWdlcyIsInRhZ1AiLCJ0YWdIIiwiVWludDhBcnJheSIsImZyb20iLCJjIiwiY2hhckNvZGVBdCIsInBvaW50VG9CeXRlcyIsInBvaW50IiwidG9SYXdCeXRlcyIsInNsaWNlIiwibnVtVG8zMmIiLCJtb2RQIiwibW9kTiIsIlBvaW50IiwiUHJvamVjdGl2ZVBvaW50IiwiR211bEFkZCIsIlEiLCJCQVNFIiwibXVsdGlwbHlBbmRBZGRVbnNhZmUiLCJzY2hub3JyR2V0RXh0UHViS2V5IiwicHJpdiIsImRfIiwidXRpbHMiLCJub3JtUHJpdmF0ZUtleVRvU2NhbGFyIiwicCIsImZyb21Qcml2YXRlS2V5Iiwic2NhbGFyIiwiaGFzRXZlblkiLCJieXRlcyIsImxpZnRfeCIsInh4IiwiYXNzZXJ0VmFsaWRpdHkiLCJjaGFsbGVuZ2UiLCJhcmdzIiwic2Nobm9yckdldFB1YmxpY0tleSIsInByaXZhdGVLZXkiLCJzY2hub3JyU2lnbiIsIm1lc3NhZ2UiLCJhdXhSYW5kIiwibSIsInB4IiwiZCIsInQiLCJyYW5kIiwia18iLCJyeCIsImUiLCJzaWciLCJzZXQiLCJzY2hub3JyVmVyaWZ5Iiwic2lnbmF0dXJlIiwicHVibGljS2V5IiwicHViIiwiciIsInN1YmFycmF5IiwicyIsIlIiLCJ0b0FmZmluZSIsImVycm9yIiwic2Nobm9yciIsImdldFB1YmxpY0tleSIsInNpZ24iLCJ2ZXJpZnkiLCJyYW5kb21Qcml2YXRlS2V5IiwiaXNvTWFwIiwibWFwIiwiaSIsImoiLCJtYXBTV1UiLCJBIiwiQiIsIloiLCJjcmVhdGUiLCJodGYiLCJzY2FsYXJzIiwiRFNUIiwiZW5jb2RlRFNUIiwiT1JERVIiLCJleHBhbmQiLCJoYXNoIiwiaGFzaFRvQ3VydmUiLCJlbmNvZGVUb0N1cnZlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/@noble/curves/esm/secp256k1.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/@noble/hashes/esm/_assert.js":
/*!****************************************************!*\
  !*** ../node_modules/@noble/hashes/esm/_assert.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== \"boolean\") throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b)) throw new Error(\"Uint8Array expected\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== \"function\" || typeof h.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert); //# sourceMappingURL=_assert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxTQUFTQSxPQUFPQyxDQUFDO0lBQ2IsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNGLE1BQU1BLElBQUksR0FDaEMsTUFBTSxJQUFJRyxNQUFNLENBQUMsK0JBQStCLEVBQUVILEVBQUUsQ0FBQztBQUM3RDtBQUNBLFNBQVNJLEtBQUtDLENBQUM7SUFDWCxJQUFJLE9BQU9BLE1BQU0sV0FDYixNQUFNLElBQUlGLE1BQU0sQ0FBQyxzQkFBc0IsRUFBRUUsRUFBRSxDQUFDO0FBQ3BEO0FBQ0Esb0JBQW9CO0FBQ2IsU0FBU0MsUUFBUUMsQ0FBQztJQUNyQixPQUFRQSxhQUFhQyxjQUNoQkQsS0FBSyxRQUFRLE9BQU9BLE1BQU0sWUFBWUEsRUFBRUUsV0FBVyxDQUFDQyxJQUFJLEtBQUs7QUFDdEU7QUFDQSxTQUFTQyxNQUFNTixDQUFDLEVBQUUsR0FBR08sT0FBTztJQUN4QixJQUFJLENBQUNOLFFBQVFELElBQ1QsTUFBTSxJQUFJRixNQUFNO0lBQ3BCLElBQUlTLFFBQVFDLE1BQU0sR0FBRyxLQUFLLENBQUNELFFBQVFFLFFBQVEsQ0FBQ1QsRUFBRVEsTUFBTSxHQUNoRCxNQUFNLElBQUlWLE1BQU0sQ0FBQyw4QkFBOEIsRUFBRVMsUUFBUSxnQkFBZ0IsRUFBRVAsRUFBRVEsTUFBTSxDQUFDLENBQUM7QUFDN0Y7QUFDQSxTQUFTRSxLQUFLQyxDQUFDO0lBQ1gsSUFBSSxPQUFPQSxNQUFNLGNBQWMsT0FBT0EsRUFBRUMsTUFBTSxLQUFLLFlBQy9DLE1BQU0sSUFBSWQsTUFBTTtJQUNwQkosT0FBT2lCLEVBQUVFLFNBQVM7SUFDbEJuQixPQUFPaUIsRUFBRUcsUUFBUTtBQUNyQjtBQUNBLFNBQVNDLE9BQU9DLFFBQVEsRUFBRUMsZ0JBQWdCLElBQUk7SUFDMUMsSUFBSUQsU0FBU0UsU0FBUyxFQUNsQixNQUFNLElBQUlwQixNQUFNO0lBQ3BCLElBQUltQixpQkFBaUJELFNBQVNHLFFBQVEsRUFDbEMsTUFBTSxJQUFJckIsTUFBTTtBQUN4QjtBQUNBLFNBQVNzQixPQUFPQyxHQUFHLEVBQUVMLFFBQVE7SUFDekJWLE1BQU1lO0lBQ04sTUFBTUMsTUFBTU4sU0FBU0gsU0FBUztJQUM5QixJQUFJUSxJQUFJYixNQUFNLEdBQUdjLEtBQUs7UUFDbEIsTUFBTSxJQUFJeEIsTUFBTSxDQUFDLHNEQUFzRCxFQUFFd0IsSUFBSSxDQUFDO0lBQ2xGO0FBQ0o7QUFDcUQ7QUFDckQsTUFBTUMsU0FBUztJQUFFN0I7SUFBUUs7SUFBTU87SUFBT0k7SUFBTUs7SUFBUUs7QUFBTztBQUMzRCxpRUFBZUcsTUFBTUEsRUFBQyxDQUN0QixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanM/ZTFhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcG9zaXRpdmUgaW50ZWdlciBleHBlY3RlZCwgbm90ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJvb2xlYW4gZXhwZWN0ZWQsIG5vdCAke2J9YCk7XG59XG4vLyBjb3BpZWQgZnJvbSB1dGlsc1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmZ1bmN0aW9uIGhhc2goaCkge1xuICAgIGlmICh0eXBlb2YgaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoLmJsb2NrTGVuKTtcbn1cbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydCB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5jb25zdCBhc3NlcnQgPSB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6WyJudW1iZXIiLCJuIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwiYm9vbCIsImIiLCJpc0J5dGVzIiwiYSIsIlVpbnQ4QXJyYXkiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJieXRlcyIsImxlbmd0aHMiLCJsZW5ndGgiLCJpbmNsdWRlcyIsImhhc2giLCJoIiwiY3JlYXRlIiwib3V0cHV0TGVuIiwiYmxvY2tMZW4iLCJleGlzdHMiLCJpbnN0YW5jZSIsImNoZWNrRmluaXNoZWQiLCJkZXN0cm95ZWQiLCJmaW5pc2hlZCIsIm91dHB1dCIsIm91dCIsIm1pbiIsImFzc2VydCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/@noble/hashes/esm/_assert.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/@noble/hashes/esm/_md.js":
/*!************************************************!*\
  !*** ../node_modules/@noble/hashes/esm/_md.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: () => (/* binding */ Chi),\n/* harmony export */   HashMD: () => (/* binding */ HashMD),\n/* harmony export */   Maj: () => (/* binding */ Maj)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(rsc)/../node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/../node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === \"function\") return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Choice: a ? b : c\nconst Chi = (a, b, c)=>a & b ^ ~a & c;\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c)=>a & b ^ a & c ^ b & c;\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */ class HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error(\"_sha2: outputLen bigger than state\");\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n} //# sourceMappingURL=_md.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19tZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE4QztBQUNTO0FBQ3ZELHlCQUF5QjtBQUN6QixTQUFTSyxhQUFhQyxJQUFJLEVBQUVDLFVBQVUsRUFBRUMsS0FBSyxFQUFFQyxJQUFJO0lBQy9DLElBQUksT0FBT0gsS0FBS0QsWUFBWSxLQUFLLFlBQzdCLE9BQU9DLEtBQUtELFlBQVksQ0FBQ0UsWUFBWUMsT0FBT0M7SUFDaEQsTUFBTUMsT0FBT0MsT0FBTztJQUNwQixNQUFNQyxXQUFXRCxPQUFPO0lBQ3hCLE1BQU1FLEtBQUtDLE9BQU8sU0FBVUosT0FBUUU7SUFDcEMsTUFBTUcsS0FBS0QsT0FBT04sUUFBUUk7SUFDMUIsTUFBTUksSUFBSVAsT0FBTyxJQUFJO0lBQ3JCLE1BQU1RLElBQUlSLE9BQU8sSUFBSTtJQUNyQkgsS0FBS1ksU0FBUyxDQUFDWCxhQUFhUyxHQUFHSCxJQUFJSjtJQUNuQ0gsS0FBS1ksU0FBUyxDQUFDWCxhQUFhVSxHQUFHRixJQUFJTjtBQUN2QztBQUNBLG9CQUFvQjtBQUNiLE1BQU1VLE1BQU0sQ0FBQ0MsR0FBR0MsR0FBR0MsSUFBTSxJQUFLRCxJQUFNLENBQUNELElBQUlFLEVBQUc7QUFDbkQsb0RBQW9EO0FBQzdDLE1BQU1DLE1BQU0sQ0FBQ0gsR0FBR0MsR0FBR0MsSUFBTSxJQUFLRCxJQUFNRCxJQUFJRSxJQUFNRCxJQUFJQyxFQUFHO0FBQzVEOzs7Q0FHQyxHQUNNLE1BQU1FLGVBQWV0QiwyQ0FBSUE7SUFDNUJ1QixZQUFZQyxRQUFRLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFbkIsSUFBSSxDQUFFO1FBQzlDLEtBQUs7UUFDTCxJQUFJLENBQUNpQixRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDbkIsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ29CLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsR0FBRyxHQUFHO1FBQ1gsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSUMsV0FBV1I7UUFDN0IsSUFBSSxDQUFDcEIsSUFBSSxHQUFHSCxxREFBVUEsQ0FBQyxJQUFJLENBQUM4QixNQUFNO0lBQ3RDO0lBQ0FFLE9BQU9DLElBQUksRUFBRTtRQUNUcEMsa0RBQU1BLENBQUMsSUFBSTtRQUNYLE1BQU0sRUFBRU0sSUFBSSxFQUFFMkIsTUFBTSxFQUFFUCxRQUFRLEVBQUUsR0FBRyxJQUFJO1FBQ3ZDVSxPQUFPaEMsa0RBQU9BLENBQUNnQztRQUNmLE1BQU1DLE1BQU1ELEtBQUtOLE1BQU07UUFDdkIsSUFBSyxJQUFJQyxNQUFNLEdBQUdBLE1BQU1NLEtBQU07WUFDMUIsTUFBTUMsT0FBT0MsS0FBS0MsR0FBRyxDQUFDZCxXQUFXLElBQUksQ0FBQ0ssR0FBRyxFQUFFTSxNQUFNTjtZQUNqRCw4RUFBOEU7WUFDOUUsSUFBSU8sU0FBU1osVUFBVTtnQkFDbkIsTUFBTWUsV0FBV3RDLHFEQUFVQSxDQUFDaUM7Z0JBQzVCLE1BQU9WLFlBQVlXLE1BQU1OLEtBQUtBLE9BQU9MLFNBQ2pDLElBQUksQ0FBQ2dCLE9BQU8sQ0FBQ0QsVUFBVVY7Z0JBQzNCO1lBQ0o7WUFDQUUsT0FBT1UsR0FBRyxDQUFDUCxLQUFLUSxRQUFRLENBQUNiLEtBQUtBLE1BQU1PLE9BQU8sSUFBSSxDQUFDUCxHQUFHO1lBQ25ELElBQUksQ0FBQ0EsR0FBRyxJQUFJTztZQUNaUCxPQUFPTztZQUNQLElBQUksSUFBSSxDQUFDUCxHQUFHLEtBQUtMLFVBQVU7Z0JBQ3ZCLElBQUksQ0FBQ2dCLE9BQU8sQ0FBQ3BDLE1BQU07Z0JBQ25CLElBQUksQ0FBQ3lCLEdBQUcsR0FBRztZQUNmO1FBQ0o7UUFDQSxJQUFJLENBQUNELE1BQU0sSUFBSU0sS0FBS04sTUFBTTtRQUMxQixJQUFJLENBQUNlLFVBQVU7UUFDZixPQUFPLElBQUk7SUFDZjtJQUNBQyxXQUFXQyxHQUFHLEVBQUU7UUFDWi9DLGtEQUFNQSxDQUFDLElBQUk7UUFDWEMsa0RBQU1BLENBQUM4QyxLQUFLLElBQUk7UUFDaEIsSUFBSSxDQUFDbEIsUUFBUSxHQUFHO1FBQ2hCLFVBQVU7UUFDVixpRUFBaUU7UUFDakUsc0VBQXNFO1FBQ3RFLE1BQU0sRUFBRUksTUFBTSxFQUFFM0IsSUFBSSxFQUFFb0IsUUFBUSxFQUFFakIsSUFBSSxFQUFFLEdBQUcsSUFBSTtRQUM3QyxJQUFJLEVBQUVzQixHQUFHLEVBQUUsR0FBRyxJQUFJO1FBQ2xCLG9DQUFvQztRQUNwQ0UsTUFBTSxDQUFDRixNQUFNLEdBQUc7UUFDaEIsSUFBSSxDQUFDRSxNQUFNLENBQUNXLFFBQVEsQ0FBQ2IsS0FBS2lCLElBQUksQ0FBQztRQUMvQix5RUFBeUU7UUFDekUsK0NBQStDO1FBQy9DLElBQUksSUFBSSxDQUFDcEIsU0FBUyxHQUFHRixXQUFXSyxLQUFLO1lBQ2pDLElBQUksQ0FBQ1csT0FBTyxDQUFDcEMsTUFBTTtZQUNuQnlCLE1BQU07UUFDVjtRQUNBLHVDQUF1QztRQUN2QyxJQUFLLElBQUlrQixJQUFJbEIsS0FBS2tCLElBQUl2QixVQUFVdUIsSUFDNUJoQixNQUFNLENBQUNnQixFQUFFLEdBQUc7UUFDaEIsZ0dBQWdHO1FBQ2hHLG9GQUFvRjtRQUNwRixpREFBaUQ7UUFDakQ1QyxhQUFhQyxNQUFNb0IsV0FBVyxHQUFHZixPQUFPLElBQUksQ0FBQ21CLE1BQU0sR0FBRyxJQUFJckI7UUFDMUQsSUFBSSxDQUFDaUMsT0FBTyxDQUFDcEMsTUFBTTtRQUNuQixNQUFNNEMsUUFBUS9DLHFEQUFVQSxDQUFDNEM7UUFDekIsTUFBTVYsTUFBTSxJQUFJLENBQUNWLFNBQVM7UUFDMUIseUZBQXlGO1FBQ3pGLElBQUlVLE1BQU0sR0FDTixNQUFNLElBQUljLE1BQU07UUFDcEIsTUFBTUMsU0FBU2YsTUFBTTtRQUNyQixNQUFNZ0IsUUFBUSxJQUFJLENBQUNDLEdBQUc7UUFDdEIsSUFBSUYsU0FBU0MsTUFBTXZCLE1BQU0sRUFDckIsTUFBTSxJQUFJcUIsTUFBTTtRQUNwQixJQUFLLElBQUlGLElBQUksR0FBR0EsSUFBSUcsUUFBUUgsSUFDeEJDLE1BQU1oQyxTQUFTLENBQUMsSUFBSStCLEdBQUdJLEtBQUssQ0FBQ0osRUFBRSxFQUFFeEM7SUFDekM7SUFDQThDLFNBQVM7UUFDTCxNQUFNLEVBQUV0QixNQUFNLEVBQUVOLFNBQVMsRUFBRSxHQUFHLElBQUk7UUFDbEMsSUFBSSxDQUFDbUIsVUFBVSxDQUFDYjtRQUNoQixNQUFNdUIsTUFBTXZCLE9BQU93QixLQUFLLENBQUMsR0FBRzlCO1FBQzVCLElBQUksQ0FBQytCLE9BQU87UUFDWixPQUFPRjtJQUNYO0lBQ0FHLFdBQVdDLEVBQUUsRUFBRTtRQUNYQSxNQUFPQSxDQUFBQSxLQUFLLElBQUksSUFBSSxDQUFDbkMsV0FBVyxFQUFDO1FBQ2pDbUMsR0FBR2pCLEdBQUcsSUFBSSxJQUFJLENBQUNXLEdBQUc7UUFDbEIsTUFBTSxFQUFFNUIsUUFBUSxFQUFFTyxNQUFNLEVBQUVILE1BQU0sRUFBRUQsUUFBUSxFQUFFRyxTQUFTLEVBQUVELEdBQUcsRUFBRSxHQUFHLElBQUk7UUFDbkU2QixHQUFHOUIsTUFBTSxHQUFHQTtRQUNaOEIsR0FBRzdCLEdBQUcsR0FBR0E7UUFDVDZCLEdBQUcvQixRQUFRLEdBQUdBO1FBQ2QrQixHQUFHNUIsU0FBUyxHQUFHQTtRQUNmLElBQUlGLFNBQVNKLFVBQ1RrQyxHQUFHM0IsTUFBTSxDQUFDVSxHQUFHLENBQUNWO1FBQ2xCLE9BQU8yQjtJQUNYO0FBQ0osRUFDQSwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19tZC5qcz8wNzQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4aXN0cywgb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIGNyZWF0ZVZpZXcsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuZXhwb3J0IGNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXG5leHBvcnQgY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8qKlxuICogTWVya2xlLURhbWdhcmQgaGFzaCBjb25zdHJ1Y3Rpb24gYmFzZSBjbGFzcy5cbiAqIENvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIE1ENSwgUklQRU1ELCBTSEExLCBTSEEyLlxuICovXG5leHBvcnQgY2xhc3MgSGFzaE1EIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW5cbiAgICAgICAgLy8gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fbWQuanMubWFwIl0sIm5hbWVzIjpbImV4aXN0cyIsIm91dHB1dCIsIkhhc2giLCJjcmVhdGVWaWV3IiwidG9CeXRlcyIsInNldEJpZ1VpbnQ2NCIsInZpZXciLCJieXRlT2Zmc2V0IiwidmFsdWUiLCJpc0xFIiwiXzMybiIsIkJpZ0ludCIsIl91MzJfbWF4Iiwid2giLCJOdW1iZXIiLCJ3bCIsImgiLCJsIiwic2V0VWludDMyIiwiQ2hpIiwiYSIsImIiLCJjIiwiTWFqIiwiSGFzaE1EIiwiY29uc3RydWN0b3IiLCJibG9ja0xlbiIsIm91dHB1dExlbiIsInBhZE9mZnNldCIsImZpbmlzaGVkIiwibGVuZ3RoIiwicG9zIiwiZGVzdHJveWVkIiwiYnVmZmVyIiwiVWludDhBcnJheSIsInVwZGF0ZSIsImRhdGEiLCJsZW4iLCJ0YWtlIiwiTWF0aCIsIm1pbiIsImRhdGFWaWV3IiwicHJvY2VzcyIsInNldCIsInN1YmFycmF5Iiwicm91bmRDbGVhbiIsImRpZ2VzdEludG8iLCJvdXQiLCJmaWxsIiwiaSIsIm92aWV3IiwiRXJyb3IiLCJvdXRMZW4iLCJzdGF0ZSIsImdldCIsImRpZ2VzdCIsInJlcyIsInNsaWNlIiwiZGVzdHJveSIsIl9jbG9uZUludG8iLCJ0byJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/@noble/hashes/esm/_md.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/@noble/hashes/esm/_u64.js":
/*!*************************************************!*\
  !*** ../node_modules/@noble/hashes/esm/_u64.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le) return {\n        h: Number(n & U32_MASK64),\n        l: Number(n >> _32n & U32_MASK64)\n    };\n    return {\n        h: Number(n >> _32n & U32_MASK64) | 0,\n        l: Number(n & U32_MASK64) | 0\n    };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for(let i = 0; i < lst.length; i++){\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\nconst toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s)=>h >>> s;\nconst shrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\nconst rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\nconst rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l)=>l;\nconst rotr32L = (h, _l)=>h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\nconst rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\nconst rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nconst add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig,\n    split,\n    toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64); //# sourceMappingURL=_u64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFNQSxhQUFhLGFBQWEsR0FBR0MsT0FBTyxLQUFLLEtBQUs7QUFDcEQsTUFBTUMsT0FBTyxhQUFhLEdBQUdELE9BQU87QUFDcEMsK0VBQStFO0FBQy9FLFNBQVNFLFFBQVFDLENBQUMsRUFBRUMsS0FBSyxLQUFLO0lBQzFCLElBQUlBLElBQ0EsT0FBTztRQUFFQyxHQUFHQyxPQUFPSCxJQUFJSjtRQUFhUSxHQUFHRCxPQUFPLEtBQU1MLE9BQVFGO0lBQVk7SUFDNUUsT0FBTztRQUFFTSxHQUFHQyxPQUFPLEtBQU1MLE9BQVFGLGNBQWM7UUFBR1EsR0FBR0QsT0FBT0gsSUFBSUosY0FBYztJQUFFO0FBQ3BGO0FBQ0EsU0FBU1MsTUFBTUMsR0FBRyxFQUFFTCxLQUFLLEtBQUs7SUFDMUIsSUFBSU0sS0FBSyxJQUFJQyxZQUFZRixJQUFJRyxNQUFNO0lBQ25DLElBQUlDLEtBQUssSUFBSUYsWUFBWUYsSUFBSUcsTUFBTTtJQUNuQyxJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSUwsSUFBSUcsTUFBTSxFQUFFRSxJQUFLO1FBQ2pDLE1BQU0sRUFBRVQsQ0FBQyxFQUFFRSxDQUFDLEVBQUUsR0FBR0wsUUFBUU8sR0FBRyxDQUFDSyxFQUFFLEVBQUVWO1FBQ2pDLENBQUNNLEVBQUUsQ0FBQ0ksRUFBRSxFQUFFRCxFQUFFLENBQUNDLEVBQUUsQ0FBQyxHQUFHO1lBQUNUO1lBQUdFO1NBQUU7SUFDM0I7SUFDQSxPQUFPO1FBQUNHO1FBQUlHO0tBQUc7QUFDbkI7QUFDQSxNQUFNRSxRQUFRLENBQUNWLEdBQUdFLElBQU0sT0FBUUYsTUFBTSxNQUFNSixPQUFRRCxPQUFPTyxNQUFNO0FBQ2pFLHVCQUF1QjtBQUN2QixNQUFNUyxRQUFRLENBQUNYLEdBQUdZLElBQUlDLElBQU1iLE1BQU1hO0FBQ2xDLE1BQU1D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QWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzP2RjYjYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgVTMyX01BU0s2NCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMzIpO1xuLy8gV2UgYXJlIG5vdCB1c2luZyBCaWdVaW50NjRBcnJheSwgYmVjYXVzZSB0aGV5IGFyZSBleHRyZW1lbHkgc2xvdyBhcyBwZXIgMjAyMlxuZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0KGxzdCwgbGUgPSBmYWxzZSkge1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBfbCwgcykgPT4gaCA+Pj4gcztcbmNvbnN0IHNoclNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90clNIID0gKGgsIGwsIHMpID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmNvbnN0IHJvdHJCTCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gKHMgLSAzMikpIHwgKGwgPDwgKDY0IC0gcykpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoX2gsIGwpID0+IGw7XG5jb25zdCByb3RyMzJMID0gKGgsIF9sKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgeyBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsIHNoclNILCBzaHJTTCwgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLCByb3RyMzJILCByb3RyMzJMLCByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCwgfTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnQgZGVmYXVsdCB1NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCJdLCJuYW1lcyI6WyJVMzJfTUFTSzY0IiwiQmlnSW50IiwiXzMybiIsImZyb21CaWciLCJuIiwibGUiLCJoIiwiTnVtYmVyIiwibCIsInNwbGl0IiwibHN0IiwiQWgiLCJVaW50MzJBcnJheSIsImxlbmd0aCIsIkFsIiwiaSIsInRvQmlnIiwic2hyU0giLCJfbCIsInMiLCJzaHJTTCIsInJvdHJTSCIsInJvdHJTTCIsInJvdHJCSCIsInJvdHJCTCIsInJvdHIzMkgiLCJfaCIsInJvdHIzMkwiLCJyb3RsU0giLCJyb3RsU0wiLCJyb3RsQkgiLCJyb3RsQkwiLCJhZGQiLCJCaCIsIkJsIiwiYWRkM0wiLCJDbCIsImFkZDNIIiwibG93IiwiQ2giLCJhZGQ0TCIsIkRsIiwiYWRkNEgiLCJEaCIsImFkZDVMIiwiRWwiLCJhZGQ1SCIsIkVoIiwidTY0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/@noble/hashes/esm/_u64.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/@noble/hashes/esm/cryptoNode.js":
/*!*******************************************************!*\
  !*** ../node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === \"object\" && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : undefined; //# sourceMappingURL=cryptoNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0b05vZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsb0ZBQW9GO0FBQ3BGLDRCQUE0QjtBQUM1QixpREFBaUQ7QUFDakQsYUFBYTtBQUNxQjtBQUMzQixNQUFNQyxTQUFTRCwyTUFBRUEsSUFBSSxPQUFPQSwyTUFBRUEsS0FBSyxZQUFZLDBOQUFpQkEsR0FBR0Esa0RBQVksR0FBR0csVUFBVSxDQUNuRyxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0b05vZGUuanM/ZWU0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIFNlZSB1dGlscy50cyBmb3IgZGV0YWlscy5cbi8vIFRoZSBmaWxlIHdpbGwgdGhyb3cgb24gbm9kZS5qcyAxNCBhbmQgZWFybGllci5cbi8vIEB0cy1pZ25vcmVcbmltcG9ydCAqIGFzIG5jIGZyb20gJ25vZGU6Y3J5cHRvJztcbmV4cG9ydCBjb25zdCBjcnlwdG8gPSBuYyAmJiB0eXBlb2YgbmMgPT09ICdvYmplY3QnICYmICd3ZWJjcnlwdG8nIGluIG5jID8gbmMud2ViY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvTm9kZS5qcy5tYXAiXSwibmFtZXMiOlsibmMiLCJjcnlwdG8iLCJ3ZWJjcnlwdG8iLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/@noble/hashes/esm/hmac.js":
/*!*************************************************!*\
  !*** ../node_modules/@noble/hashes/esm/hmac.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(rsc)/../node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/../node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRztBQUNyRDtBQUMzQyxrQkFBa0I7QUFDWCxNQUFNUSxhQUFhRiwyQ0FBSUE7SUFDMUJHLFlBQVlULElBQUksRUFBRVUsSUFBSSxDQUFFO1FBQ3BCLEtBQUs7UUFDTCxJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFNBQVMsR0FBRztRQUNqQlgsZ0RBQVVBLENBQUNEO1FBQ1gsTUFBTWEsTUFBTU4sa0RBQU9BLENBQUNHO1FBQ3BCLElBQUksQ0FBQ0ksS0FBSyxHQUFHZCxLQUFLZSxNQUFNO1FBQ3hCLElBQUksT0FBTyxJQUFJLENBQUNELEtBQUssQ0FBQ0UsTUFBTSxLQUFLLFlBQzdCLE1BQU0sSUFBSUMsTUFBTTtRQUNwQixJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJLENBQUNKLEtBQUssQ0FBQ0ksUUFBUTtRQUNuQyxJQUFJLENBQUNDLFNBQVMsR0FBRyxJQUFJLENBQUNMLEtBQUssQ0FBQ0ssU0FBUztRQUNyQyxNQUFNRCxXQUFXLElBQUksQ0FBQ0EsUUFBUTtRQUM5QixNQUFNRSxNQUFNLElBQUlDLFdBQVdIO1FBQzNCLHdDQUF3QztRQUN4Q0UsSUFBSUUsR0FBRyxDQUFDVCxJQUFJVSxNQUFNLEdBQUdMLFdBQVdsQixLQUFLZSxNQUFNLEdBQUdDLE1BQU0sQ0FBQ0gsS0FBS1csTUFBTSxLQUFLWDtRQUNyRSxJQUFLLElBQUlZLElBQUksR0FBR0EsSUFBSUwsSUFBSUcsTUFBTSxFQUFFRSxJQUM1QkwsR0FBRyxDQUFDSyxFQUFFLElBQUk7UUFDZCxJQUFJLENBQUNYLEtBQUssQ0FBQ0UsTUFBTSxDQUFDSTtRQUNsQixtSEFBbUg7UUFDbkgsSUFBSSxDQUFDTSxLQUFLLEdBQUcxQixLQUFLZSxNQUFNO1FBQ3hCLHVDQUF1QztRQUN2QyxJQUFLLElBQUlVLElBQUksR0FBR0EsSUFBSUwsSUFBSUcsTUFBTSxFQUFFRSxJQUM1QkwsR0FBRyxDQUFDSyxFQUFFLElBQUksT0FBTztRQUNyQixJQUFJLENBQUNDLEtBQUssQ0FBQ1YsTUFBTSxDQUFDSTtRQUNsQkEsSUFBSU8sSUFBSSxDQUFDO0lBQ2I7SUFDQVgsT0FBT1ksR0FBRyxFQUFFO1FBQ1J2QixrREFBWUEsQ0FBQyxJQUFJO1FBQ2pCLElBQUksQ0FBQ1MsS0FBSyxDQUFDRSxNQUFNLENBQUNZO1FBQ2xCLE9BQU8sSUFBSTtJQUNmO0lBQ0FDLFdBQVdDLEdBQUcsRUFBRTtRQUNaekIsa0RBQVlBLENBQUMsSUFBSTtRQUNqQkYsaURBQVdBLENBQUMyQixLQUFLLElBQUksQ0FBQ1gsU0FBUztRQUMvQixJQUFJLENBQUNSLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNHLEtBQUssQ0FBQ2UsVUFBVSxDQUFDQztRQUN0QixJQUFJLENBQUNKLEtBQUssQ0FBQ1YsTUFBTSxDQUFDYztRQUNsQixJQUFJLENBQUNKLEtBQUssQ0FBQ0csVUFBVSxDQUFDQztRQUN0QixJQUFJLENBQUNDLE9BQU87SUFDaEI7SUFDQVAsU0FBUztRQUNMLE1BQU1NLE1BQU0sSUFBSVQsV0FBVyxJQUFJLENBQUNLLEtBQUssQ0FBQ1AsU0FBUztRQUMvQyxJQUFJLENBQUNVLFVBQVUsQ0FBQ0M7UUFDaEIsT0FBT0E7SUFDWDtJQUNBRSxXQUFXQyxFQUFFLEVBQUU7UUFDWCxtR0FBbUc7UUFDbkdBLE1BQU9BLENBQUFBLEtBQUtDLE9BQU9uQixNQUFNLENBQUNtQixPQUFPQyxjQUFjLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBQztRQUN6RCxNQUFNLEVBQUVULEtBQUssRUFBRVosS0FBSyxFQUFFSCxRQUFRLEVBQUVDLFNBQVMsRUFBRU0sUUFBUSxFQUFFQyxTQUFTLEVBQUUsR0FBRyxJQUFJO1FBQ3ZFYyxLQUFLQTtRQUNMQSxHQUFHdEIsUUFBUSxHQUFHQTtRQUNkc0IsR0FBR3JCLFNBQVMsR0FBR0E7UUFDZnFCLEdBQUdmLFFBQVEsR0FBR0E7UUFDZGUsR0FBR2QsU0FBUyxHQUFHQTtRQUNmYyxHQUFHUCxLQUFLLEdBQUdBLE1BQU1NLFVBQVUsQ0FBQ0MsR0FBR1AsS0FBSztRQUNwQ08sR0FBR25CLEtBQUssR0FBR0EsTUFBTWtCLFVBQVUsQ0FBQ0MsR0FBR25CLEtBQUs7UUFDcEMsT0FBT21CO0lBQ1g7SUFDQUYsVUFBVTtRQUNOLElBQUksQ0FBQ25CLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNjLEtBQUssQ0FBQ0ssT0FBTztRQUNsQixJQUFJLENBQUNqQixLQUFLLENBQUNpQixPQUFPO0lBQ3RCO0FBQ0o7QUFDQTs7Ozs7Q0FLQyxHQUNNLE1BQU1LLE9BQU8sQ0FBQ3BDLE1BQU1hLEtBQUt3QixVQUFZLElBQUk3QixLQUFLUixNQUFNYSxLQUFLRyxNQUFNLENBQUNxQixTQUFTYixNQUFNLEdBQUc7QUFDekZZLEtBQUtyQixNQUFNLEdBQUcsQ0FBQ2YsTUFBTWEsTUFBUSxJQUFJTCxLQUFLUixNQUFNYSxNQUM1QyxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanM/N2Q1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXNoIGFzIGFzc2VydEhhc2gsIGJ5dGVzIGFzIGFzc2VydEJ5dGVzLCBleGlzdHMgYXMgYXNzZXJ0RXhpc3RzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIEhNQUMgKFJGQyAyMTA0KVxuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYXNzZXJ0SGFzaChoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdG9CeXRlcyhfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydEJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOlsiaGFzaCIsImFzc2VydEhhc2giLCJieXRlcyIsImFzc2VydEJ5dGVzIiwiZXhpc3RzIiwiYXNzZXJ0RXhpc3RzIiwiSGFzaCIsInRvQnl0ZXMiLCJITUFDIiwiY29uc3RydWN0b3IiLCJfa2V5IiwiZmluaXNoZWQiLCJkZXN0cm95ZWQiLCJrZXkiLCJpSGFzaCIsImNyZWF0ZSIsInVwZGF0ZSIsIkVycm9yIiwiYmxvY2tMZW4iLCJvdXRwdXRMZW4iLCJwYWQiLCJVaW50OEFycmF5Iiwic2V0IiwibGVuZ3RoIiwiZGlnZXN0IiwiaSIsIm9IYXNoIiwiZmlsbCIsImJ1ZiIsImRpZ2VzdEludG8iLCJvdXQiLCJkZXN0cm95IiwiX2Nsb25lSW50byIsInRvIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJobWFjIiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/@noble/hashes/esm/sha256.js":
/*!***************************************************!*\
  !*** ../node_modules/@noble/hashes/esm/sha256.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(rsc)/../node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/../node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(){\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ W2 >>> 10;\n            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor(){\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */ const sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new SHA224()); //# sourceMappingURL=sha256.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTRDO0FBQ087QUFDbkQsZ0VBQWdFO0FBQ2hFLDBEQUEwRDtBQUMxRCxtQkFBbUI7QUFDbkIseUZBQXlGO0FBQ3pGLGtCQUFrQjtBQUNsQixNQUFNSyxXQUFXLGFBQWEsR0FBRyxJQUFJQyxZQUFZO0lBQzdDO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUN2RjtBQUNELGlCQUFpQjtBQUNqQix3RkFBd0Y7QUFDeEYsa0JBQWtCO0FBQ2xCLE1BQU1DLFlBQVksYUFBYSxHQUFHLElBQUlELFlBQVk7SUFDOUM7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUN2RjtBQUNELDREQUE0RDtBQUM1RCxtREFBbUQ7QUFDbkQsTUFBTUUsV0FBVyxhQUFhLEdBQUcsSUFBSUYsWUFBWTtBQUNqRCxNQUFNRyxlQUFlVCwwQ0FBTUE7SUFDdkJVLGFBQWM7UUFDVixLQUFLLENBQUMsSUFBSSxJQUFJLEdBQUc7UUFDakIsbUVBQW1FO1FBQ25FLHVEQUF1RDtRQUN2RCxJQUFJLENBQUNDLENBQUMsR0FBR0osU0FBUyxDQUFDLEVBQUUsR0FBRztRQUN4QixJQUFJLENBQUNLLENBQUMsR0FBR0wsU0FBUyxD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QUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDcUIsU0FBUyxHQUFHO0lBQ3JCO0FBQ0o7QUFDQTs7O0NBR0MsR0FDTSxNQUFNQyxTQUFTLGFBQWEsR0FBR3BDLDBEQUFlQSxDQUFDLElBQU0sSUFBSUssVUFBVTtBQUNuRSxNQUFNZ0MsU0FBUyxhQUFhLEdBQUdyQywwREFBZUEsQ0FBQyxJQUFNLElBQUlrQyxVQUFVLENBQzFFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzPzcxOTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGFzaE1ELCBDaGksIE1haiB9IGZyb20gJy4vX21kLmpzJztcbmltcG9ydCB7IHJvdHIsIHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMi0yNTYgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzIHRvIGV4ZWN1dGUgYmlydGhkYXkgYXR0YWNrLlxuLy8gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl42NyBoYXNoZXMvc2VjIGFzIHBlciBlYXJseSAyMDIzLlxuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZTpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0lWID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gU0hBMjU2X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gU0hBMjU2X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMjU2X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gU0hBMjU2X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gU0hBMjU2X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gU0hBMjU2X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gU0hBMjU2X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gU0hBMjU2X0lWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbIkhhc2hNRCIsIkNoaSIsIk1haiIsInJvdHIiLCJ3cmFwQ29uc3RydWN0b3IiLCJTSEEyNTZfSyIsIlVpbnQzMkFycmF5IiwiU0hBMjU2X0lWIiwiU0hBMjU2X1ciLCJTSEEyNTYiLCJjb25zdHJ1Y3RvciIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJIIiwiZ2V0Iiwic2V0IiwicHJvY2VzcyIsInZpZXciLCJvZmZzZXQiLCJpIiwiZ2V0VWludDMyIiwiVzE1IiwiVzIiLCJzMCIsInMxIiwic2lnbWExIiwiVDEiLCJzaWdtYTAiLCJUMiIsInJvdW5kQ2xlYW4iLCJmaWxsIiwiZGVzdHJveSIsImJ1ZmZlciIsIlNIQTIyNCIsIm91dHB1dExlbiIsInNoYTI1NiIsInNoYTIyNCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/@noble/hashes/esm/sha3.js":
/*!*************************************************!*\
  !*** ../node_modules/@noble/hashes/esm/sha3.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: () => (/* binding */ Keccak),\n/* harmony export */   keccakP: () => (/* binding */ keccakP),\n/* harmony export */   keccak_224: () => (/* binding */ keccak_224),\n/* harmony export */   keccak_256: () => (/* binding */ keccak_256),\n/* harmony export */   keccak_384: () => (/* binding */ keccak_384),\n/* harmony export */   keccak_512: () => (/* binding */ keccak_512),\n/* harmony export */   sha3_224: () => (/* binding */ sha3_224),\n/* harmony export */   sha3_256: () => (/* binding */ sha3_256),\n/* harmony export */   sha3_384: () => (/* binding */ sha3_384),\n/* harmony export */   sha3_512: () => (/* binding */ sha3_512),\n/* harmony export */   shake128: () => (/* binding */ shake128),\n/* harmony export */   shake256: () => (/* binding */ shake256)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_assert.js */ \"(rsc)/../node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(rsc)/../node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/../node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){\n    // Pi\n    [x, y] = [\n        y,\n        (2 * x + 3 * y) % 5\n    ];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n    // Iota\n    let t = _0n;\n    for(let j = 0; j < 7; j++){\n        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n        if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s)=>s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s);\nconst rotlL = (h, l, s)=>s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s);\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for(let round = 24 - rounds; round < 24; round++){\n        // Theta Œ∏\n        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for(let x = 0; x < 10; x += 2){\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for(let y = 0; y < 50; y += 10){\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (œÅ) and Pi (œÄ)\n        let curH = s[2];\n        let curL = s[3];\n        for(let t = 0; t < 24; t++){\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (œá)\n        for(let y = 0; y < 50; y += 10){\n            for(let x = 0; x < 10; x++)B[x] = s[y + x];\n            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (Œπ)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200) throw new Error(\"Sha3 supports only keccak-f1600 function\");\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\n    }\n    keccak() {\n        if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLE) (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.byteSwap32)(this.state32);\n        keccakP(this.state32, this.rounds);\n        if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLE) (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.byteSwap32)(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this);\n        const { blockLen, state } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen) this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished) return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this, false);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.bytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for(let pos = 0, len = out.length; pos < len;){\n            if (this.posOut >= blockLen) this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.output)(out, this);\n        if (this.finished) throw new Error(\"digest() was already called\");\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new Keccak(blockLen, suffix, outputLen));\nconst sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */ const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nconst sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nconst sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nconst keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */ const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nconst keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nconst keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapXOFConstructorWithOpts)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nconst shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nconst shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8); //# sourceMappingURL=sha3.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZEO0FBQ0s7QUFDOEM7QUFDaEgsb0dBQW9HO0FBQ3BHLGlDQUFpQztBQUNqQywyQ0FBMkM7QUFDM0MsTUFBTWdCLFVBQVUsRUFBRTtBQUNsQixNQUFNQyxZQUFZLEVBQUU7QUFDcEIsTUFBTUMsYUFBYSxFQUFFO0FBQ3JCLE1BQU1DLE1BQU0sYUFBYSxHQUFHQyxPQUFPO0FBQ25DLE1BQU1DLE1BQU0sYUFBYSxHQUFHRCxPQUFPO0FBQ25DLE1BQU1FLE1BQU0sYUFBYSxHQUFHRixPQUFPO0FBQ25DLE1BQU1HLE1BQU0sYUFBYSxHQUFHSCxPQUFPO0FBQ25DLE1BQU1JLFFBQVEsYUFBYSxHQUFHSixPQUFPO0FBQ3JDLE1BQU1LLFNBQVMsYUFBYSxHQUFHTCxPQUFPO0FBQ3RDLElBQUssSUFBSU0sUUFBUSxHQUFHQyxJQUFJTixLQUFLTyxJQUFJLEdBQUdDLElBQUksR0FBR0gsUUFBUSxJQUFJQSxRQUFTO0lBQzVELEtBQUs7SUFDTCxDQUFDRSxHQUFHQyxFQUFFLEdBQUc7UUFBQ0E7UUFBSSxLQUFJRCxJQUFJLElBQUlDLENBQUFBLElBQUs7S0FBRTtJQUNqQ2IsUUFBUWMsSUFBSSxDQUFDLElBQUssS0FBSUQsSUFBSUQsQ0FBQUE7SUFDMUIsYUFBYTtJQUNiWCxVQUFVYSxJQUFJLENBQUMsQ0FBR0osUUFBUSxLQUFNQSxDQUFBQSxRQUFRLEtBQU0sSUFBSztJQUNuRCxPQUFPO0lBQ1AsSUFBSUssSUFBSVo7SUFDUixJQUFLLElBQUlhLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO1FBQ3hCTCxJQUFJLENBQUMsS0FBTU4sTUFBUSxDQUFDTSxLQUFLSixHQUFFLElBQUtFLE1BQU0sSUFBS0Q7UUFDM0MsSUFBSUcsSUFBSUwsS0FDSlMsS0FBS1YsT0FBUSxDQUFDQSxPQUFPLGFBQWEsR0FBR0QsT0FBT1ksRUFBQyxJ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QUFXLGFBQWEsR0FBR0osSUFBSSxNQUFNLElBQUksTUFBTSxHQUFHO0FBQ3hELE1BQU1LLGFBQWEsYUFBYSxHQUFHTCxJQUFJLE1BQU0sS0FBSyxNQUFNLEdBQUc7QUFDbEU7OztDQUdDLEdBQ00sTUFBTU0sYUFBYSxhQUFhLEdBQUdOLElBQUksTUFBTSxLQUFLLE1BQU0sR0FBRztBQUMzRCxNQUFNTyxhQUFhLGFBQWEsR0FBR1AsSUFBSSxNQUFNLEtBQUssTUFBTSxHQUFHO0FBQzNELE1BQU1RLGFBQWEsYUFBYSxHQUFHUixJQUFJLE1BQU0sSUFBSSxNQUFNLEdBQUc7QUFDakUsTUFBTVMsV0FBVyxDQUFDMUMsUUFBUUQsVUFBVUUsWUFBYzlDLHFFQUEwQkEsQ0FBQyxDQUFDd0YsT0FBTyxDQUFDLENBQUMsR0FBSyxJQUFJOUMsT0FBT0UsVUFBVUMsUUFBUTJDLEtBQUtDLEtBQUssS0FBS0MsWUFBWTVDLFlBQVkwQyxLQUFLQyxLQUFLLEVBQUU7QUFDckssTUFBTUUsV0FBVyxhQUFhLEdBQUdKLFNBQVMsTUFBTSxLQUFLLE1BQU0sR0FBRztBQUM5RCxNQUFNSyxXQUFXLGFBQWEsR0FBR0wsU0FBUyxNQUFNLEtBQUssTUFBTSxHQUFHLENBQ3JFLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMy5qcz9jNGQ1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJ5dGVzLCBleGlzdHMsIG51bWJlciwgb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IHJvdGxCSCwgcm90bEJMLCByb3RsU0gsIHJvdGxTTCwgc3BsaXQgfSBmcm9tICcuL191NjQuanMnO1xuaW1wb3J0IHsgSGFzaCwgdTMyLCB0b0J5dGVzLCB3cmFwQ29uc3RydWN0b3IsIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzLCBpc0xFLCBieXRlU3dhcDMyLCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMyAoa2VjY2FrKSBpcyBiYXNlZCBvbiBhIG5ldyBkZXNpZ246IGJhc2ljYWxseSwgdGhlIGludGVybmFsIHN0YXRlIGlzIGJpZ2dlciB0aGFuIG91dHB1dCBzaXplLlxuLy8gSXQncyBjYWxsZWQgYSBzcG9uZ2UgZnVuY3Rpb24uXG4vLyBWYXJpb3VzIHBlciByb3VuZCBjb25zdGFudHMgY2FsY3VsYXRpb25zXG5jb25zdCBTSEEzX1BJID0gW107XG5jb25zdCBTSEEzX1JPVEwgPSBbXTtcbmNvbnN0IF9TSEEzX0lPVEEgPSBbXTtcbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKTtcbmNvbnN0IF83biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNyk7XG5jb25zdCBfMjU2biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMjU2KTtcbmNvbnN0IF8weDcxbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMHg3MSk7XG5mb3IgKGxldCByb3VuZCA9IDAsIFIgPSBfMW4sIHggPSAxLCB5ID0gMDsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgIC8vIFBpXG4gICAgW3gsIHldID0gW3ksICgyICogeCArIDMgKiB5KSAlIDVdO1xuICAgIFNIQTNfUEkucHVzaCgyICogKDUgKiB5ICsgeCkpO1xuICAgIC8vIFJvdGF0aW9uYWxcbiAgICBTSEEzX1JPVEwucHVzaCgoKChyb3VuZCArIDEpICogKHJvdW5kICsgMikpIC8gMikgJSA2NCk7XG4gICAgLy8gSW90YVxuICAgIGxldCB0ID0gXzBuO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgIFIgPSAoKFIgPDwgXzFuKSBeICgoUiA+PiBfN24pICogXzB4NzFuKSkgJSBfMjU2bjtcbiAgICAgICAgaWYgKFIgJiBfMm4pXG4gICAgICAgICAgICB0IF49IF8xbiA8PCAoKF8xbiA8PCAvKiBAX19QVVJFX18gKi8gQmlnSW50KGopKSAtIF8xbik7XG4gICAgfVxuICAgIF9TSEEzX0lPVEEucHVzaCh0KTtcbn1cbmNvbnN0IFtTSEEzX0lPVEFfSCwgU0hBM19JT1RBX0xdID0gLyogQF9fUFVSRV9fICovIHNwbGl0KF9TSEEzX0lPVEEsIHRydWUpO1xuLy8gTGVmdCByb3RhdGlvbiAod2l0aG91dCAwLCAzMiwgNjQpXG5jb25zdCByb3RsSCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gcm90bEJIKGgsIGwsIHMpIDogcm90bFNIKGgsIGwsIHMpKTtcbmNvbnN0IHJvdGxMID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkwoaCwgbCwgcykgOiByb3RsU0woaCwgbCwgcykpO1xuLy8gU2FtZSBhcyBrZWNjYWtmMTYwMCwgYnV0IGFsbG93cyB0byBza2lwIHNvbWUgcm91bmRzXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrUChzLCByb3VuZHMgPSAyNCkge1xuICAgIGNvbnN0IEIgPSBuZXcgVWludDMyQXJyYXkoNSAqIDIpO1xuICAgIC8vIE5PVEU6IGFsbCBpbmRpY2VzIGFyZSB4MiBzaW5jZSB3ZSBzdG9yZSBzdGF0ZSBhcyB1MzIgaW5zdGVhZCBvZiB1NjQgKGJpZ2ludHMgdG8gc2xvdyBpbiBqcylcbiAgICBmb3IgKGxldCByb3VuZCA9IDI0IC0gcm91bmRzOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgICAgIC8vIFRoZXRhIM64XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgIEJbeF0gPSBzW3hdIF4gc1t4ICsgMTBdIF4gc1t4ICsgMjBdIF4gc1t4ICsgMzBdIF4gc1t4ICsgNDBdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4ICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBpZHgwID0gKHggKyAyKSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgQjAgPSBCW2lkeDBdO1xuICAgICAgICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoQjAsIEIxLCAxKSBeIEJbaWR4MV07XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKEIwLCBCMSwgMSkgXiBCW2lkeDEgKyAxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgICAgICBzW3ggKyB5XSBePSBUaDtcbiAgICAgICAgICAgICAgICBzW3ggKyB5ICsgMV0gXj0gVGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmhvICjPgSkgYW5kIFBpICjPgClcbiAgICAgICAgbGV0IGN1ckggPSBzWzJdO1xuICAgICAgICBsZXQgY3VyTCA9IHNbM107XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjQ7IHQrKykge1xuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVExbdF07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJW3RdO1xuICAgICAgICAgICAgY3VySCA9IHNbUEldO1xuICAgICAgICAgICAgY3VyTCA9IHNbUEkgKyAxXTtcbiAgICAgICAgICAgIHNbUEldID0gVGg7XG4gICAgICAgICAgICBzW1BJICsgMV0gPSBUbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGkgKM+HKVxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgQlt4XSA9IHNbeSArIHhdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIHNbeSArIHhdIF49IH5CWyh4ICsgMikgJSAxMF0gJiBCWyh4ICsgNCkgJSAxMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW90YSAozrkpXG4gICAgICAgIHNbMF0gXj0gU0hBM19JT1RBX0hbcm91bmRdO1xuICAgICAgICBzWzFdIF49IFNIQTNfSU9UQV9MW3JvdW5kXTtcbiAgICB9XG4gICAgQi5maWxsKDApO1xufVxuZXhwb3J0IGNsYXNzIEtlY2NhayBleHRlbmRzIEhhc2gge1xuICAgIC8vIE5PVEU6IHdlIGFjY2VwdCBhcmd1bWVudHMgaW4gYnl0ZXMgaW5zdGVhZCBvZiBiaXRzIGhlcmUuXG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YgPSBmYWxzZSwgcm91bmRzID0gMjQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMuZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0aGlzLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gQ2FuIGJlIHBhc3NlZCBmcm9tIHVzZXIgYXMgZGtMZW5cbiAgICAgICAgbnVtYmVyKG91dHB1dExlbik7XG4gICAgICAgIC8vIDE2MDAgPSA1eDUgbWF0cml4IG9mIDY0Yml0LiAgMTYwMCBiaXRzID09PSAyMDAgYnl0ZXNcbiAgICAgICAgaWYgKDAgPj0gdGhpcy5ibG9ja0xlbiB8fCB0aGlzLmJsb2NrTGVuID49IDIwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhMyBzdXBwb3J0cyBvbmx5IGtlY2Nhay1mMTYwMCBmdW5jdGlvbicpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcbiAgICAgICAgdGhpcy5zdGF0ZTMyID0gdTMyKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBrZWNjYWsoKSB7XG4gICAgICAgIGlmICghaXNMRSlcbiAgICAgICAgICAgIGJ5dGVTd2FwMzIodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAga2VjY2FrUCh0aGlzLnN0YXRlMzIsIHRoaXMucm91bmRzKTtcbiAgICAgICAgaWYgKCFpc0xFKVxuICAgICAgICAgICAgYnl0ZVN3YXAzMih0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICAvLyBEbyB0aGUgcGFkZGluZ1xuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcbiAgICAgICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSlcbiAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICB9XG4gICAgd3JpdGVJbnRvKG91dCkge1xuICAgICAgICBleGlzdHModGhpcywgZmFsc2UpO1xuICAgICAgICBieXRlcyhvdXQpO1xuICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICBjb25zdCBidWZmZXJPdXQgPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBsZW4gPSBvdXQubGVuZ3RoOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NPdXQgPj0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zT3V0LCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgb3V0LnNldChidWZmZXJPdXQuc3ViYXJyYXkodGhpcy5wb3NPdXQsIHRoaXMucG9zT3V0ICsgdGFrZSksIHBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvc091dCArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgeG9mSW50byhvdXQpIHtcbiAgICAgICAgLy8gU2hhMy9LZWNjYWsgdXNhZ2Ugd2l0aCBYT0YgaXMgcHJvYmFibHkgbWlzdGFrZSwgb25seSBTSEFLRSBpbnN0YW5jZXMgY2FuIGRvIFhPRlxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlWE9GKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYT0YgaXMgbm90IHBvc3NpYmxlIGZvciB0aGlzIGluc3RhbmNlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgIH1cbiAgICB4b2YoYnl0ZXMpIHtcbiAgICAgICAgbnVtYmVyKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG5ldyBVaW50OEFycmF5KHRoaXMub3V0cHV0TGVuKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5maWxsKDApO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiwgcm91bmRzKSk7XG4gICAgICAgIHRvLnN0YXRlMzIuc2V0KHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRvLnBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0by5wb3NPdXQgPSB0aGlzLnBvc091dDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSB0aGlzLmZpbmlzaGVkO1xuICAgICAgICB0by5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIFN1ZmZpeCBjYW4gY2hhbmdlIGluIGNTSEFLRVxuICAgICAgICB0by5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8uZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSB0aGlzLmRlc3Ryb3llZDtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmNvbnN0IGdlbiA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpO1xuZXhwb3J0IGNvbnN0IHNoYTNfMjI0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBTSEEzLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydCBjb25zdCBzaGEzXzM4NCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgMTA0LCAzODQgLyA4KTtcbmV4cG9ydCBjb25zdCBzaGEzXzUxMiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgNzIsIDUxMiAvIDgpO1xuZXhwb3J0IGNvbnN0IGtlY2Nha18yMjQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDE0NCwgMjI0IC8gOCk7XG4vKipcbiAqIGtlY2Nhay0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20gU0hBMy0yNTYuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBrZWNjYWtfMjU2ID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0IGNvbnN0IGtlY2Nha18zODQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnQgY29uc3Qga2VjY2FrXzUxMiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgNzIsIDUxMiAvIDgpO1xuY29uc3QgZ2VuU2hha2UgPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cygob3B0cyA9IHt9KSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG9wdHMuZGtMZW4gPT09IHVuZGVmaW5lZCA/IG91dHB1dExlbiA6IG9wdHMuZGtMZW4sIHRydWUpKTtcbmV4cG9ydCBjb25zdCBzaGFrZTEyOCA9IC8qIEBfX1BVUkVfXyAqLyBnZW5TaGFrZSgweDFmLCAxNjgsIDEyOCAvIDgpO1xuZXhwb3J0IGNvbnN0IHNoYWtlMjU2ID0gLyogQF9fUFVSRV9fICovIGdlblNoYWtlKDB4MWYsIDEzNiwgMjU2IC8gOCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEzLmpzLm1hcCJdLCJuYW1lcyI6WyJieXRlcyIsImV4aXN0cyIsIm51bWJlciIsIm91dHB1dCIsInJvdGxCSCIsInJvdGxCTCIsInJvdGxTSCIsInJvdGxTTCIsInNwbGl0IiwiSGFzaCIsInUzMiIsInRvQnl0ZXMiLCJ3cmFwQ29uc3RydWN0b3IiLCJ3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyIsImlzTEUiLCJieXRlU3dhcDMyIiwiU0hBM19QSSIsIlNIQTNfUk9UTCIsIl9TSEEzX0lPVEEiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfN24iLCJfMjU2biIsIl8weDcxbiIsInJvdW5kIiwiUiIsIngiLCJ5IiwicHVzaCIsInQiLCJqIiwiU0hBM19JT1RBX0giLCJTSEEzX0lPVEFfTCIsInJvdGxIIiwiaCIsImwiLCJzIiwicm90bEwiLCJrZWNjYWtQIiwicm91bmRzIiwiQiIsIlVpbnQzMkFycmF5IiwiaWR4MSIsImlkeDAiLCJCMCIsIkIxIiwiVGgiLCJUbCIsImN1ckgiLCJjdXJMIiwic2hpZnQiLCJQSSIsImZpbGwiLCJLZWNjYWsiLCJjb25zdHJ1Y3RvciIsImJsb2NrTGVuIiwic3VmZml4Iiwib3V0cHV0TGVuIiwiZW5hYmxlWE9GIiwicG9zIiwicG9zT3V0IiwiZmluaXNoZWQiLCJkZXN0cm95ZWQiLCJFcnJvciIsInN0YXRlIiwiVWludDhBcnJheSIsInN0YXRlMzIiLCJrZWNjYWsiLCJ1cGRhdGUiLCJkYXRhIiwibGVuIiwibGVuZ3RoIiwidGFrZSIsIk1hdGgiLCJtaW4iLCJpIiwiZmluaXNoIiwid3JpdGVJbnRvIiwib3V0IiwiYnVmZmVyT3V0Iiwic2V0Iiwic3ViYXJyYXkiLCJ4b2ZJbnRvIiwieG9mIiwiZGlnZXN0SW50byIsImRlc3Ryb3kiLCJkaWdlc3QiLCJfY2xvbmVJbnRvIiwidG8iLCJnZW4iLCJzaGEzXzIyNCIsInNoYTNfMjU2Iiwic2hhM18zODQiLCJzaGEzXzUxMiIsImtlY2Nha18yMjQiLCJrZWNjYWtfMjU2Iiwia2VjY2FrXzM4NCIsImtlY2Nha181MTIiLCJnZW5TaGFrZSIsIm9wdHMiLCJka0xlbiIsInVuZGVmaW5lZCIsInNoYWtlMTI4Iiwic2hha2UyNTYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/@noble/hashes/esm/sha3.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/@noble/hashes/esm/sha512.js":
/*!***************************************************!*\
  !*** ../node_modules/@noble/hashes/esm/sha512.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_md.js */ \"(rsc)/../node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(rsc)/../node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/../node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (()=>_u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].split([\n        \"0x428a2f98d728ae22\",\n        \"0x7137449123ef65cd\",\n        \"0xb5c0fbcfec4d3b2f\",\n        \"0xe9b5dba58189dbbc\",\n        \"0x3956c25bf348b538\",\n        \"0x59f111f1b605d019\",\n        \"0x923f82a4af194f9b\",\n        \"0xab1c5ed5da6d8118\",\n        \"0xd807aa98a3030242\",\n        \"0x12835b0145706fbe\",\n        \"0x243185be4ee4b28c\",\n        \"0x550c7dc3d5ffb4e2\",\n        \"0x72be5d74f27b896f\",\n        \"0x80deb1fe3b1696b1\",\n        \"0x9bdc06a725c71235\",\n        \"0xc19bf174cf692694\",\n        \"0xe49b69c19ef14ad2\",\n        \"0xefbe4786384f25e3\",\n        \"0x0fc19dc68b8cd5b5\",\n        \"0x240ca1cc77ac9c65\",\n        \"0x2de92c6f592b0275\",\n        \"0x4a7484aa6ea6e483\",\n        \"0x5cb0a9dcbd41fbd4\",\n        \"0x76f988da831153b5\",\n        \"0x983e5152ee66dfab\",\n        \"0xa831c66d2db43210\",\n        \"0xb00327c898fb213f\",\n        \"0xbf597fc7beef0ee4\",\n        \"0xc6e00bf33da88fc2\",\n        \"0xd5a79147930aa725\",\n        \"0x06ca6351e003826f\",\n        \"0x142929670a0e6e70\",\n        \"0x27b70a8546d22ffc\",\n        \"0x2e1b21385c26c926\",\n        \"0x4d2c6dfc5ac42aed\",\n        \"0x53380d139d95b3df\",\n        \"0x650a73548baf63de\",\n        \"0x766a0abb3c77b2a8\",\n        \"0x81c2c92e47edaee6\",\n        \"0x92722c851482353b\",\n        \"0xa2bfe8a14cf10364\",\n        \"0xa81a664bbc423001\",\n        \"0xc24b8b70d0f89791\",\n        \"0xc76c51a30654be30\",\n        \"0xd192e819d6ef5218\",\n        \"0xd69906245565a910\",\n        \"0xf40e35855771202a\",\n        \"0x106aa07032bbd1b8\",\n        \"0x19a4c116b8d2d0c8\",\n        \"0x1e376c085141ab53\",\n        \"0x2748774cdf8eeb99\",\n        \"0x34b0bcb5e19b48a8\",\n        \"0x391c0cb3c5c95a63\",\n        \"0x4ed8aa4ae3418acb\",\n        \"0x5b9cca4f7763e373\",\n        \"0x682e6ff3d6b2b8a3\",\n        \"0x748f82ee5defb2fc\",\n        \"0x78a5636f43172f60\",\n        \"0x84c87814a1f0ab72\",\n        \"0x8cc702081a6439ec\",\n        \"0x90befffa23631e28\",\n        \"0xa4506cebde82bde9\",\n        \"0xbef9a3f7b2c67915\",\n        \"0xc67178f2e372532b\",\n        \"0xca273eceea26619c\",\n        \"0xd186b8c721c0c207\",\n        \"0xeada7dd6cde0eb1e\",\n        \"0xf57d4f7fee6ed178\",\n        \"0x06f067aa72176fba\",\n        \"0x0a637dc5a2c898a6\",\n        \"0x113f9804bef90dae\",\n        \"0x1b710b35131c471b\",\n        \"0x28db77f523047d84\",\n        \"0x32caab7b40c72493\",\n        \"0x3c9ebe0a15c9bebc\",\n        \"0x431d67c49c100d4c\",\n        \"0x4cc5d4becb3e42b6\",\n        \"0x597f299cfc657e2a\",\n        \"0x5fcb6fab3ad6faec\",\n        \"0x6c44198c4a475817\"\n    ].map((n)=>BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_js__WEBPACK_IMPORTED_MODULE_1__.HashMD {\n    constructor(){\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [\n            Ah,\n            Al,\n            Bh,\n            Bl,\n            Ch,\n            Cl,\n            Dh,\n            Dl,\n            Eh,\n            El,\n            Fh,\n            Fl,\n            Gh,\n            Gl,\n            Hh,\n            Hl\n        ];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4){\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32(offset += 4);\n        }\n        for(let i = 16; i < 80; i++){\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for(let i = 0; i < 80; i++){\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = Eh & Fh ^ ~Eh & Gh;\n            const CHIl = El & Fl ^ ~El & Gl;\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 39);\n            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;\n            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor(){\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor(){\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor(){\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(()=>new SHA512());\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(()=>new SHA512_224());\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(()=>new SHA512_256());\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(()=>new SHA384()); //# sourceMappingURL=sha512.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTUxMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFrQztBQUNOO0FBQ2lCO0FBQzdDLDBHQUEwRztBQUMxRyxrQkFBa0I7QUFDbEIsTUFBTSxDQUFDRyxXQUFXQyxVQUFVLEdBQW1CLGFBQUgsR0FBSSxLQUFNSCxxREFBUyxDQUFDO1FBQzVEO1FBQXNCO1FBQXNCO1FBQXNCO1FBQ2xFO1FBQXNCO1FBQXNCO1FBQXNCO1FBQ2xFO1FBQXNCO1FBQXNCO1FBQXNCO1FBQ2xFO1FBQXNCO1FBQXNCO1FBQXNCO1FBQ2xFO1FBQXNCO1FBQXNCO1FBQXNCO1FBQ2xFO1FBQXNCO1FBQXNCO1FBQXNCO1FBQ2xFO1FBQXNCO1FBQXNCO1FBQXNCO1FBQ2xFO1FBQXNCO1FBQXNCO1FBQXNCO1FBQ2xFO1FBQXNCO1FBQXNCO1FBQXNCO1FBQ2xFO1FBQXNCO1FBQXNCO1FBQXNCO1FBQ2xFO1FBQXNCO1FBQXNCO1FBQXNCO1FBQ2xFO1FBQXNCO1FBQXNCO1FBQXNCO1FBQ2xFO1FBQXNCO1FBQXNCO1FBQXNCO1FBQ2xFO1FBQXNCO1FBQXNCO1FBQXNCO1FBQ2xFO1FBQXNCO1FBQXNCO1FBQXNCO1FBQ2xFO1FBQXNCO1FBQXNCO1FBQXNCO1FBQ2xFO1FBQXNCO1FBQXNCO1FBQXNCO1FBQ2xFO1FBQXNCO1FBQXNCO1FBQXNCO1FBQ2xFO1FBQXNCO1FBQXNCO1FBQXNCO1FBQ2xFO1FBQXNCO1FBQXNCO1FBQXNCO0tBQ3JFLENBQUNLLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0MsT0FBT0QsSUFBRztBQUNyQiw0REFBNEQ7QUFDNUQsTUFBTUUsYUFBYSxhQUFhLEdBQUcsSUFBSUMsWUFBWTtBQUNuRCxNQUFNQyxhQUFhLGFBQWEsR0FBRyxJQUFJRCxZQUFZO0FBQzVDLE1BQU1FLGVBQWVaLDBDQUFNQTtJQUM5QmEsYUFBYztRQUNWLEtBQUssQ0FBQyxLQUFLLElBQUksSUFBSTtRQUNuQix3SEFBd0g7UUFDeEgs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LEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDa0QsU0FBUyxHQUFHO0lBQ3JCO0FBQ0o7QUFDTyxNQUFNRyxTQUFTLGFBQWEsR0FBR2hGLDBEQUFlQSxDQUFDLElBQU0sSUFBSVUsVUFBVTtBQUNuRSxNQUFNdUUsYUFBYSxhQUFhLEdBQUdqRiwwREFBZUEsQ0FBQyxJQUFNLElBQUk0RSxjQUFjO0FBQzNFLE1BQU1NLGFBQWEsYUFBYSxHQUFHbEYsMERBQWVBLENBQUMsSUFBTSxJQUFJOEUsY0FBYztBQUMzRSxNQUFNSyxTQUFTLGFBQWEsR0FBR25GLDBEQUFlQSxDQUFDLElBQU0sSUFBSStFLFVBQVUsQ0FDMUUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGE1MTIuanM/N2Y1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIYXNoTUQgfSBmcm9tICcuL19tZC5qcyc7XG5pbXBvcnQgdTY0IGZyb20gJy4vX3U2NC5qcyc7XG5pbXBvcnQgeyB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFJvdW5kIGNvbnRhbnRzIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4MCBwcmltZXMgMi4uNDA5KTpcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgW1NIQTUxMl9LaCwgU0hBNTEyX0tsXSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdTY0LnNwbGl0KFtcbiAgICAnMHg0MjhhMmY5OGQ3MjhhZTIyJywgJzB4NzEzNzQ0OTEyM2VmNjVjZCcsICcweGI1YzBmYmNmZWM0ZDNiMmYnLCAnMHhlOWI1ZGJhNTgxODlkYmJjJyxcbiAgICAnMHgzOTU2YzI1YmYzNDhiNTM4JywgJzB4NTlmMTExZjFiNjA1ZDAxOScsICcweDkyM2Y4MmE0YWYxOTRmOWInLCAnMHhhYjFjNWVkNWRhNmQ4MTE4JyxcbiAgICAnMHhkODA3YWE5OGEzMDMwMjQyJywgJzB4MTI4MzViMDE0NTcwNmZiZScsICcweDI0MzE4NWJlNGVlNGIyOGMnLCAnMHg1NTBjN2RjM2Q1ZmZiNGUyJyxcbiAgICAnMHg3MmJlNWQ3NGYyN2I4OTZmJywgJzB4ODBkZWIxZmUzYjE2OTZiMScsICcweDliZGMwNmE3MjVjNzEyMzUnLCAnMHhjMTliZjE3NGNmNjkyNjk0JyxcbiAgICAnMHhlNDliNjljMTllZjE0YWQyJywgJzB4ZWZiZTQ3ODYzODRmMjVlMycsICcweDBmYzE5ZGM2OGI4Y2Q1YjUnLCAnMHgyNDBjYTFjYzc3YWM5YzY1JyxcbiAgICAnMHgyZGU5MmM2ZjU5MmIwMjc1JywgJzB4NGE3NDg0YWE2ZWE2ZTQ4MycsICcweDVjYjBhOWRjYmQ0MWZiZDQnLCAnMHg3NmY5ODhkYTgzMTE1M2I1JyxcbiAgICAnMHg5ODNlNTE1MmVlNjZkZmFiJywgJzB4YTgzMWM2NmQyZGI0MzIxMCcsICcweGIwMDMyN2M4OThmYjIxM2YnLCAnMHhiZjU5N2ZjN2JlZWYwZWU0JyxcbiAgICAnMHhjNmUwMGJmMzNkYTg4ZmMyJywgJzB4ZDVhNzkxNDc5MzBhYTcyNScsICcweDA2Y2E2MzUxZTAwMzgyNmYnLCAnMHgxNDI5Mjk2NzBhMGU2ZTcwJyxcbiAgICAnMHgyN2I3MGE4NTQ2ZDIyZmZjJywgJzB4MmUxYjIxMzg1YzI2YzkyNicsICcweDRkMmM2ZGZjNWFjNDJhZWQnLCAnMHg1MzM4MGQxMzlkOTViM2RmJyxcbiAgICAnMHg2NTBhNzM1NDhiYWY2M2RlJywgJzB4NzY2YTBhYmIzYzc3YjJhOCcsICcweDgxYzJjOTJlNDdlZGFlZTYnLCAnMHg5MjcyMmM4NTE0ODIzNTNiJyxcbiAgICAnMHhhMmJmZThhMTRjZjEwMzY0JywgJzB4YTgxYTY2NGJiYzQyMzAwMScsICcweGMyNGI4YjcwZDBmODk3OTEnLCAnMHhjNzZjNTFhMzA2NTRiZTMwJyxcbiAgICAnMHhkMTkyZTgxOWQ2ZWY1MjE4JywgJzB4ZDY5OTA2MjQ1NTY1YTkxMCcsICcweGY0MGUzNTg1NTc3MTIwMmEnLCAnMHgxMDZhYTA3MDMyYmJkMWI4JyxcbiAgICAnMHgxOWE0YzExNmI4ZDJkMGM4JywgJzB4MWUzNzZjMDg1MTQxYWI1MycsICcweDI3NDg3NzRjZGY4ZWViOTknLCAnMHgzNGIwYmNiNWUxOWI0OGE4JyxcbiAgICAnMHgzOTFjMGNiM2M1Yzk1YTYzJywgJzB4NGVkOGFhNGFlMzQxOGFjYicsICcweDViOWNjYTRmNzc2M2UzNzMnLCAnMHg2ODJlNmZmM2Q2YjJiOGEzJyxcbiAgICAnMHg3NDhmODJlZTVkZWZiMmZjJywgJzB4NzhhNTYzNmY0MzE3MmY2MCcsICcweDg0Yzg3ODE0YTFmMGFiNzInLCAnMHg4Y2M3MDIwODFhNjQzOWVjJyxcbiAgICAnMHg5MGJlZmZmYTIzNjMxZTI4JywgJzB4YTQ1MDZjZWJkZTgyYmRlOScsICcweGJlZjlhM2Y3YjJjNjc5MTUnLCAnMHhjNjcxNzhmMmUzNzI1MzJiJyxcbiAgICAnMHhjYTI3M2VjZWVhMjY2MTljJywgJzB4ZDE4NmI4YzcyMWMwYzIwNycsICcweGVhZGE3ZGQ2Y2RlMGViMWUnLCAnMHhmNTdkNGY3ZmVlNmVkMTc4JyxcbiAgICAnMHgwNmYwNjdhYTcyMTc2ZmJhJywgJzB4MGE2MzdkYzVhMmM4OThhNicsICcweDExM2Y5ODA0YmVmOTBkYWUnLCAnMHgxYjcxMGIzNTEzMWM0NzFiJyxcbiAgICAnMHgyOGRiNzdmNTIzMDQ3ZDg0JywgJzB4MzJjYWFiN2I0MGM3MjQ5MycsICcweDNjOWViZTBhMTVjOWJlYmMnLCAnMHg0MzFkNjdjNDljMTAwZDRjJyxcbiAgICAnMHg0Y2M1ZDRiZWNiM2U0MmI2JywgJzB4NTk3ZjI5OWNmYzY1N2UyYScsICcweDVmY2I2ZmFiM2FkNmZhZWMnLCAnMHg2YzQ0MTk4YzRhNDc1ODE3J1xuXS5tYXAobiA9PiBCaWdJbnQobikpKSkoKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuY29uc3QgU0hBNTEyX1dfSCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuY29uc3QgU0hBNTEyX1dfTCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuZXhwb3J0IGNsYXNzIFNIQTUxMiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDEyOCwgNjQsIDE2LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGUgd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICAvLyBBbHNvIGxvb2tzIGNsZWFuZXIgYW5kIGVhc2llciB0byB2ZXJpZnkgd2l0aCBzcGVjLlxuICAgICAgICAvLyBJbml0aWFsIHN0YXRlIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5KTpcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4NmEwOWU2NjcgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhmM2JjYzkwOCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweGJiNjdhZTg1IHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4ODRjYWE3M2IgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgzYzZlZjM3MiB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweGZlOTRmODJiIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4YTU0ZmY1M2EgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1ZjFkMzZmMSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDUxMGU1MjdmIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4YWRlNjgyZDEgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg5YjA1Njg4YyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDJiM2U2YzFmIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4MWY4M2Q5YWIgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHhmYjQxYmQ2YiB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDViZTBjZDE5IHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4MTM3ZTIxNzkgfCAwO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGxdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpIHtcbiAgICAgICAgdGhpcy5BaCA9IEFoIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IEFsIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IEJoIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IEJsIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IENoIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IENsIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IERoIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IERsIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IEVoIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IEVsIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IEZoIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IEZsIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IEdoIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IEdsIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IEhoIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IEhsIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNjQgd29yZHMgd1sxNi4uNzldIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpIHtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IHZpZXcuZ2V0VWludDMyKChvZmZzZXQgKz0gNCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHMwIDo9ICh3W2ktMTVdIHJpZ2h0cm90YXRlIDEpIHhvciAod1tpLTE1XSByaWdodHJvdGF0ZSA4KSB4b3IgKHdbaS0xNV0gcmlnaHRzaGlmdCA3KVxuICAgICAgICAgICAgY29uc3QgVzE1aCA9IFNIQTUxMl9XX0hbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMTVsID0gU0hBNTEyX1dfTFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMwaCA9IHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNIKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNIKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgY29uc3QgczBsID0gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0woVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICAvLyBzMSA6PSAod1tpLTJdIHJpZ2h0cm90YXRlIDE5KSB4b3IgKHdbaS0yXSByaWdodHJvdGF0ZSA2MSkgeG9yICh3W2ktMl0gcmlnaHRzaGlmdCA2KVxuICAgICAgICAgICAgY29uc3QgVzJoID0gU0hBNTEyX1dfSFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzJsID0gU0hBNTEyX1dfTFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczFoID0gdTY0LnJvdHJTSChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCSChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNIKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIGNvbnN0IHMxbCA9IHU2NC5yb3RyU0woVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkwoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTTChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICAvLyBTSEEyNTZfV1tpXSA9IHMwICsgczEgKyBTSEEyNTZfV1tpIC0gN10gKyBTSEEyNTZfV1tpIC0gMTZdO1xuICAgICAgICAgICAgY29uc3QgU1VNbCA9IHU2NC5hZGQ0TChzMGwsIHMxbCwgU0hBNTEyX1dfTFtpIC0gN10sIFNIQTUxMl9XX0xbaSAtIDE2XSk7XG4gICAgICAgICAgICBjb25zdCBTVU1oID0gdTY0LmFkZDRIKFNVTWwsIHMwaCwgczFoLCBTSEE1MTJfV19IW2kgLSA3XSwgU0hBNTEyX1dfSFtpIC0gMTZdKTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSBTVU1oIHwgMDtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSBTVU1sIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA4MCByb3VuZHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBTMSA6PSAoZSByaWdodHJvdGF0ZSAxNCkgeG9yIChlIHJpZ2h0cm90YXRlIDE4KSB4b3IgKGUgcmlnaHRyb3RhdGUgNDEpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTFoID0gdTY0LnJvdHJTSChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0goRWgsIEVsLCAxOCkgXiB1NjQucm90ckJIKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExbCA9IHU2NC5yb3RyU0woRWgsIEVsLCAxNCkgXiB1NjQucm90clNMKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCTChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIC8vY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IENISWggPSAoRWggJiBGaCkgXiAofkVoICYgR2gpO1xuICAgICAgICAgICAgY29uc3QgQ0hJbCA9IChFbCAmIEZsKSBeICh+RWwgJiBHbCk7XG4gICAgICAgICAgICAvLyBUMSA9IEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEE1MTJfS1tpXSArIFNIQTUxMl9XW2ldXG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFQxbGwgPSB1NjQuYWRkNUwoSGwsIHNpZ21hMWwsIENISWwsIFNIQTUxMl9LbFtpXSwgU0hBNTEyX1dfTFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWggPSB1NjQuYWRkNUgoVDFsbCwgSGgsIHNpZ21hMWgsIENISWgsIFNIQTUxMl9LaFtpXSwgU0hBNTEyX1dfSFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWwgPSBUMWxsIHwgMDtcbiAgICAgICAgICAgIC8vIFMwIDo9IChhIHJpZ2h0cm90YXRlIDI4KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzQpIHhvciAoYSByaWdodHJvdGF0ZSAzOSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGggPSB1NjQucm90clNIKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTBsID0gdTY0LnJvdHJTTChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3QgTUFKaCA9IChBaCAmIEJoKSBeIChBaCAmIENoKSBeIChCaCAmIENoKTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmwgPSAoQWwgJiBCbCkgXiAoQWwgJiBDbCkgXiAoQmwgJiBDbCk7XG4gICAgICAgICAgICBIaCA9IEdoIHwgMDtcbiAgICAgICAgICAgIEhsID0gR2wgfCAwO1xuICAgICAgICAgICAgR2ggPSBGaCB8IDA7XG4gICAgICAgICAgICBHbCA9IEZsIHwgMDtcbiAgICAgICAgICAgIEZoID0gRWggfCAwO1xuICAgICAgICAgICAgRmwgPSBFbCB8IDA7XG4gICAgICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQoRGggfCAwLCBEbCB8IDAsIFQxaCB8IDAsIFQxbCB8IDApKTtcbiAgICAgICAgICAgIERoID0gQ2ggfCAwO1xuICAgICAgICAgICAgRGwgPSBDbCB8IDA7XG4gICAgICAgICAgICBDaCA9IEJoIHwgMDtcbiAgICAgICAgICAgIENsID0gQmwgfCAwO1xuICAgICAgICAgICAgQmggPSBBaCB8IDA7XG4gICAgICAgICAgICBCbCA9IEFsIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IEFsbCA9IHU2NC5hZGQzTChUMWwsIHNpZ21hMGwsIE1BSmwpO1xuICAgICAgICAgICAgQWggPSB1NjQuYWRkM0goQWxsLCBUMWgsIHNpZ21hMGgsIE1BSmgpO1xuICAgICAgICAgICAgQWwgPSBBbGwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgICh7IGg6IEFoLCBsOiBBbCB9ID0gdTY0LmFkZCh0aGlzLkFoIHwgMCwgdGhpcy5BbCB8IDAsIEFoIHwgMCwgQWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEJoLCBsOiBCbCB9ID0gdTY0LmFkZCh0aGlzLkJoIHwgMCwgdGhpcy5CbCB8IDAsIEJoIHwgMCwgQmwgfCAwKSk7XG4gICAgICAgICh7IGg6IENoLCBsOiBDbCB9ID0gdTY0LmFkZCh0aGlzLkNoIHwgMCwgdGhpcy5DbCB8IDAsIENoIHwgMCwgQ2wgfCAwKSk7XG4gICAgICAgICh7IGg6IERoLCBsOiBEbCB9ID0gdTY0LmFkZCh0aGlzLkRoIHwgMCwgdGhpcy5EbCB8IDAsIERoIHwgMCwgRGwgfCAwKSk7XG4gICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZCh0aGlzLkVoIHwgMCwgdGhpcy5FbCB8IDAsIEVoIHwgMCwgRWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEZoLCBsOiBGbCB9ID0gdTY0LmFkZCh0aGlzLkZoIHwgMCwgdGhpcy5GbCB8IDAsIEZoIHwgMCwgRmwgfCAwKSk7XG4gICAgICAgICh7IGg6IEdoLCBsOiBHbCB9ID0gdTY0LmFkZCh0aGlzLkdoIHwgMCwgdGhpcy5HbCB8IDAsIEdoIHwgMCwgR2wgfCAwKSk7XG4gICAgICAgICh7IGg6IEhoLCBsOiBIbCB9ID0gdTY0LmFkZCh0aGlzLkhoIHwgMCwgdGhpcy5IbCB8IDAsIEhoIHwgMCwgSGwgfCAwKSk7XG4gICAgICAgIHRoaXMuc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBNTEyX1dfSC5maWxsKDApO1xuICAgICAgICBTSEE1MTJfV19MLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbmNsYXNzIFNIQTUxMl8yMjQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHg4YzNkMzdjOCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweDE5NTQ0ZGEyIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4NzNlMTk5NjYgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHg4OWRjZDRkNiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDFkZmFiN2FlIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4MzJmZjljODIgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHg2NzlkZDUxNCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDU4MmY5ZmNmIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4MGY2ZDJiNjkgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHg3YmQ0NGRhOCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDc3ZTM2ZjczIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4MDRjNDg5NDIgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgzZjlkODVhOCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDZhMWQzNmM4IHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4MTExMmU2YWQgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHg5MWQ2OTJhMSB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuY2xhc3MgU0hBNTEyXzI1NiBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDIyMzEyMTk0IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4ZmMyYmY3MmMgfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg5ZjU1NWZhMyB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweGM4NGM2NGMyIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4MjM5M2I4NmIgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHg2ZjUzYjE1MSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDk2Mzg3NzE5IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NTk0MGVhYmQgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg5NjI4M2VlMiB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGE4OGVmZmUzIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4YmU1ZTFlMjUgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHg1Mzg2Mzk5MiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDJiMDE5OWZjIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4MmM4NWI4YWEgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHgwZWI3MmRkYyB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDgxYzUyY2EyIHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAzMjtcbiAgICB9XG59XG5jbGFzcyBTSEEzODQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHhjYmJiOWQ1ZCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4NjI5YTI5MmEgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDkxNTkwMTVhIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHgxNTJmZWNkOCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4NjczMzI2NjcgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDhlYjQ0YTg3IHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHhkYjBjMmUwZCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4NDdiNTQ4MWQgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gNDg7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNoYTUxMiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMigpKTtcbmV4cG9ydCBjb25zdCBzaGE1MTJfMjI0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyXzIyNCgpKTtcbmV4cG9ydCBjb25zdCBzaGE1MTJfMjU2ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyXzI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEzODQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEzODQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGE1MTIuanMubWFwIl0sIm5hbWVzIjpbIkhhc2hNRCIsInU2NCIsIndyYXBDb25zdHJ1Y3RvciIsIlNIQTUxMl9LaCIsIlNIQTUxMl9LbCIsInNwbGl0IiwibWFwIiwibiIsIkJpZ0ludCIsIlNIQTUxMl9XX0giLCJVaW50MzJBcnJheSIsIlNIQTUxMl9XX0wiLCJTSEE1MTIiLCJjb25zdHJ1Y3RvciIsIkFoIiwiQWwiLCJCaCIsIkJsIiwiQ2giLCJDbCIsIkRoIiwiRGwiLCJFaCIsIkVsIiwiRmgiLCJGbCIsIkdoIiwiR2wiLCJIaCIsIkhsIiwiZ2V0Iiwic2V0IiwicHJvY2VzcyIsInZpZXciLCJvZmZzZXQiLCJpIiwiZ2V0VWludDMyIiwiVzE1aCIsIlcxNWwiLCJzMGgiLCJyb3RyU0giLCJzaHJTSCIsInMwbCIsInJvdHJTTCIsInNoclNMIiwiVzJoIiwiVzJsIiwiczFoIiwicm90ckJIIiwiczFsIiwicm90ckJMIiwiU1VNbCIsImFkZDRMIiwiU1VNaCIsImFkZDRIIiwic2lnbWExaCIsInNpZ21hMWwiLCJDSEloIiwiQ0hJbCIsIlQxbGwiLCJhZGQ1TCIsIlQxaCIsImFkZDVIIiwiVDFsIiwic2lnbWEwaCIsInNpZ21hMGwiLCJNQUpoIiwiTUFKbCIsImgiLCJsIiwiYWRkIiwiQWxsIiwiYWRkM0wiLCJhZGQzSCIsInJvdW5kQ2xlYW4iLCJmaWxsIiwiZGVzdHJveSIsImJ1ZmZlciIsIlNIQTUxMl8yMjQiLCJvdXRwdXRMZW4iLCJTSEE1MTJfMjU2IiwiU0hBMzg0Iiwic2hhNTEyIiwic2hhNTEyXzIyNCIsInNoYTUxMl8yNTYiLCJzaGEzODQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/@noble/hashes/esm/sha512.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/@noble/hashes/esm/utils.js":
/*!**************************************************!*\
  !*** ../node_modules/@noble/hashes/esm/utils.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   byteSwapIfBE: () => (/* binding */ byteSwapIfBE),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(rsc)/../node_modules/@noble/hashes/esm/cryptoNode.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(rsc)/../node_modules/@noble/hashes/esm/_assert.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\n// Cast array to different type\nconst u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift)=>word << 32 - shift | word >>> shift;\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift)=>word << shift | word >>> 32 - shift >>> 0;\nconst isLE = new Uint8Array(new Uint32Array([\n    0x11223344\n]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = (word)=>word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;\n// Conditionally byte swap if on a big-endian platform\nconst byteSwapIfBE = isLE ? (n)=>n : (n)=>byteSwap(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for(let i = 0; i < arr.length; i++){\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    _A: 65,\n    _F: 70,\n    _a: 97,\n    _f: 102\n};\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async ()=>{};\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== \"[object Object]\") throw new Error(\"Options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */ function randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues === \"function\") {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDcEUsb0ZBQW9GO0FBQ3BGLHNFQUFzRTtBQUN0RSxrRUFBa0U7QUFDbEUsOERBQThEO0FBQzlELCtEQUErRDtBQUMvRCwyRUFBMkU7QUFDN0I7QUFDQztBQUMvQywwQ0FBMEM7QUFDMUMsb0ZBQW9GO0FBQzdFLFNBQVNHLFFBQVFDLENBQUM7SUFDckIsT0FBUUEsYUFBYUMsY0FDaEJELEtBQUssUUFBUSxPQUFPQSxNQUFNLFlBQVlBLEVBQUVFLFdBQVcsQ0FBQ0MsSUFBSSxLQUFLO0FBQ3RFO0FBQ0EsK0JBQStCO0FBQ3hCLE1BQU1DLEtBQUssQ0FBQ0MsTUFBUSxJQUFJSixXQUFXSSxJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUYsSUFBSUcsVUFBVSxFQUFFO0FBQy9FLE1BQU1DLE1BQU0sQ0FBQ0osTUFBUSxJQUFJSyxZQUFZTCxJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUksS0FBS0MsS0FBSyxDQUFDUCxJQUFJRyxVQUFVLEdBQUcsSUFBSTtBQUN4RyxxQkFBcUI7QUFDZCxNQUFNSyxhQUFhLENBQUNSLE1BQVEsSUFBSVMsU0FBU1QsSUFBSUMsTUFBTSxFQUFFRCxJQUFJRSxVQUFVLEVBQUVGLElBQUlHLFVBQVUsRUFBRTtBQUM1RiwrREFBK0Q7QUFDeEQsTUFBTU8sT0FBTyxDQUFDQyxNQUFNQyxRQUFVLFFBQVUsS0FBS0EsUUFBV0QsU0FBU0MsTUFBTztBQUMvRSw2REFBNkQ7QUFDdEQsTUFBTUMsT0FBTyxDQUFDRixNQUFNQyxRQUFVLFFBQVNBLFFBQVUsU0FBVyxLQUFLQSxVQUFZLEVBQUc7QUFDaEYsTUFBTUUsT0FBTyxJQUFJbEIsV0FBVyxJQUFJUyxZQUFZO0lBQUM7Q0FBVyxFQUFFSixNQUFNLENBQUMsQ0FBQyxFQUFFLEtBQUssS0FB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QU1MLFNBQVMsQ0FBQztJQUN0QkMsTUFBTUssU0FBUyxHQUFHRCxJQUFJQyxTQUFTO0lBQy9CTCxNQUFNTSxRQUFRLEdBQUdGLElBQUlFLFFBQVE7SUFDN0JOLE1BQU1PLE1BQU0sR0FBRyxDQUFDZCxPQUFTTSxTQUFTTjtJQUNsQyxPQUFPTztBQUNYO0FBQ0E7O0NBRUMsR0FDTSxTQUFTVSxZQUFZQyxjQUFjLEVBQUU7SUFDeEMsSUFBSXZHLHdEQUFNQSxJQUFJLE9BQU9BLHdEQUFNQSxDQUFDd0csZUFBZSxLQUFLLFlBQVk7UUFDeEQsT0FBT3hHLHdEQUFNQSxDQUFDd0csZUFBZSxDQUFDLElBQUluRyxXQUFXa0c7SUFDakQ7SUFDQSxNQUFNLElBQUl2RCxNQUFNO0FBQ3BCLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcz8yMmM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCAoMjAyNS0wNC0zMCksIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcbmltcG9ydCB7IGJ5dGVzIGFzIGFieXRlcyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG4vLyBleHBvcnQgeyBpc0J5dGVzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbi8vIFdlIGNhbid0IHJldXNlIGlzQnl0ZXMgZnJvbSBfYXNzZXJ0LCBiZWNhdXNlIHNvbWVob3cgdGhpcyBjYXVzZXMgaHVnZSBwZXJmIGlzc3Vlc1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmV4cG9ydCBjb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnQgY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG4vLyBUaGUgcm90YXRlIGxlZnQgKGNpcmN1bGFyIGxlZnQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90bCA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgc2hpZnQpIHwgKCh3b3JkID4+PiAoMzIgLSBzaGlmdCkpID4+PiAwKTtcbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbi8vIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCBieXRlU3dhcCA9ICh3b3JkKSA9PiAoKHdvcmQgPDwgMjQpICYgMHhmZjAwMDAwMCkgfFxuICAgICgod29yZCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgKCh3b3JkID4+PiA4KSAmIDB4ZmYwMCkgfFxuICAgICgod29yZCA+Pj4gMjQpICYgMHhmZik7XG4vLyBDb25kaXRpb25hbGx5IGJ5dGUgc3dhcCBpZiBvbiBhIGJpZy1lbmRpYW4gcGxhdGZvcm1cbmV4cG9ydCBjb25zdCBieXRlU3dhcElmQkUgPSBpc0xFID8gKG4pID0+IG4gOiAobikgPT4gYnl0ZVN3YXAobik7XG4vLyBJbiBwbGFjZSBieXRlIHN3YXAgZm9yIFVpbnQzMkFycmF5XG5leHBvcnQgZnVuY3Rpb24gYnl0ZVN3YXAzMihhcnIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBieXRlU3dhcChhcnJbaV0pO1xuICAgIH1cbn1cbi8vIEFycmF5IHdoZXJlIGluZGV4IDB4ZjAgKDI0MCkgaXMgbWFwcGVkIHRvIHN0cmluZyAnZjAnXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIF9BOiA2NSwgX0Y6IDcwLCBfYTogOTcsIF9mOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fMCAmJiBjaGFyIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoYXIgLSBhc2NpaXMuXzA7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9BICYmIGNoYXIgPD0gYXNjaWlzLl9GKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX0EgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9hICYmIGNoYXIgPD0gYXNjaWlzLl9mKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX2EgLSAxMCk7XG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBhYnl0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgYWJ5dGVzKGEpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHRvU3RyLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbImNyeXB0byIsImJ5dGVzIiwiYWJ5dGVzIiwiaXNCeXRlcyIsImEiLCJVaW50OEFycmF5IiwiY29uc3RydWN0b3IiLCJuYW1lIiwidTgiLCJhcnIiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsInUzMiIsIlVpbnQzMkFycmF5IiwiTWF0aCIsImZsb29yIiwiY3JlYXRlVmlldyIsIkRhdGFWaWV3Iiwicm90ciIsIndvcmQiLCJzaGlmdCIsInJvdGwiLCJpc0xFIiwiYnl0ZVN3YXAiLCJieXRlU3dhcElmQkUiLCJuIiwiYnl0ZVN3YXAzMiIsImkiLCJsZW5ndGgiLCJoZXhlcyIsIkFycmF5IiwiZnJvbSIsIl8iLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiYnl0ZXNUb0hleCIsImhleCIsImFzY2lpcyIsIl8wIiwiXzkiLCJfQSIsIl9GIiwiX2EiLCJfZiIsImFzY2lpVG9CYXNlMTYiLCJjaGFyIiwiaGV4VG9CeXRlcyIsIkVycm9yIiwiaGwiLCJhbCIsImFycmF5IiwiYWkiLCJoaSIsIm4xIiwiY2hhckNvZGVBdCIsIm4yIiwidW5kZWZpbmVkIiwibmV4dFRpY2siLCJhc3luY0xvb3AiLCJpdGVycyIsInRpY2siLCJjYiIsInRzIiwiRGF0ZSIsIm5vdyIsImRpZmYiLCJ1dGY4VG9CeXRlcyIsInN0ciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwidG9CeXRlcyIsImRhdGEiLCJjb25jYXRCeXRlcyIsImFycmF5cyIsInN1bSIsInJlcyIsInBhZCIsInNldCIsIkhhc2giLCJjbG9uZSIsIl9jbG9uZUludG8iLCJ0b1N0ciIsImNoZWNrT3B0cyIsImRlZmF1bHRzIiwib3B0cyIsImNhbGwiLCJtZXJnZWQiLCJPYmplY3QiLCJhc3NpZ24iLCJ3cmFwQ29uc3RydWN0b3IiLCJoYXNoQ29ucyIsImhhc2hDIiwibXNnIiwidXBkYXRlIiwiZGlnZXN0IiwidG1wIiwib3V0cHV0TGVuIiwiYmxvY2tMZW4iLCJjcmVhdGUiLCJ3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyIsIndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzIiwicmFuZG9tQnl0ZXMiLCJieXRlc0xlbmd0aCIsImdldFJhbmRvbVZhbHVlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/@noble/hashes/esm/utils.js\n");

/***/ })

};
;